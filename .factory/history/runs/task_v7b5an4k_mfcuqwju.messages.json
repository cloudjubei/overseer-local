{
  "ada1bb79-e120-493b-b0ba-13d11951b42b": {
    "featureId": "ada1bb79-e120-493b-b0ba-13d11951b42b",
    "startDate": "2025-09-09T17:56:25.718Z",
    "messages": [
      {
        "role": "user",
        "content": "# Developer Agent Steps Execution\n\nYou are the Developer Agent. You will be assigned a single feature to implement. Your goal is to complete it by following these steps precisely.\n\n## Workflow\n\n1.  **Analyze the Feature**: Read the feature's title, description and rejection (if provided) to understand its goal.\n2.  **Consult the File Structure**: Use the provided `docs/FILE_ORGANISATION.md` to understand the project context.\n3.  **Implement**: Write or modify files to meet the feature's acceptance criteria. Use the `write_file`, `rename_file`, `delete_file`, `list_files` and `search_files` tools for all file operations.\n4.  **Complete the Feature**: When the feature is complete, you **MUST** call the `finish_feature` tool. This is your final step for a successful implementation.\n5.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_feature` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n## Notes\n\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\n#CURRENT TASK (ID: f67e8921-b197-40c9-9154-e95db8f27deb)\n##TITLE:\nUI Improvements\n##DESCRIPTION:\nVarious UI improvements to the app\n\n\n#ASSIGNED FEATURE: LiveData providers are project specific or global (ID: ada1bb79-e120-493b-b0ba-13d11951b42b)\n##DESCRIPTION: Make it possible to configure a LiveDataProvider as global or targeting  the project it's being made in - the views are in @src/renderer/screens/LiveDataView.tsx .\nCurrently we have the Agent prices provider - this should be global, as it gets the prices that all LLM agent runs use to show the cost per token.\nThere's a 2nd provider currently configured for this project - the BTC price getter - that one should be specific to this project (Overseer Local).\nResponsible classes are:\n@src/renderer/hooks/useLiveData.tsx and @src/renderer/services/liveDataService.ts\n\n\n\n\n#ACCEPTANCE CRITERIA:\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- write_file(filename: str, content: str) - Create or overwrite a file with the given content. Always use this to write code or docs.\n- rename_file(filename: str, new_filename: str) - Rename or move a file from one path to another.\n- delete_file(filename: str) - Delete a file. Use with caution and only when necessary.\n- run_test() -> str - Run the test for the current feature and return the output. Use to verify implementation.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n[object Object]\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\nAs responses to the tool calls you will send, you will also receive JSON objects in the form:\n```json\n{\n\"name\":\"tool_name\",\n\"result\":\"...\"\n}\n```\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"# File Organisation\\n\\nPurpose\\n- Provide a high-level map of the repository so contributors and agents can quickly find the right area.\\n- This is not a change log and not a per-file inventory.\\n\\nEditing Rules (read before updating)\\n- Only document major directories and subsystems. Do not list individual files.\\n- Keep bullets short (one sentence) and avoid \\\"New:\\\" or historical notes.\\n- When adding/removing a major directory or moving a subsystem, update a single bullet here.\\n- Prefer linking or pointing to deeper docs (README/OVERVIEW) rather than describing internals here.\\n- Never document build related artifacts.\\n\\nTop-Level Layout\\n- docs/: Project-wide documentation and specs; single source of truth for protocols and workflows.\\n- src/: Application source (Electron app: main, preload, renderer, and tooling).\\n  - live-data/: Main process live data service and types for live data services.\\n    - providers/: Pluggable provider implementations (e.g., agent-prices bridge, generic fetch-json).\\n    - registry.js: Provider registry to map service ids to providers.\\n    - store.js: Persistence for service configs and cached snapshots by service id.\\n    - types.js: Shared types and helpers (freshness policy, normalization, freshness computation).\\n  - renderer/: React UI (components, screens, hooks, services, navigation, preview runtime).\\n    - components/agents/: Agent-specific UI (status chips, run bullets, model selectors, project/cost/token chips).\\n    - services/: Renderer-side services (e.g., pricingService for LLM price lookup via IPC).\\n    - hooks/useShortcuts: Keyboard shortcuts provider; respects user-selected modifier and avoids interfering with text input.\\n  - tools/: Developer and agent tooling (preview analyzer, factory integration, helpers).\\n  - main.js: Electron main process entry.\\n  - preload.js: Safe IPC surface exposed to the renderer (exposes live data API).\\n- packages/: Local monorepo packages.\\n  - factory-ts/: Agent orchestration library (orchestrator, pricing, history, completion, git integration).\\n- scripts/: Project automation scripts and CLIs.\\n- Root config files: package.json, tsconfig.json, tailwind/postcss configs, vite configs, forge config, .env.\\n\\nWhere to Learn More\\n- Agents and roles: packages/factory-ts/docs (AGENT_*.md).\\n- Factory TS overview and APIs: packages/factory-ts (see README/OVERVIEW files in that package).\\n- Preview system: see src/renderer/preview and related docs in docs/ (preview usage and analyzer).\\n- IPC and factory integration: src/tools/factory (renderer bridge and main process handlers).\\n\\nConventions (brief)\\n- Keep cross-cutting documentation in docs/; place domain-specific or area-specific READMEs next to the code they describe.\\n- Use descriptive directory names and keep responsibilities separated by area (renderer vs main vs tools vs packages).\\n\\nEnvironment & Credentials\\n- .env at the repo root is used for local development (e.g., credentials consumed by tooling and factory-ts).\\n\\nNotes\\n- If you are unsure whether something belongs here, it probably belongs in a local README under its directory, with this file providing only a one-line pointer to that area.\\n\",\"src/renderer/screens/LiveDataView.tsx\":\"import { useState } from 'react';\\nimport type { LiveDataProvider, LiveDataProviderStatus } from '../../live-data/LiveDataTypes';\\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/Select';\\nimport { Switch } from '../components/ui/Switch';\\nimport useLiveData from '../hooks/useLiveData';\\n\\nfunction formatLastUpdated(ts: number | undefined | null) {\\n  if (!ts) return 'never';\\n  try {\\n    return new Date(ts).toLocaleString();\\n  } catch {\\n    return 'never';\\n  }\\n}\\n\\nfunction JsonBlock({ data }: { data: any }) {\\n  return (\\n    <pre className=\\\"mt-2 max-h-80 overflow-auto rounded bg-gray-50 p-2 text-xs text-gray-800 border\\\">\\n      {data == null ? 'No data available.' : JSON.stringify(data, null, 2)}\\n    </pre>\\n  );\\n}\\n\\ntype NewServiceForm = {\\n  id: string;\\n  name: string;\\n  description: string;\\n  url: string;\\n  freshnessPolicy: LiveDataProvider['freshnessPolicy'];\\n  autoEnabled: boolean;\\n  autoTrigger: 'onAppLaunch' | 'scheduled';\\n};\\n\\nexport default function LiveDataView() {\\n  const { services, servicesById, triggerUpdate, updateConfig, addService } = useLiveData()\\n  const [openViewer, setOpenViewer] = useState<Record<string, boolean>>({});\\n  const [loadingData, setLoadingData] = useState<Record<string, boolean>>({});\\n  const [serviceData, setServiceData] = useState<Record<string, any>>({});\\n  const [errorByService, setErrorByService] = useState<Record<string, string | undefined>>({});\\n\\n  const [showAddForm, setShowAddForm] = useState(false);\\n  const [savingNew, setSavingNew] = useState(false);\\n  const [addError, setAddError] = useState<string | undefined>(undefined);\\n  const [newSvc, setNewSvc] = useState<NewServiceForm>({\\n    id: '',\\n    name: '',\\n    description: '',\\n    url: '',\\n    freshnessPolicy: 'daily',\\n    autoEnabled: true,\\n    autoTrigger: 'onAppLaunch',\\n  });\\n\\n  const toggleViewer = async (s: LiveDataProviderStatus) => {\\n    const isOpen = !!openViewer[s.id];\\n    const next = { ...openViewer, [s.id]: !isOpen };\\n    setOpenViewer(next);\\n\\n    // If opening and no data loaded yet, try to fetch it now.\\n    if (!isOpen && serviceData[s.id] === undefined) {\\n      await fetchLatestForService(s);\\n    }\\n  };\\n\\n  const fetchLatestForService = async (s: LiveDataProviderStatus) => {\\n    setLoadingData(prev => ({ ...prev, [s.id]: true }));\\n    setErrorByService(prev => ({ ...prev, [s.id]: undefined }));\\n\\n    try {\\n      let data: any = null;\\n      if ((window as any).liveDataService?.getData) {\\n        data = await (window as any).liveDataService.getData(s.id);\\n      }\\n      setServiceData(prev => ({ ...prev, [s.id]: data }));\\n    } catch (e: any) {\\n      setErrorByService(prev => ({ ...prev, [s.id]: e?.message || 'Failed to load latest data' }));\\n    } finally {\\n      setLoadingData(prev => ({ ...prev, [s.id]: false }));\\n    }\\n  };\\n\\n  const handleUpdateNow = async (s: LiveDataProviderStatus) => {\\n    try {\\n      await triggerUpdate(s.id);\\n    } finally {\\n      // If the JSON viewer is open for this service, refresh its data preview to reflect latest updates\\n      if (openViewer[s.id]) {\\n        await fetchLatestForService(s);\\n      }\\n    }\\n  };\\n\\n  const resetAddForm = () => {\\n    setNewSvc({ id: '', name: '', description: '', url: '', freshnessPolicy: 'daily', autoEnabled: true, autoTrigger: 'onAppLaunch' });\\n    setAddError(undefined);\\n  };\\n\\n  const handleSaveNewService = async () => {\\n    setAddError(undefined);\\n    if (!newSvc.id || !newSvc.name) {\\n      setAddError('Please provide both an ID and a Name.');\\n      return;\\n    }\\n    // Basic URL check if provided\\n    if (newSvc.url && !/^https?:\\\\/\\\\//i.test(newSvc.url)) {\\n      setAddError('URL must start with http:// or https://');\\n      return;\\n    }\\n\\n    setSavingNew(true);\\n    try {\\n      const payload: LiveDataProvider = {\\n        id: newSvc.id.trim(),\\n        name: newSvc.name.trim(),\\n        description: newSvc.description?.trim() || '',\\n        lastUpdated: 0,\\n        freshnessPolicy: newSvc.freshnessPolicy,\\n        autoUpdate: { enabled: !!newSvc.autoEnabled, trigger: newSvc.autoTrigger },\\n        config: newSvc.url ? { url: newSvc.url.trim() } : {},\\n      };\\n      await addService(payload);\\n      setShowAddForm(false);\\n      resetAddForm();\\n    } catch (e: any) {\\n      setAddError(e?.message || 'Failed to add service');\\n    } finally {\\n      setSavingNew(false);\\n    }\\n  };\\n\\n  return (\\n    <div className=\\\"p-4\\\">\\n      <div className=\\\"flex items-center justify-between\\\">\\n        <h1 className=\\\"text-2xl font-bold\\\">Live Data</h1>\\n        <button\\n          className=\\\"px-3 py-1 rounded bg-blue-600 text-white hover:bg-blue-700\\\"\\n          onClick={() => setShowAddForm(v => !v)}\\n        >\\n          {showAddForm ? 'Cancel' : '+ Add provider'}\\n        </button>\\n      </div>\\n\\n      {showAddForm && (\\n        <div className=\\\"mt-4 border rounded p-3 bg-white\\\">\\n          <div className=\\\"font-semibold mb-2\\\">Add live data provider</div>\\n\\n          {addError && <div className=\\\"text-sm text-red-700 mb-2\\\">{addError}</div>}\\n\\n          <div className=\\\"grid grid-cols-1 md:grid-cols-2 gap-4\\\">\\n            <div className=\\\"flex flex-col gap-1\\\">\\n              <label className=\\\"text-sm font-medium\\\">ID</label>\\n              <input\\n                className=\\\"border rounded px-2 py-1 text-sm\\\"\\n                value={newSvc.id}\\n                onChange={e => setNewSvc({ ...newSvc, id: e.target.value })}\\n                placeholder=\\\"unique-id\\\"\\n              />\\n              <span className=\\\"text-xs text-gray-500\\\">Must be unique. For custom JSON providers, choose any id.</span>\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1\\\">\\n              <label className=\\\"text-sm font-medium\\\">Name</label>\\n              <input\\n                className=\\\"border rounded px-2 py-1 text-sm\\\"\\n                value={newSvc.name}\\n                onChange={e => setNewSvc({ ...newSvc, name: e.target.value })}\\n                placeholder=\\\"Display name\\\"\\n              />\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1 md:col-span-2\\\">\\n              <label className=\\\"text-sm font-medium\\\">Description</label>\\n              <textarea\\n                className=\\\"border rounded px-2 py-1 text-sm\\\"\\n                value={newSvc.description}\\n                onChange={e => setNewSvc({ ...newSvc, description: e.target.value })}\\n                placeholder=\\\"What does this provider fetch?\\\"\\n              />\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1 md:col-span-2\\\">\\n              <label className=\\\"text-sm font-medium\\\">Fetch URL (for JSON provider)</label>\\n              <input\\n                className=\\\"border rounded px-2 py-1 text-sm\\\"\\n                value={newSvc.url}\\n                onChange={e => setNewSvc({ ...newSvc, url: e.target.value })}\\n                placeholder=\\\"https://example.com/data.json\\\"\\n              />\\n              <span className=\\\"text-xs text-gray-500\\\">If provided, this provider will fetch JSON from the URL using the generic fetcher.</span>\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1\\\">\\n              <label className=\\\"text-sm font-medium\\\">Freshness policy</label>\\n              <Select\\n                value={newSvc.freshnessPolicy}\\n                onValueChange={(val: LiveDataProvider['freshnessPolicy']) =>\\n                  setNewSvc({ ...newSvc, freshnessPolicy: val })\\n                }\\n              >\\n                <SelectTrigger size=\\\"sm\\\">\\n                  <SelectValue placeholder=\\\"Select policy\\\" />\\n                </SelectTrigger>\\n                <SelectContent>\\n                  <SelectItem value=\\\"daily\\\">Daily</SelectItem>\\n                  <SelectItem value=\\\"weekly\\\">Weekly</SelectItem>\\n                  <SelectItem value=\\\"monthly\\\">Monthly</SelectItem>\\n                </SelectContent>\\n              </Select>\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-2\\\">\\n              <Switch\\n                checked={!!newSvc.autoEnabled}\\n                onCheckedChange={(checked) => setNewSvc({ ...newSvc, autoEnabled: checked })}\\n                label=\\\"Automated checks\\\"\\n              />\\n              {newSvc.autoEnabled && (\\n                <div className=\\\"flex items-center gap-2\\\">\\n                  <span className=\\\"text-sm text-[var(--text-secondary)]\\\">When:</span>\\n                  <Select\\n                    value={newSvc.autoTrigger}\\n                    onValueChange={(val: 'onAppLaunch' | 'scheduled') => setNewSvc({ ...newSvc, autoTrigger: val })}\\n                  >\\n                    <SelectTrigger size=\\\"sm\\\" className=\\\"w-[200px]\\\">\\n                      <SelectValue />\\n                    </SelectTrigger>\\n                    <SelectContent>\\n                      <SelectItem value=\\\"onAppLaunch\\\">On app launch</SelectItem>\\n                      <SelectItem value=\\\"scheduled\\\">On schedule</SelectItem>\\n                    </SelectContent>\\n                  </Select>\\n                </div>\\n              )}\\n            </div>\\n          </div>\\n\\n          <div className=\\\"mt-3 flex gap-2\\\">\\n            <button\\n              disabled={savingNew}\\n              onClick={handleSaveNewService}\\n              className={`px-3 py-1 rounded text-white ${savingNew ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'}`}\\n            >\\n              {savingNew ? 'Adding…' : 'Add provider'}\\n            </button>\\n            <button\\n              disabled={savingNew}\\n              onClick={() => { setShowAddForm(false); resetAddForm(); }}\\n              className=\\\"px-3 py-1 rounded border text-gray-800 hover:bg-gray-50\\\"\\n            >\\n              Cancel\\n            </button>\\n          </div>\\n        </div>\\n      )}\\n\\n      {services.length === 0 ? (\\n        <div className=\\\"mt-4 text-gray-700\\\">No live data services are configured.</div>\\n      ) : (\\n        <div className=\\\"mt-4 space-y-3\\\">\\n          {services.map((s) => (\\n            <div key={s.id} className=\\\"border rounded p-3\\\">\\n              <div className=\\\"flex items-center justify-between\\\">\\n                <div>\\n                  <div className=\\\"font-semibold\\\">{s.name}</div>\\n                  {s.description && <div className=\\\"text-sm text-gray-600\\\">{s.description}</div>}\\n                </div>\\n                <div className=\\\"flex items-center gap-2\\\">\\n                  <button\\n                    onClick={() => toggleViewer(s)}\\n                    className=\\\"px-3 py-1 rounded border text-gray-800 hover:bg-gray-50\\\"\\n                  >\\n                    {openViewer[s.id] ? 'Hide data' : 'Show data'}\\n                  </button>\\n                  <button\\n                    disabled={!!s.isUpdating}\\n                    onClick={() => handleUpdateNow(s)}\\n                    className={`px-3 py-1 rounded text-white ${s.isUpdating ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'}`}\\n                  >\\n                    {s.isUpdating ? 'Updating…' : 'Update now'}\\n                  </button>\\n                </div>\\n              </div>\\n\\n              {/* Status row */}\\n              <div className=\\\"mt-2 text-sm text-gray-700 flex flex-wrap gap-4\\\">\\n                <span>\\n                  Status: <span className={s.isFresh ? 'text-green-600' : 'text-amber-700'}>{s.isFresh ? 'Up to date' : 'Stale'}</span>\\n                </span>\\n                <span>Last updated: {formatLastUpdated(s.lastUpdated)}</span>\\n              </div>\\n\\n              {/* JSON viewer */}\\n              {openViewer[s.id] && (\\n                <div className=\\\"mt-3\\\">\\n                  {loadingData[s.id] ? (\\n                    <div className=\\\"text-sm text-gray-600\\\">Loading latest data…</div>\\n                  ) : errorByService[s.id] ? (\\n                    <div className=\\\"text-sm text-red-600\\\">{errorByService[s.id]}</div>\\n                  ) : (\\n                    <JsonBlock data={serviceData[s.id]} />\\n                  )}\\n                  <div className=\\\"mt-2\\\">\\n                    <button\\n                      onClick={() => fetchLatestForService(s)}\\n                      className=\\\"text-xs text-blue-700 underline\\\"\\n                    >\\n                      Refresh data preview\\n                    </button>\\n                  </div>\\n                </div>\\n              )}\\n\\n              {/* Configuration controls */}\\n              <div className=\\\"mt-3 grid grid-cols-1 md:grid-cols-2 gap-4\\\">\\n                {/* Freshness policy */}\\n                <div className=\\\"flex flex-col gap-1\\\">\\n                  <label className=\\\"text-sm font-medium text-[var(--text-primary)]\\\">Freshness policy</label>\\n                  <Select\\n                    value={s.freshnessPolicy}\\n                    onValueChange={(val: LiveDataProvider['freshnessPolicy']) =>\\n                      updateConfig(s.id, { freshnessPolicy: val })\\n                    }\\n                  >\\n                    <SelectTrigger size=\\\"sm\\\">\\n                      <SelectValue placeholder=\\\"Select policy\\\" />\\n                    </SelectTrigger>\\n                    <SelectContent>\\n                      <SelectItem value=\\\"daily\\\">Daily</SelectItem>\\n                      <SelectItem value=\\\"weekly\\\">Weekly</SelectItem>\\n                      <SelectItem value=\\\"monthly\\\">Monthly</SelectItem>\\n                    </SelectContent>\\n                  </Select>\\n                </div>\\n\\n                {/* Auto-update toggle and trigger */}\\n                <div className=\\\"flex flex-col gap-2\\\">\\n                  <Switch\\n                    checked={!!s.autoUpdate?.enabled}\\n                    onCheckedChange={(checked) =>\\n                      updateConfig(s.id, { autoUpdate: { ...(s.autoUpdate || { trigger: 'onAppLaunch' }), enabled: checked } })\\n                    }\\n                    label=\\\"Automated checks\\\"\\n                  />\\n                  {s.autoUpdate?.enabled && (\\n                    <div className=\\\"flex items-center gap-2\\\">\\n                      <span className=\\\"text-sm text-[var(--text-secondary)]\\\">When:</span>\\n                      <Select\\n                        value={s.autoUpdate?.trigger || 'onAppLaunch'}\\n                        onValueChange={(val: 'onAppLaunch' | 'scheduled') =>\\n                          updateConfig(s.id, { autoUpdate: { ...(s.autoUpdate || { enabled: true }), trigger: val } })\\n                        }\\n                      >\\n                        <SelectTrigger size=\\\"sm\\\" className=\\\"w-[200px]\\\">\\n                          <SelectValue />\\n                        </SelectTrigger>\\n                        <SelectContent>\\n                          <SelectItem value=\\\"onAppLaunch\\\">On app launch</SelectItem>\\n                          <SelectItem value=\\\"scheduled\\\">On schedule</SelectItem>\\n                        </SelectContent>\\n                      </Select>\\n                    </div>\\n                  )}\\n                </div>\\n              </div>\\n            </div>\\n          ))}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\",\"src/renderer/hooks/useLiveData.tsx\":\"import { useEffect, useState } from 'react';\\nimport { LiveDataProvider, LiveDataProviderStatus } from '../../live-data/LiveDataTypes';\\nimport { liveDataService } from '../services/liveDataService';\\n\\nexport default function useLiveData() {\\n  const [services, setServices] = useState<LiveDataProviderStatus[]>([]);\\n  const [servicesById, setServicesById] = useState<Record<string,LiveDataProviderStatus>>({});\\n\\n  const update = async () => {\\n      const services = await liveDataService.getStatus()\\n      updateCurrentServices(services)\\n  }\\n  const updateCurrentServices = (services: LiveDataProvider[]) => {\\n    setServices(services)\\n    \\n    let newServicesById : Record<string,LiveDataProvider> = {}\\n    for(const s of services){\\n      newServicesById[s.id] = s\\n    }\\n    setServicesById(newServicesById)\\n  }\\n  \\n  useEffect(() => {\\n    update();\\n\\n    const unsubscribe = liveDataService.subscribe(updateCurrentServices);\\n\\n    return () => {\\n      unsubscribe();\\n    };\\n  }, []);\\n\\n  const triggerUpdate = async (serviceId: string) : Promise<LiveDataProviderStatus | undefined> =>  {\\n    return await liveDataService.triggerUpdate(serviceId)\\n  }\\n  const updateConfig = async (serviceId: string, updates: Partial<Omit<LiveDataProvider,\\\"id\\\">>) : Promise<LiveDataProviderStatus> =>  {\\n    return liveDataService.updateConfig(serviceId, updates)\\n  }\\n  const addService = async (service: LiveDataProvider) : Promise<LiveDataProviderStatus> => {\\n    return await liveDataService.addService(service)\\n  }\\n  const removeService = async (serviceId: string) : Promise<boolean> => {\\n    return await liveDataService.removeService(serviceId)\\n  }\\n\\n  return { services, servicesById, triggerUpdate, updateConfig, addService, removeService };\\n}\",\"src/renderer/services/liveDataService.ts\":\"import { LiveDataProvider, LiveDataProviderStatus } from \\\"src/live-data/LiveDataTypes\\\"\\n\\nexport type LiveDataService = {\\n  subscribe: (callback: (statuses: LiveDataProviderStatus[]) => void) => () => void\\n  getStatus: () => Promise<LiveDataProviderStatus[]>\\n  triggerUpdate: (serviceId: string) => Promise<LiveDataProviderStatus | undefined>\\n  updateConfig: (serviceId: string, updates: Partial<Omit<LiveDataProvider, \\\"id\\\">>) => Promise<LiveDataProviderStatus>\\n  getData: (serviceId: string) => Promise<any>\\n  addService: (service: LiveDataProvider) => Promise<LiveDataProviderStatus>\\n  removeService: (serviceId: string) => Promise<boolean>\\n}\\n\\nexport const liveDataService: LiveDataService = { ...window.liveDataService }\"}\n\nBegin now.",
        "featureId": "ada1bb79-e120-493b-b0ba-13d11951b42b",
        "agentType": "developer",
        "turn": 0,
        "source": "initial",
        "createdAt": "2025-09-09T17:59:19.643Z"
      },
      {
        "role": "assistant",
        "content": "{\"thoughts\":\"I will search for the live data types and main process implementation to add a scope (global/project) attribute, update the renderer hook/service to pass project context and filter accordingly, and then update the UI to allow configuring scope when adding providers and display scope. Finally, ensure the agent prices is marked global and BTC provider is project-specific. I will look for src/live-data files to modify types and registry/store if available. If main process side is missing, I may be constrained to renderer-only changes and will flag blockers if needed.\",\"tool_calls\":[{\"tool_name\":\"search_files\",\"arguments\":{\"query\":\"LiveDataTypes provider scope global project store registry\",\"path\":\".\"}}]}",
        "featureId": "ada1bb79-e120-493b-b0ba-13d11951b42b",
        "agentType": "developer",
        "turn": 0,
        "askedAt": "2025-09-09T17:56:25.727Z",
        "createdAt": "2025-09-09T17:59:19.643Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"search_files\",\"result\":[\".env\",\".eslintrc.cjs\",\".factory/history/runs/task_0do2g64m_mf62jwn1.messages.json\",\".factory/history/runs/task_1d8nb33q_mf5vyyh8.messages.json\",\".factory/history/runs/task_1uz7j29o_mfctddve.messages.json\",\".factory/history/runs/task_22r07lbo_mfa9td9t.messages.json\",\".factory/history/runs/task_2fk45sdy_mfbrx2xr.messages.json\",\".factory/history/runs/task_31t7beqj_mf62wgt6.messages.json\",\".factory/history/runs/task_3fchhkdg_mf5z7aj7.messages.json\",\".factory/history/runs/task_3grutzv8_mfbs8mwt.messages.json\",\".factory/history/runs/task_3iweghyx_mfbs7xd9.messages.json\",\".factory/history/runs/task_4s4aki18_mf5wiujm.messages.json\",\".factory/history/runs/task_5gy6omvl_mf7i2ciw.messages.json\",\".factory/history/runs/task_7btxi72t_mfbqd2gy.messages.json\",\".factory/history/runs/task_7eswtk15_mf5z945m.messages.json\",\".factory/history/runs/task_8398rmcq_mfcp01za.messages.json\",\".factory/history/runs/task_86bnwhy1_mfbjfysa.messages.json\",\".factory/history/runs/task_9ujdo52r_mf7wlxqj.messages.json\",\".factory/history/runs/task_a2ft0pl7_mfa6tsle.messages.json\",\".factory/history/runs/task_b7qn46xu_mfbps5hg.messages.json\",\".factory/history/runs/task_bwy65nx0_mfbnpep6.messages.json\",\".factory/history/runs/task_c1gnwubw_mf5wuag3.messages.json\",\".factory/history/runs/task_ciaibf8p_mf5zcwv5.messages.json\",\".factory/history/runs/task_esu6sa2b_mfa9miva.messages.json\",\".factory/history/runs/task_f215tuhn_mfckldqx.messages.json\",\".factory/history/runs/task_g173ugp0_mfb2nxfr.messages.json\",\".factory/history/runs/task_gdqk5k4e_mfaaa3sb.messages.json\",\".factory/history/runs/task_h5bb811q_mfbi0mv4.messages.json\",\".factory/history/runs/task_hd6krtqi_mfckmqfr.messages.json\",\".factory/history/runs/task_hfohsvlx_mfa8vbo7.messages.json\",\".factory/history/runs/task_hkwsk2tm_mfbr9t4f.messages.json\",\".factory/history/runs/task_hrs3cx5j_mf60yquv.messages.json\",\".factory/history/runs/task_j3cdsg4i_mfbjf71u.messages.json\",\".factory/history/runs/task_jhd3zi9c_mfbp1mnh.messages.json\",\".factory/history/runs/task_ju2k8wrr_mfbqc9ps.messages.json\",\".factory/history/runs/task_lus1mk8g_mfct54he.messages.json\",\".factory/history/runs/task_lyfx4cup_mfbnf7u4.messages.json\",\".factory/history/runs/task_m4m6sc97_mfbr9mao.messages.json\",\".factory/history/runs/task_ml8008ls_mfboxlz2.messages.json\",\".factory/history/runs/task_n5m3772l_mfb1qwzi.messages.json\",\".factory/history/runs/task_nk3m7xx3_mfbq3re8.messages.json\",\".factory/history/runs/task_o8mze91l_mfbrat05.messages.json\",\".factory/history/runs/task_om23c96f_mfbpsszd.messages.json\",\".factory/history/runs/task_qgk4uadu_mf5zf4zr.messages.json\",\".factory/history/runs/task_qi46wshp_mfbnggpt.messages.json\",\".factory/history/runs/task_qvmdlgil_mfb0fkq3.messages.json\",\".factory/history/runs/task_tstc9kee_mf60n4p6.messages.json\",\".factory/history/runs/task_u1gbvefb_mf8uuiqf.messages.json\",\".factory/history/runs/task_ufk6ljdr_mf5v5ujo.messages.json\",\".factory/history/runs/task_ulyvpmo7_mfcju6gk.messages.json\",\".factory/history/runs/task_up4z6g5l_mfbjehri.messages.json\",\".factory/history/runs/task_w8hkl6bk_mfbqy1j7.messages.json\",\".factory/history/runs/task_y0ieg2q5_mfbr8ezh.messages.json\",\".factory/history/runs/task_zniegpyw_mfbrx7nv.messages.json\",\".factory/history/runs.json\",\".factory/prices.json\",\".gitignore\",\"README.md\",\"docs/APP_RELEASE.md\",\"docs/BACKEND_API_SPEC.md\",\"docs/BUILD_SIGNING.md\",\"docs/COMPONENT_PREVIEWS.md\",\"docs/FILE_ORGANISATION.md\",\"docs/MULTI_PLATFORM_ARCHITECTURE.md\",\"docs/OFFLINE_SYNC_STRATEGY.md\",\"docs/PLATFORM_ADAPTATIONS.md\",\"docs/PREVIEW_ANALYZER.md\",\"docs/PREVIEW_RUN_TOOL.md\",\"docs/PREVIEW_TOOL.md\",\"docs/SHARED_LOGIC_STRATEGY.md\",\"docs/STANDARDS.md\",\"docs/design/COMPONENTS.md\",\"docs/design/DESIGN_SYSTEM.md\",\"docs/tasks/task_example.json\",\"docs/tasks/task_format.py\",\"docs/ux/LINEAR_UX_GUIDELINES.md\",\"package-lock.json\",\"packages/factory-ts/src/pricing.ts\",\"packages/factory-ts/src/types.ts\",\"projects/main/chats/5b14fca8-9df7-4360-b09d-5c53b9d83828.json\",\"projects/main/chats/c983e16e-53e5-4d0a-9c71-37c9715606da.json\",\"projects/main.json\",\"projects/thefactory-tools.json\",\"scripts/setup-linting-formatting.js\",\"src/chat/ChatsManager.js\",\"src/chat/ChatsStorage.js\",\"src/chat/LLMProvider.js\",\"src/files/FilesManager.js\",\"src/files/FilesStorage.js\",\"src/index.css\",\"src/ipcHandlersKeys.js\",\"src/live-data/LiveDataManager.js\",\"src/live-data/LiveDataRegistry.js\",\"src/live-data/LiveDataStore.js\",\"src/live-data/LiveDataTypes.ts\",\"src/live-data/providers/agentPricesProvider.js\",\"src/live-data/providers/fetchJsonProvider.js\",\"src/main.js\",\"src/managers.js\",\"src/notifications/NotificationsManager.js\",\"src/notifications/NotificationsStorage.js\",\"src/preload.js\",\"src/projects/ProjectsManager.js\",\"src/projects/ProjectsValidator.js\",\"src/renderer/App.tsx\",\"src/renderer/components/agents/AgentRunBullet.tsx\",\"src/renderer/components/agents/AgentRunRow.tsx\",\"src/renderer/components/agents/CostChip.tsx\",\"src/renderer/components/agents/ModelChip.tsx\",\"src/renderer/components/agents/ProjectChip.tsx\",\"src/renderer/components/tasks/DependencySelector.tsx\",\"src/renderer/components/tasks/FeatureForm.tsx\",\"src/renderer/components/tasks/TaskCard.tsx\",\"src/renderer/components/ui/CommandMenu.tsx\",\"src/renderer/components/ui/Modal.tsx\",\"src/renderer/components/ui/ShortcutsHelp.tsx\",\"src/renderer/components/ui/Toast.tsx\",\"src/renderer/components/ui/previews.tsx\",\"src/renderer/hooks/useAgents.ts\",\"src/renderer/hooks/useChats.tsx\",\"src/renderer/hooks/useFiles.tsx\",\"src/renderer/hooks/useLLMConfig.ts\",\"src/renderer/hooks/useLiveData.tsx\",\"src/renderer/hooks/useNotifications.ts\",\"src/renderer/hooks/useProjectSettings.ts\",\"src/renderer/hooks/useReferencesAutocomplete.ts\",\"src/renderer/hooks/useShortcuts.tsx\",\"src/renderer/hooks/useTasks.tsx\",\"src/renderer/navigation/ModalHost.tsx\",\"src/renderer/navigation/Navigator.tsx\",\"src/renderer/navigation/SidebarView.tsx\",\"src/renderer/navigation/UnsavedChanges.ts\",\"src/renderer/preview/mocks/coreMocks.tsx\",\"src/renderer/preview/previewHost.tsx\",\"src/renderer/preview/previewRegistry.tsx\",\"src/renderer/preview/previewTypes.ts\",\"src/renderer/preview/withPreview.tsx\",\"src/renderer/projects/ProjectContext.tsx\",\"src/renderer/projects/ProjectManagerModal.tsx\",\"src/renderer/projects/projectIcons.ts\",\"src/renderer/projects/validateProject.ts\",\"src/renderer/screens/AgentsView.tsx\",\"src/renderer/screens/AllAgentsView.tsx\",\"src/renderer/screens/ChatView.tsx\",\"src/renderer/screens/LiveDataView.tsx\",\"src/renderer/screens/SettingsView.tsx\",\"src/renderer/services/agentsService.ts\",\"src/renderer/services/chatsService.ts\",\"src/renderer/services/filesService.ts\",\"src/renderer/services/liveDataService.ts\",\"src/renderer/services/notificationsService.ts\",\"src/renderer/services/pricingService.ts\",\"src/renderer/services/projectsService.ts\",\"src/renderer/services/settingsService.ts\",\"src/renderer/services/tasksService.ts\",\"src/renderer/tasks/BoardView.tsx\",\"src/renderer/tasks/TaskDetailsView.tsx\",\"src/renderer/tasks/TasksListView.tsx\",\"src/renderer/utils/LLMConfigManager.ts\",\"src/settings/SettingsLLMConfigModal.tsx\",\"src/settings/SettingsManager.js\",\"src/settings/appSettings.js\",\"src/settings/projectSettings.js\",\"src/tasks/TasksManager.js\",\"src/tasks/TasksStorage.js\",\"src/tools/factory/mainOrchestrator.js\",\"src/tools/factory/orchestratorBridge.ts\",\"src/tools/preview/analyzer.js\",\"src/types/external.d.ts\",\"src/types/settings.ts\",\"tasks/00e54231-df30-438d-b119-983e218ffc59/task.json\",\"tasks/0aab94ca-1802-4cd4-a873-5b339a6d20ca/task.json\",\"tasks/0e0f9d33-0e40-47dd-ba1f-546de712ff7d/task.json\",\"tasks/22562d2d-39cc-4d25-8ae7-0945b888b2d5/task.json\",\"tasks/2cd244ee-c255-487c-882c-c28cd857156e/task.json\",\"tasks/38477f37-1d05-428f-9045-5400d7508eef/task.json\",\"tasks/46cb9c12-219f-491c-b881-68bd417c508d/task.json\",\"tasks/5204b934-7bb9-42dd-89b5-ea1b178cd33b/task.json\",\"tasks/56af182c-f774-40e0-8927-941006bac81b/task.json\",\"tasks/7dbda629-2ad6-41bb-b20a-2e1e32bdce6a/task.json\",\"tasks/7e07f377-262d-4ffc-a702-fa20ef521315/task.json\",\"tasks/91ce08a7-8637-4f7f-a2e4-fd6bcb16df85/task.json\",\"tasks/9b6fcd9f-86b9-4a95-bf03-e3cf51431be4/task.json\",\"tasks/9eccbb8c-2c9e-44bb-a695-4deeac8d7f26/task.json\",\"tasks/bccf261a-aa2f-4b4d-bce5-4fa1f2be035a/task.json\",\"tasks/dea3f9d3-9bc8-4702-acc6-4d065af34e94/task.json\",\"tasks/ef63de20-fc75-421c-9cb8-10f8287961af/task.json\",\"tasks/f1f12817-8f44-4f92-9b2f-af5910289a13/task.json\",\"tasks/f375e3cb-f377-43b5-bb79-b2ffbf778d15/task.json\",\"tasks/f67e8921-b197-40c9-9154-e95db8f27deb/task.json\",\"tasks/fa757374-68c9-42a3-99e0-28c909b01624/task.json\",\"tasks/ffc07e5a-e89d-4094-958a-90f9e5a4d67d/task.json\"]}]",
        "featureId": "ada1bb79-e120-493b-b0ba-13d11951b42b",
        "agentType": "developer",
        "turn": 0,
        "source": "tools",
        "createdAt": "2025-09-09T17:59:19.643Z"
      },
      {
        "role": "assistant",
        "content": "{\"thoughts\":\"I'll open the relevant files to understand current data structures and IPC. Then I'll add a scope field, plumb it through main process store/manager and renderer UI. Finally, set Agent Prices to global and BTC price provider to project specific.\",\"tool_calls\":[{\"tool_name\":\"read_files\",\"arguments\":{\"paths\":[\"src/live-data/LiveDataTypes.ts\",\"src/live-data/LiveDataManager.js\",\"src/live-data/LiveDataRegistry.js\",\"src/live-data/LiveDataStore.js\",\"src/live-data/providers/agentPricesProvider.js\",\"src/live-data/providers/fetchJsonProvider.js\",\"src/preload.js\",\"src/main.js\",\"src/renderer/projects/ProjectContext.tsx\",\"src/renderer/screens/LiveDataView.tsx\",\"src/renderer/hooks/useLiveData.tsx\",\"src/renderer/services/liveDataService.ts\"]}}]}",
        "featureId": "ada1bb79-e120-493b-b0ba-13d11951b42b",
        "agentType": "developer",
        "turn": 1,
        "askedAt": "2025-09-09T17:56:35.165Z",
        "createdAt": "2025-09-09T17:59:19.643Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"read_files\",\"result\":\"{\\\"src/live-data/LiveDataTypes.ts\\\":\\\"export type LiveDataProviderFreshnessPolicy = 'daily' | 'weekly' | 'monthly';\\\\nexport type LiveDataProviderAutoUpdateTrigger = 'onAppLaunch' | 'scheduled';\\\\n\\\\nexport interface LiveDataProviderAutoUpdateSettings {\\\\n  enabled: boolean;\\\\n  trigger: LiveDataProviderAutoUpdateTrigger;\\\\n  time?: number; // Unix timestamp\\\\n}\\\\n\\\\nexport interface LiveDataProvider {\\\\n  id: string;\\\\n  name: string;\\\\n  description: string;\\\\n  lastUpdated: number; // Unix timestamp\\\\n  freshnessPolicy: LiveDataProviderFreshnessPolicy;\\\\n  autoUpdate: LiveDataProviderAutoUpdateSettings;\\\\n  config: any; // Service-specific configuration\\\\n}\\\\n\\\\nexport interface LiveDataProviderStatus extends LiveDataProvider {\\\\n  isUpdating?: boolean;\\\\n  isFresh?: boolean;\\\\n};\\\\n\\\",\\\"src/live-data/LiveDataManager.js\\\":\\\"import { ipcMain } from 'electron';\\\\nimport IPC_HANDLER_KEYS from '../ipcHandlersKeys';\\\\nimport { LiveDataStore } from './LiveDataStore';\\\\nimport { LiveDataRegistry } from './LiveDataRegistry';\\\\nimport { createAgentPricesProvider } from './providers/agentPricesProvider';\\\\nimport { createFetchJsonProvider } from './providers/fetchJsonProvider';\\\\n\\\\nconst DEFAULT_SERVICES = [\\\\n  {\\\\n    id: 'agent-prices',\\\\n    name: 'Agent Prices',\\\\n    description: 'Fetches the latest prices for common AI models from various providers.',\\\\n    freshnessPolicy: 'daily',\\\\n    autoUpdate: { enabled: true, trigger: 'onAppLaunch' },\\\\n    lastUpdated: 0,\\\\n    config: { url: 'https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json' },\\\\n    isUpdating: false,\\\\n  },\\\\n  // Example slot for a dynamic JSON fetch service (user can add more via UI in future)\\\\n  // { id: 'my-json-service', name: 'My JSON', description: 'Fetches custom JSON', freshnessPolicy: 'weekly', autoUpdate: { enabled: false }, config: { url: 'https://example.com/data.json' } }\\\\n];\\\\n\\\\nexport class LiveDataManager {\\\\n  constructor(projectRoot, window) {\\\\n    this.projectRoot = projectRoot;\\\\n    this.window = window;\\\\n\\\\n    this.store = new LiveDataStore();\\\\n    this.registry = new LiveDataRegistry();\\\\n    this._ipcBound = false;\\\\n\\\\n    this.services = this._loadServices();\\\\n\\\\n    // Register built-in providers\\\\n    this.registry.register(createAgentPricesProvider(this.store));\\\\n    // Generic provider enables future-proof dynamic services by URL\\\\n    this.registry.register(createFetchJsonProvider(this.store));\\\\n  }\\\\n\\\\n  _loadServices() {\\\\n    const stored = this.store.getServices();\\\\n    if (stored && Array.isArray(stored)) {\\\\n      const normalized = stored.map(s => normalizeService(s));\\\\n      // Ensure defaults exist\\\\n      const ids = new Set(normalized.map(s => s.id));\\\\n      for (const def of DEFAULT_SERVICES) {\\\\n        if (!ids.has(def.id)) normalized.push(normalizeService(def));\\\\n      }\\\\n      return normalized;\\\\n    }\\\\n    return DEFAULT_SERVICES.map(s => normalizeService(s));\\\\n  }\\\\n\\\\n  _saveServices() {\\\\n    this.store.setServices(this.services);\\\\n  }\\\\n\\\\n  async init() {\\\\n    this._registerIpcHandlers();\\\\n    this._maybeTriggerOnLaunchUpdates();\\\\n  }\\\\n\\\\n  _registerIpcHandlers() {\\\\n    if (this._ipcBound) return;\\\\n\\\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_GET_STATUS, () => this.getServicesStatus());\\\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_TRIGGER_UPDATE, (_event, { serviceId }) => this.triggerUpdate(serviceId));\\\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_UPDATE_CONFIG, (_event, { serviceId, updates }) => this.updateServiceConfig(serviceId, updates));\\\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_GET_DATA, (_event, { serviceId }) => this.getServiceData(serviceId));\\\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_ADD_SERVICE, (_event, { service }) => this.addService(service));\\\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_REMOVE_SERVICE, (_event, { serviceId }) => this.removeService(serviceId));\\\\n\\\\n    this._ipcBound = true;\\\\n  }\\\\n\\\\n  getServicesStatus() {\\\\n    return this.services.map(svc => ({ ...svc, isFresh: computeIsFresh(svc) }));\\\\n  }\\\\n\\\\n  updateServiceConfig(serviceId, updates) {\\\\n    const idx = this.services.findIndex(s => s.id === serviceId);\\\\n    if (idx === -1) return null;\\\\n    const merged = normalizeService({ ...this.services[idx], ...updates });\\\\n    this.services[idx] = merged;\\\\n    this._saveServices();\\\\n    this._emitStatus();\\\\n    return merged;\\\\n  }\\\\n\\\\n  addService(service) {\\\\n    // Allows users to add new services by specifying id, name, url, and update settings.\\\\n    if (!service?.id) throw new Error('Service id is required');\\\\n    const exists = this.services.some(s => s.id === service.id);\\\\n    if (exists) throw new Error('Service with this id already exists');\\\\n\\\\n    // If service.type is 'fetch-json' we keep its id unique and will use generic provider.\\\\n    // If service.id matches a provider id (like 'agent-prices'), it will use that provider.\\\\n\\\\n    const merged = normalizeService(service);\\\\n    this.services.push(merged);\\\\n    this._saveServices();\\\\n    this._emitStatus();\\\\n    return merged;\\\\n  }\\\\n\\\\n  removeService(serviceId) {\\\\n    const idx = this.services.findIndex(s => s.id === serviceId);\\\\n    if (idx === -1) return false;\\\\n    this.services.splice(idx, 1);\\\\n    this._saveServices();\\\\n    this._emitStatus();\\\\n    return true;\\\\n  }\\\\n\\\\n  async triggerUpdate(serviceId) {\\\\n    const svc = this.services.find(s => s.id === serviceId);\\\\n    if (!svc || svc.isUpdating) return this.getServicesStatus();\\\\n\\\\n    svc.isUpdating = true;\\\\n    this._emitStatus();\\\\n\\\\n    try {\\\\n      // Select provider by most specific: service.id, or fall back to generic fetch-json\\\\n      let provider = this.registry.get(svc.id);\\\\n      if (!provider && svc.config?.url) {\\\\n        provider = this.registry.get('fetch-json');\\\\n      }\\\\n\\\\n      if (provider && typeof provider.update === 'function') {\\\\n        await provider.update(svc);\\\\n      } else {\\\\n        // No provider registered; do nothing but simulate delay\\\\n        await new Promise(r => setTimeout(r, 500));\\\\n      }\\\\n\\\\n      svc.lastUpdated = Date.now();\\\\n    } catch (e) {\\\\n      console.error(`[live-data] update failed for ${serviceId}:`, e?.message || e);\\\\n    } finally {\\\\n      svc.isUpdating = false;\\\\n      this._saveServices();\\\\n      this._emitStatus();\\\\n    }\\\\n\\\\n    return this.getServicesStatus();\\\\n  }\\\\n\\\\n  async getServiceData(serviceId) {\\\\n    const svc = this.services.find(s => s.id === serviceId);\\\\n    if (!svc) return null;\\\\n\\\\n    try {\\\\n      let provider = this.registry.get(svc.id);\\\\n      if (!provider && svc.config?.url) provider = this.registry.get('fetch-json');\\\\n      if (provider && typeof provider.getData === 'function') {\\\\n        return await provider.getData(svc);\\\\n      }\\\\n      return this.store.getServiceData(serviceId);\\\\n    } catch (e) {\\\\n      console.warn('[live-data] getServiceData error for', serviceId, e?.message || e);\\\\n      return this.store.getServiceData(serviceId) || null;\\\\n    }\\\\n  }\\\\n\\\\n  _emitStatus() {\\\\n    if (!this.window || this.window.isDestroyed()) return;\\\\n    try {\\\\n      this.window.webContents.send(IPC_HANDLER_KEYS.LIVE_DATA_SUBSCRIBE, this.getServicesStatus());\\\\n    } catch (e) {\\\\n      console.warn('Failed to emit LIVE_DATA_SUBSCRIBE:', e);\\\\n    }\\\\n  }\\\\n\\\\n  _maybeTriggerOnLaunchUpdates() {\\\\n    for (const svc of this.services) {\\\\n      if (svc.autoUpdate?.enabled && (svc.autoUpdate?.trigger === 'onAppLaunch')) {\\\\n        if (!computeIsFresh(svc)) {\\\\n          this.triggerUpdate(svc.id); // fire-and-forget\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n  stopWatching() {\\\\n    // Placeholder for future scheduled triggers\\\\n  }\\\\n}\\\\n\\\\n// Normalize shape for service entries read from storage or defaults\\\\nexport function normalizeService(service) {\\\\n  return {\\\\n    id: service.id,\\\\n    name: service.name,\\\\n    description: service.description,\\\\n    freshnessPolicy: service.freshnessPolicy || service.freshnessPolicy || 'daily',\\\\n    autoUpdate: typeof service.autoUpdate === 'object'\\\\n      ? { enabled: !!service.autoUpdate.enabled, trigger: service.autoUpdate.trigger || 'onAppLaunch', time: service.autoUpdate.time }\\\\n      : { enabled: !!service.autoUpdate, trigger: 'onAppLaunch' },\\\\n    lastUpdated: typeof service.lastUpdated === 'number'\\\\n      ? service.lastUpdated\\\\n      : (service.lastUpdated ? new Date(service.lastUpdated).getTime() : 0),\\\\n    config: service.config || {}, // free-form; may include url, headers, params, etc.\\\\n    isUpdating: !!service.isUpdating,\\\\n  };\\\\n}\\\\n\\\\n// Interface (documentation) for providers\\\\n// A provider implementation must expose: { id, update(service, deps), getData(service, deps) }\\\\n// - id: string (matches service id for built-ins or a generic provider id for dynamic services)\\\\n// - update: performs network or internal refresh, should persist data via store if applicable\\\\n// - getData: returns current data snapshot for the service\\\\n\\\\nexport function computeIsFresh(service, now = Date.now()) {\\\\n  if (!service.lastUpdated) return false;\\\\n  const diffMs = now - service.lastUpdated;\\\\n  const dayMs = 24 * 60 * 60 * 1000;\\\\n  switch (service.freshnessPolicy) {\\\\n    case 'daily':\\\\n      return diffMs < dayMs;\\\\n    case 'weekly':\\\\n      return diffMs < 7 * dayMs;\\\\n    case 'monthly':\\\\n      return diffMs < 30 * dayMs; // Approximate month\\\\n    default:\\\\n      return false;\\\\n  }\\\\n}\\\\n\\\",\\\"src/live-data/LiveDataRegistry.js\\\":\\\"/*\\\\nLive Data Provider Registry\\\\n- Allows registering providers and looking them up by service id.\\\\n*/\\\\n\\\\nexport class LiveDataRegistry {\\\\n  constructor() {\\\\n    this.providers = new Map();\\\\n  }\\\\n\\\\n  register(provider) {\\\\n    if (!provider || !provider.id) throw new Error('Provider must have an id');\\\\n    this.providers.set(provider.id, provider);\\\\n  }\\\\n\\\\n  get(serviceId) {\\\\n    return this.providers.get(serviceId);\\\\n  }\\\\n}\\\\n\\\",\\\"src/live-data/LiveDataStore.js\\\":\\\"import AppStorage from '../settings/AppStorage';\\\\n\\\\n// LiveDataStore persists service configs and per-service data cache.\\\\nexport class LiveDataStore {\\\\n  constructor() {\\\\n    this.storage = new AppStorage('live-data');\\\\n  }\\\\n\\\\n  getServices() {\\\\n    try {\\\\n      const raw = this.storage.getItem('services-config');\\\\n      return raw ? JSON.parse(raw) : null;\\\\n    } catch (e) {\\\\n      console.error('[live-data] Failed to read services-config:', e);\\\\n      return null;\\\\n    }\\\\n  }\\\\n\\\\n  setServices(services) {\\\\n    try {\\\\n      this.storage.setItem('services-config', JSON.stringify(services));\\\\n    } catch (e) {\\\\n      console.error('[live-data] Failed to write services-config:', e);\\\\n    }\\\\n  }\\\\n\\\\n  getServiceData(serviceId) {\\\\n    try {\\\\n      const raw = this.storage.getItem(`data:${serviceId}`);\\\\n      return raw ? JSON.parse(raw) : null;\\\\n    } catch (e) {\\\\n      console.error('[live-data] Failed to read service data for', serviceId, e);\\\\n      return null;\\\\n    }\\\\n  }\\\\n\\\\n  setServiceData(serviceId, data) {\\\\n    try {\\\\n      this.storage.setItem(`data:${serviceId}`, JSON.stringify(data));\\\\n    } catch (e) {\\\\n      console.error('[live-data] Failed to write service data for', serviceId, e);\\\\n    }\\\\n  }\\\\n}\\\\n\\\",\\\"src/live-data/providers/agentPricesProvider.js\\\":\\\"import { getPricingManager } from '../../tools/factory/mainOrchestrator';\\\\n\\\\n// Agent Prices provider bridges to factory-ts pricing manager.\\\\n// It does not persist its own data; instead, it refreshes pricing manager\\\\n// and mirrors a snapshot into LiveDataStore for renderer consumption.\\\\nexport function createAgentPricesProvider(store) {\\\\n  return {\\\\n    id: 'agent-prices',\\\\n    update: async (service) => {\\\\n      const pricing = getPricingManager();\\\\n      if (!pricing) throw new Error('Pricing manager not initialized');\\\\n      // Allow URL override via service.config.url, otherwise fallback to litellm list\\\\n      const url = service?.config?.url || 'https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json';\\\\n      await pricing.refresh(undefined, url);\\\\n\\\\n      // Pull snapshot for caching in store\\\\n      const snapshot = typeof pricing.listPrices === 'function'\\\\n        ? pricing.listPrices()\\\\n        : { updatedAt: new Date().toISOString(), prices: [] };\\\\n      store.setServiceData(service.id, snapshot);\\\\n      return true;\\\\n    },\\\\n    getData: async (service) => {\\\\n      // First prefer pricing manager real-time, fallback to cached store\\\\n      try {\\\\n        const pricing = getPricingManager();\\\\n        if (pricing && typeof pricing.listPrices === 'function') {\\\\n          const snapshot = pricing.listPrices();\\\\n          if (snapshot) return snapshot;\\\\n        }\\\\n      } catch (_) {}\\\\n      return store.getServiceData(service.id) || { updatedAt: new Date().toISOString(), prices: [] };\\\\n    }\\\\n  };\\\\n}\\\\n\\\",\\\"src/live-data/providers/fetchJsonProvider.js\\\":\\\"/*\\\\nGeneric Fetch JSON provider\\\\n- Supports dynamic services configured with a URL (service.config.url)\\\\n- Fetches JSON and stores it. Useful for future-proof expansion without wiring code.\\\\n*/\\\\n\\\\nimport https from 'https';\\\\nimport http from 'http';\\\\n\\\\nfunction fetchJson(url) {\\\\n  return new Promise((resolve, reject) => {\\\\n    try {\\\\n      const lib = url.startsWith('https') ? https : http;\\\\n      const req = lib.get(url, (res) => {\\\\n        if (res.statusCode < 200 || res.statusCode >= 300) {\\\\n          reject(new Error(`HTTP ${res.statusCode}`));\\\\n          res.resume();\\\\n          return;\\\\n        }\\\\n        let data = '';\\\\n        res.setEncoding('utf8');\\\\n        res.on('data', chunk => { data += chunk; });\\\\n        res.on('end', () => {\\\\n          try {\\\\n            const parsed = JSON.parse(data);\\\\n            resolve(parsed);\\\\n          } catch (e) {\\\\n            reject(e);\\\\n          }\\\\n        });\\\\n      });\\\\n      req.on('error', reject);\\\\n    } catch (e) {\\\\n      reject(e);\\\\n    }\\\\n  });\\\\n}\\\\n\\\\nexport function createFetchJsonProvider(store) {\\\\n  return {\\\\n    id: 'fetch-json',\\\\n    update: async (service) => {\\\\n      const url = service?.config?.url;\\\\n      if (!url) throw new Error('Missing service.config.url');\\\\n      const data = await fetchJson(url);\\\\n      store.setServiceData(service.id, { updatedAt: new Date().toISOString(), data });\\\\n      return true;\\\\n    },\\\\n    getData: async (service) => {\\\\n      return store.getServiceData(service.id) || null;\\\\n    }\\\\n  };\\\\n}\\\\n\\\",\\\"src/preload.js\\\":\\\"import { contextBridge, ipcRenderer } from 'electron';\\\\nimport IPC_HANDLER_KEYS from \\\\\\\"./ipcHandlersKeys\\\\\\\"\\\\n\\\\nconst FILES_API = {\\\\n  subscribe: (callback) => {\\\\n    const listener = (_event, files) => callback(files);\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.FILES_SUBSCRIBE, listener);\\\\n    return () => ipcRenderer.removeListener(IPC_HANDLER_KEYS.FILES_SUBSCRIBE, listener);\\\\n  },\\\\n  listFiles: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.FILES_LIST, { projectId }),\\\\n  readFile: (projectId, relPath, encoding = 'utf8') => ipcRenderer.invoke(IPC_HANDLER_KEYS.FILES_READ, { projectId, relPath, encoding }),\\\\n  readFileBinary: (projectId, relPath) => ipcRenderer.invoke(IPC_HANDLER_KEYS.FILES_READ_BINARY, { projectId, relPath }),\\\\n  readDirectory: (projectId, relPath) => ipcRenderer.invoke(IPC_HANDLER_KEYS.FILES_READ_DIRECTORY, { projectId, relPath }),\\\\n  writeFile: (projectId, relPath, content, encoding = 'utf8') => ipcRenderer.invoke(IPC_HANDLER_KEYS.FILES_WRITE, { projectId, relPath, content, encoding }),\\\\n  deleteFile: (projectId, relPath) => ipcRenderer.invoke(IPC_HANDLER_KEYS.FILES_DELETE, { projectId, relPath }),\\\\n  renameFile: (projectId, relPathSource, relPathTarget) => ipcRenderer.invoke(IPC_HANDLER_KEYS.FILES_RENAME, { projectId, relPathSource, relPathTarget }),\\\\n  uploadFile: (projectId, name, content) => ipcRenderer.invoke(IPC_HANDLER_KEYS.FILES_UPLOAD, { projectId, name, content })\\\\n};\\\\n\\\\nconst TASKS_API = {\\\\n  subscribe: (callback) => {\\\\n    const listener = (_event, tasks) => callback(tasks);\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.TASKS_SUBSCRIBE, listener);\\\\n    return () => ipcRenderer.removeListener(IPC_HANDLER_KEYS.TASKS_SUBSCRIBE, listener);\\\\n  },\\\\n  listTasks: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_LIST, { projectId }),\\\\n  getTask: (projectId, taskId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_GET, { projectId, taskId }),\\\\n  createTask: (projectId, task) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_CREATE, { projectId, task }),\\\\n  updateTask: (projectId, taskId, data) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_UPDATE, { projectId, taskId, data }),\\\\n  deleteTask: (projectId, taskId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_DELETE, { projectId, taskId }),\\\\n  getFeature: (projectId, featureId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_FEATURE_GET, { projectId, featureId }),\\\\n  addFeature: (projectId, taskId, feature) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_FEATURE_ADD, { projectId, taskId, feature }),\\\\n  updateFeature: (projectId, taskId, featureId, data) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_FEATURE_UPDATE, { projectId, taskId, featureId, data }),\\\\n  deleteFeature: (projectId, taskId, featureId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_FEATURE_DELETE, { projectId, taskId, featureId }),\\\\n  reorderFeatures: (projectId, taskId, payload) => ipcRenderer.invoke(IPC_HANDLER_KEYS.TASKS_FEATURES_REORDER, { projectId, taskId, payload })\\\\n};\\\\n\\\\nconst CHATS_API = {\\\\n  listModels: (config) => ipcRenderer.invoke(IPC_HANDLER_KEYS.CHATS_LIST_MODELS, { config }),\\\\n  subscribe: (callback) => {\\\\n    const listener = (_event, chats) => callback(chats);\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.CHATS_SUBSCRIBE, listener);\\\\n    return () => ipcRenderer.removeListener(IPC_HANDLER_KEYS.CHATS_SUBSCRIBE, listener);\\\\n  },\\\\n  listChats: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.CHATS_LIST, { projectId }),\\\\n  createChat: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.CHATS_CREATE, { projectId }),\\\\n  getChat: (projectId, chatId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.CHATS_GET, { projectId, chatId }),\\\\n  deleteChat: (projectId, chatId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.CHATS_DELETE, { projectId, chatId }),\\\\n  getCompletion: (projectId, chatId, newMessages, config) => ipcRenderer.invoke(IPC_HANDLER_KEYS.CHATS_COMPLETION, { projectId, chatId, newMessages, config }),\\\\n};\\\\n\\\\nconst NOTIFICATIONS_API = {\\\\n  onOpenNotification: (callback) => {\\\\n    const listener = (_event, metadata) => callback(metadata);\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.NOTIFICATIONS_ON_OPEN, listener);\\\\n    return () => ipcRenderer.removeListener(IPC_HANDLER_KEYS.NOTIFICATIONS_ON_OPEN, listener);\\\\n  },\\\\n\\\\n  sendOs: (data) => ipcRenderer.invoke(IPC_HANDLER_KEYS.NOTIFICATIONS_SEND_OS, data),\\\\n  subscribe: (callback) => {\\\\n    const listener = (_event, payload) => callback(payload);\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.NOTIFICATIONS_SUBSCRIBE, listener);\\\\n    return () => ipcRenderer.removeListener(IPC_HANDLER_KEYS.NOTIFICATIONS_SUBSCRIBE, listener);\\\\n  },\\\\n  getRecentNotifications: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.NOTIFICATIONS_RECENT, { projectId }),\\\\n  getUnreadNotificationsCount: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.NOTIFICATIONS_UNREADCOUNT, { projectId }),\\\\n  markAllNotificationsAsRead: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.NOTIFICATIONS_MARKALLASREAD, { projectId }),\\\\n  markNotificationAsRead: (projectId, id) => ipcRenderer.invoke(IPC_HANDLER_KEYS.NOTIFICATIONS_MARKASREAD, { projectId, id }),\\\\n  deleteAllNotifications: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.NOTIFICATIONS_DELETEALL, { projectId }),\\\\n  create: (projectId, input) => ipcRenderer.invoke(IPC_HANDLER_KEYS.NOTIFICATIONS_CREATE, { projectId, input }),\\\\n};\\\\n\\\\nconst PROJECTS_API = {\\\\n  subscribe: (callback) => {\\\\n    const listener = (_event, projects) => callback(projects);\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.PROJECTS_SUBSCRIBE, listener);\\\\n    return () => ipcRenderer.removeListener(IPC_HANDLER_KEYS.PROJECTS_SUBSCRIBE, listener);\\\\n  },\\\\n  listProjects: () => ipcRenderer.invoke(IPC_HANDLER_KEYS.PROJECTS_LIST),\\\\n  getProject: (id) => ipcRenderer.invoke(IPC_HANDLER_KEYS.PROJECTS_GET, { id }),\\\\n  createProject: (project) => ipcRenderer.invoke(IPC_HANDLER_KEYS.PROJECTS_CREATE, { id: project?.id, project }),\\\\n  updateProject: (id, project) => ipcRenderer.invoke(IPC_HANDLER_KEYS.PROJECTS_UPDATE, { id, project }),\\\\n  deleteProject: (id) => ipcRenderer.invoke(IPC_HANDLER_KEYS.PROJECTS_DELETE, { id }),\\\\n  reorderTask: (projectId, fromIndex, toIndex) => ipcRenderer.invoke(IPC_HANDLER_KEYS.PROJECTS_TASK_REORDER, { projectId, fromIndex, toIndex }),\\\\n};\\\\n\\\\nconst SCREENSHOT_API = {\\\\n  capture: (options) => ipcRenderer.invoke('screenshot:capture', options),\\\\n};\\\\n\\\\nconst SETTINGS_API = {\\\\n  subscribe: (callback) => {\\\\n    const listener = (_event, projectSettings) => callback(projectSettings);\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.SETTINGS_SUBSCRIBE, listener);\\\\n    return () => ipcRenderer.removeListener(IPC_HANDLER_KEYS.SETTINGS_SUBSCRIBE, listener);\\\\n  },\\\\n  getAppSettings: () => ipcRenderer.invoke(IPC_HANDLER_KEYS.SETTINGS_GET_APP),\\\\n  updateAppSettings: (updates) => ipcRenderer.invoke(IPC_HANDLER_KEYS.SETTINGS_UPDATE_APP, { updates }),\\\\n  getProjectSettings: (projectId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.SETTINGS_GET_PROJECT, { projectId }),\\\\n  updateProjectSettings: (projectId, updates) => ipcRenderer.invoke(IPC_HANDLER_KEYS.SETTINGS_UPDATE_PROJECT, { projectId, updates }),\\\\n};\\\\n\\\\n// Factory orchestrator API exposed to renderer\\\\nconst FACTORY_API = {\\\\n  startTaskRun: (agentType, projectId, taskId, llmConfig, options = {}) => {\\\\n    console.log('[preload:factory] startTaskRun', { agentType, projectId, taskId, options });\\\\n    return ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_START_TASK, { agentType, projectId, taskId, llmConfig, options });\\\\n  },\\\\n  startFeatureRun: (agentType, projectId, taskId, featureId, llmConfig, options = {}) => {\\\\n    console.log('[preload:factory] startFeatureRun', { agentType, projectId, taskId, featureId, options });\\\\n    return ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_START_FEATURE, { agentType, projectId, taskId, featureId, llmConfig, options });\\\\n  },\\\\n  cancelRun: (runId, reason) => {\\\\n    console.log('[preload:factory] cancelRun', { runId, reason });\\\\n    return ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_CANCEL_RUN, { runId, reason });\\\\n  },\\\\n  subscribe: (runId, callback) => {\\\\n    console.log('[preload:factory] subscribe', { runId });\\\\n    const listener = (_event, data) => {\\\\n      if (data.runId === runId) callback(data.event);\\\\n    };\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.FACTORY_EVENT, listener);\\\\n    ipcRenderer.send(IPC_HANDLER_KEYS.FACTORY_SUBSCRIBE, { runId });\\\\n    return () => {\\\\n      console.log('[preload:factory] unsubscribe', { runId });\\\\n      ipcRenderer.removeListener(IPC_HANDLER_KEYS.FACTORY_EVENT, listener);\\\\n    };\\\\n  },\\\\n  listActiveRuns: () => {\\\\n    return ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_LIST_ACTIVE);\\\\n  },\\\\n  listRunHistory: () => {\\\\n    return ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_HISTORY_LIST);\\\\n  },\\\\n  getRunMessages: (runId) => {\\\\n    return ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_HISTORY_MESSAGES, { runId });\\\\n  },\\\\n  deleteRun: (runId) => {\\\\n    return ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_HISTORY_DELETE, { runId });\\\\n  },\\\\n  // Pricing\\\\n  getPricing: () => ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_PRICING_GET),\\\\n  refreshPricing: (provider, url) => ipcRenderer.invoke(IPC_HANDLER_KEYS.FACTORY_PRICING_REFRESH, { provider, url }),\\\\n};\\\\n\\\\nconst LIVEDATA_API = {\\\\n  subscribe: (callback) => {\\\\n    const listener = (_event, services) => callback(services);\\\\n    ipcRenderer.on(IPC_HANDLER_KEYS.LIVE_DATA_SUBSCRIBE, listener);\\\\n    return () => ipcRenderer.removeListener(IPC_HANDLER_KEYS.LIVE_DATA_SUBSCRIBE, listener);\\\\n  },\\\\n  getStatus: () => ipcRenderer.invoke(IPC_HANDLER_KEYS.LIVE_DATA_GET_STATUS),\\\\n  addService: (service) => ipcRenderer.invoke(IPC_HANDLER_KEYS.LIVE_DATA_ADD_SERVICE, { service }),\\\\n  removeService: (serviceId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.LIVE_DATA_REMOVE_SERVICE, { serviceId }),\\\\n  triggerUpdate: (serviceId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.LIVE_DATA_TRIGGER_UPDATE, { serviceId }),\\\\n  updateConfig: (serviceId, updates) => ipcRenderer.invoke(IPC_HANDLER_KEYS.LIVE_DATA_UPDATE_CONFIG, { serviceId, updates }),\\\\n  getData: (serviceId) => ipcRenderer.invoke(IPC_HANDLER_KEYS.LIVE_DATA_GET_DATA, { serviceId }),\\\\n};\\\\n\\\\ncontextBridge.exposeInMainWorld('tasksService', TASKS_API);\\\\ncontextBridge.exposeInMainWorld('projectsService', PROJECTS_API);\\\\ncontextBridge.exposeInMainWorld('filesService', FILES_API);\\\\ncontextBridge.exposeInMainWorld('chatsService', CHATS_API);\\\\ncontextBridge.exposeInMainWorld('notificationsService', NOTIFICATIONS_API);\\\\ncontextBridge.exposeInMainWorld('screenshot', SCREENSHOT_API);\\\\ncontextBridge.exposeInMainWorld('settingsService', SETTINGS_API);\\\\ncontextBridge.exposeInMainWorld('factory', FACTORY_API);\\\\ncontextBridge.exposeInMainWorld('liveDataService', LIVEDATA_API);\\\\n\\\",\\\"src/main.js\\\":\\\"import { app, BrowserWindow } from 'electron';\\\\nimport path from 'node:path';\\\\nimport started from 'electron-squirrel-startup';\\\\nimport { registerScreenshotService } from './capture/screenshotService';\\\\nimport { initManagers, stopManagers } from './managers';\\\\n\\\\nif (started) {\\\\n  app.quit();\\\\n}\\\\nlet mainWindow;\\\\n\\\\nconst IS_DEV =true\\\\n\\\\nconst createWindow = () => {\\\\n  mainWindow = new BrowserWindow({\\\\n    width: IS_DEV ? 1600 : 1200,\\\\n    height: 800,\\\\n    webPreferences: {\\\\n      preload: path.join(__dirname, 'preload.js')\\\\n    }, \\\\n  });\\\\n\\\\n  if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {\\\\n    mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL);\\\\n  } else {\\\\n    mainWindow.loadFile(path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`));\\\\n  }\\\\n\\\\n  mainWindow.webContents.openDevTools();\\\\n};\\\\n\\\\napp.whenReady().then(async () => {\\\\n  createWindow();\\\\n\\\\n  registerScreenshotService(() => mainWindow);\\\\n\\\\n  const projectRoot = app.getAppPath();\\\\n\\\\n  await initManagers(projectRoot, mainWindow);\\\\n  \\\\n  app.on('activate', () => {\\\\n    if (BrowserWindow.getAllWindows().length === 0) {\\\\n      createWindow();\\\\n    }\\\\n  });\\\\n});\\\\n\\\\napp.on('window-all-closed', () => {\\\\n  if (process.platform !== 'darwin') {\\\\n    app.quit();\\\\n  }\\\\n  stopManagers()\\\\n});\\\\n\\\",\\\"src/renderer/projects/ProjectContext.tsx\\\":\\\"import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react'\\\\nimport type { ProjectSpec } from 'thefactory-tools';\\\\nimport { projectsService } from '../services/projectsService'\\\\nimport { useAppSettings } from '../hooks/useAppSettings'\\\\n\\\\nexport const MAIN_PROJECT = 'main'\\\\n\\\\nexport type ProjectContextValue = {\\\\n  activeProjectId: string\\\\n  activeProject?: ProjectSpec\\\\n\\\\n  projects: ProjectSpec[]\\\\n\\\\n  setActiveProjectId: (id: string) => void\\\\n  getProjectById: (id: string) => ProjectSpec | undefined\\\\n}\\\\n\\\\nconst ProjectContext = createContext<ProjectContextValue | null>(null)\\\\n\\\\nexport function ProjectsProvider({ children }: { children: React.ReactNode }) {\\\\n  const { appSettings, updateAppSettings } = useAppSettings()\\\\n  const [initialLoad, setInitialLoad] = useState(true)\\\\n  const [activeProjectId, setActiveProjectIdState] = useState<string>(MAIN_PROJECT)\\\\n  const [projects, setProjects] = useState<ProjectSpec[]>([])\\\\n\\\\n  // Load projects and subscribe to updates\\\\n  const update = async () => {\\\\n    const projects = await projectsService.listProjects()\\\\n    updateCurrentProjects(projects)\\\\n  }\\\\n  const updateCurrentProjects = (projectsList: ProjectSpec[]) => {\\\\n    setProjects(projectsList)\\\\n  }\\\\n  useEffect(() => {\\\\n    update();\\\\n    const unsubscribe = projectsService.subscribe(updateCurrentProjects);\\\\n    return () => { unsubscribe(); };\\\\n  }, [])\\\\n\\\\n  useEffect(() => {\\\\n    if (appSettings && initialLoad){\\\\n      if (appSettings.userPreferences.lastActiveProjectId) {\\\\n        setActiveProjectIdState(appSettings.userPreferences.lastActiveProjectId)\\\\n      } else {\\\\n        setActiveProjectIdState(MAIN_PROJECT)\\\\n      }\\\\n      setInitialLoad(false)\\\\n    }\\\\n  }, [appSettings])\\\\n\\\\n  useEffect(() => {\\\\n    if (!projects || projects.length === 0) return\\\\n    const exists = projects.some(p => p.id === activeProjectId)\\\\n    if (!exists) {\\\\n      setActiveProjectIdState(MAIN_PROJECT)\\\\n    }\\\\n  }, [projects, activeProjectId])\\\\n\\\\n  const setActiveProjectId = useCallback((id: string) => {\\\\n    setActiveProjectIdState(id)\\\\n    // Only update the specific userPreferences sub-tree to avoid clobbering other preferences (like tasksViewMode)\\\\n    updateAppSettings({ userPreferences: { ...appSettings.userPreferences, lastActiveProjectId: id }})\\\\n  }, [appSettings, updateAppSettings])\\\\n\\\\n  const getProjectById = useCallback((id: string) => {\\\\n    if (projects.length == 0) return undefined\\\\n    return projects.find(p => p.id === id)\\\\n  }, [projects])\\\\n\\\\n  const activeProject: ProjectSpec | undefined = useMemo(() => {\\\\n    return getProjectById(activeProjectId)\\\\n  }, [projects, activeProjectId, getProjectById])\\\\n\\\\n  const value = useMemo<ProjectContextValue>(() => ({\\\\n    activeProjectId,\\\\n    activeProject,\\\\n    setActiveProjectId,\\\\n    projects,\\\\n    getProjectById,\\\\n  }), [activeProjectId, activeProject, setActiveProjectId, projects, getProjectById])\\\\n\\\\n  return <ProjectContext.Provider value={value}>{children}</ProjectContext.Provider>\\\\n}\\\\n\\\\nexport function useProjectContext(): ProjectContextValue {\\\\n  const ctx = useContext(ProjectContext)\\\\n  if (!ctx) throw new Error('useProjectContext must be used within ProjectsProvider')\\\\n  return ctx\\\\n}\\\\n\\\\nexport function useActiveProject() {\\\\n  const { activeProjectId, activeProject } = useProjectContext()\\\\n  return {\\\\n    projectId: activeProjectId,\\\\n    project: activeProject\\\\n  }\\\\n}\\\\n\\\",\\\"src/renderer/screens/LiveDataView.tsx\\\":\\\"import { useState } from 'react';\\\\nimport type { LiveDataProvider, LiveDataProviderStatus } from '../../live-data/LiveDataTypes';\\\\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/Select';\\\\nimport { Switch } from '../components/ui/Switch';\\\\nimport useLiveData from '../hooks/useLiveData';\\\\n\\\\nfunction formatLastUpdated(ts: number | undefined | null) {\\\\n  if (!ts) return 'never';\\\\n  try {\\\\n    return new Date(ts).toLocaleString();\\\\n  } catch {\\\\n    return 'never';\\\\n  }\\\\n}\\\\n\\\\nfunction JsonBlock({ data }: { data: any }) {\\\\n  return (\\\\n    <pre className=\\\\\\\"mt-2 max-h-80 overflow-auto rounded bg-gray-50 p-2 text-xs text-gray-800 border\\\\\\\">\\\\n      {data == null ? 'No data available.' : JSON.stringify(data, null, 2)}\\\\n    </pre>\\\\n  );\\\\n}\\\\n\\\\ntype NewServiceForm = {\\\\n  id: string;\\\\n  name: string;\\\\n  description: string;\\\\n  url: string;\\\\n  freshnessPolicy: LiveDataProvider['freshnessPolicy'];\\\\n  autoEnabled: boolean;\\\\n  autoTrigger: 'onAppLaunch' | 'scheduled';\\\\n};\\\\n\\\\nexport default function LiveDataView() {\\\\n  const { services, servicesById, triggerUpdate, updateConfig, addService } = useLiveData()\\\\n  const [openViewer, setOpenViewer] = useState<Record<string, boolean>>({});\\\\n  const [loadingData, setLoadingData] = useState<Record<string, boolean>>({});\\\\n  const [serviceData, setServiceData] = useState<Record<string, any>>({});\\\\n  const [errorByService, setErrorByService] = useState<Record<string, string | undefined>>({});\\\\n\\\\n  const [showAddForm, setShowAddForm] = useState(false);\\\\n  const [savingNew, setSavingNew] = useState(false);\\\\n  const [addError, setAddError] = useState<string | undefined>(undefined);\\\\n  const [newSvc, setNewSvc] = useState<NewServiceForm>({\\\\n    id: '',\\\\n    name: '',\\\\n    description: '',\\\\n    url: '',\\\\n    freshnessPolicy: 'daily',\\\\n    autoEnabled: true,\\\\n    autoTrigger: 'onAppLaunch',\\\\n  });\\\\n\\\\n  const toggleViewer = async (s: LiveDataProviderStatus) => {\\\\n    const isOpen = !!openViewer[s.id];\\\\n    const next = { ...openViewer, [s.id]: !isOpen };\\\\n    setOpenViewer(next);\\\\n\\\\n    // If opening and no data loaded yet, try to fetch it now.\\\\n    if (!isOpen && serviceData[s.id] === undefined) {\\\\n      await fetchLatestForService(s);\\\\n    }\\\\n  };\\\\n\\\\n  const fetchLatestForService = async (s: LiveDataProviderStatus) => {\\\\n    setLoadingData(prev => ({ ...prev, [s.id]: true }));\\\\n    setErrorByService(prev => ({ ...prev, [s.id]: undefined }));\\\\n\\\\n    try {\\\\n      let data: any = null;\\\\n      if ((window as any).liveDataService?.getData) {\\\\n        data = await (window as any).liveDataService.getData(s.id);\\\\n      }\\\\n      setServiceData(prev => ({ ...prev, [s.id]: data }));\\\\n    } catch (e: any) {\\\\n      setErrorByService(prev => ({ ...prev, [s.id]: e?.message || 'Failed to load latest data' }));\\\\n    } finally {\\\\n      setLoadingData(prev => ({ ...prev, [s.id]: false }));\\\\n    }\\\\n  };\\\\n\\\\n  const handleUpdateNow = async (s: LiveDataProviderStatus) => {\\\\n    try {\\\\n      await triggerUpdate(s.id);\\\\n    } finally {\\\\n      // If the JSON viewer is open for this service, refresh its data preview to reflect latest updates\\\\n      if (openViewer[s.id]) {\\\\n        await fetchLatestForService(s);\\\\n      }\\\\n    }\\\\n  };\\\\n\\\\n  const resetAddForm = () => {\\\\n    setNewSvc({ id: '', name: '', description: '', url: '', freshnessPolicy: 'daily', autoEnabled: true, autoTrigger: 'onAppLaunch' });\\\\n    setAddError(undefined);\\\\n  };\\\\n\\\\n  const handleSaveNewService = async () => {\\\\n    setAddError(undefined);\\\\n    if (!newSvc.id || !newSvc.name) {\\\\n      setAddError('Please provide both an ID and a Name.');\\\\n      return;\\\\n    }\\\\n    // Basic URL check if provided\\\\n    if (newSvc.url && !/^https?:\\\\\\\\/\\\\\\\\//i.test(newSvc.url)) {\\\\n      setAddError('URL must start with http:// or https://');\\\\n      return;\\\\n    }\\\\n\\\\n    setSavingNew(true);\\\\n    try {\\\\n      const payload: LiveDataProvider = {\\\\n        id: newSvc.id.trim(),\\\\n        name: newSvc.name.trim(),\\\\n        description: newSvc.description?.trim() || '',\\\\n        lastUpdated: 0,\\\\n        freshnessPolicy: newSvc.freshnessPolicy,\\\\n        autoUpdate: { enabled: !!newSvc.autoEnabled, trigger: newSvc.autoTrigger },\\\\n        config: newSvc.url ? { url: newSvc.url.trim() } : {},\\\\n      };\\\\n      await addService(payload);\\\\n      setShowAddForm(false);\\\\n      resetAddForm();\\\\n    } catch (e: any) {\\\\n      setAddError(e?.message || 'Failed to add service');\\\\n    } finally {\\\\n      setSavingNew(false);\\\\n    }\\\\n  };\\\\n\\\\n  return (\\\\n    <div className=\\\\\\\"p-4\\\\\\\">\\\\n      <div className=\\\\\\\"flex items-center justify-between\\\\\\\">\\\\n        <h1 className=\\\\\\\"text-2xl font-bold\\\\\\\">Live Data</h1>\\\\n        <button\\\\n          className=\\\\\\\"px-3 py-1 rounded bg-blue-600 text-white hover:bg-blue-700\\\\\\\"\\\\n          onClick={() => setShowAddForm(v => !v)}\\\\n        >\\\\n          {showAddForm ? 'Cancel' : '+ Add provider'}\\\\n        </button>\\\\n      </div>\\\\n\\\\n      {showAddForm && (\\\\n        <div className=\\\\\\\"mt-4 border rounded p-3 bg-white\\\\\\\">\\\\n          <div className=\\\\\\\"font-semibold mb-2\\\\\\\">Add live data provider</div>\\\\n\\\\n          {addError && <div className=\\\\\\\"text-sm text-red-700 mb-2\\\\\\\">{addError}</div>}\\\\n\\\\n          <div className=\\\\\\\"grid grid-cols-1 md:grid-cols-2 gap-4\\\\\\\">\\\\n            <div className=\\\\\\\"flex flex-col gap-1\\\\\\\">\\\\n              <label className=\\\\\\\"text-sm font-medium\\\\\\\">ID</label>\\\\n              <input\\\\n                className=\\\\\\\"border rounded px-2 py-1 text-sm\\\\\\\"\\\\n                value={newSvc.id}\\\\n                onChange={e => setNewSvc({ ...newSvc, id: e.target.value })}\\\\n                placeholder=\\\\\\\"unique-id\\\\\\\"\\\\n              />\\\\n              <span className=\\\\\\\"text-xs text-gray-500\\\\\\\">Must be unique. For custom JSON providers, choose any id.</span>\\\\n            </div>\\\\n\\\\n            <div className=\\\\\\\"flex flex-col gap-1\\\\\\\">\\\\n              <label className=\\\\\\\"text-sm font-medium\\\\\\\">Name</label>\\\\n              <input\\\\n                className=\\\\\\\"border rounded px-2 py-1 text-sm\\\\\\\"\\\\n                value={newSvc.name}\\\\n                onChange={e => setNewSvc({ ...newSvc, name: e.target.value })}\\\\n                placeholder=\\\\\\\"Display name\\\\\\\"\\\\n              />\\\\n            </div>\\\\n\\\\n            <div className=\\\\\\\"flex flex-col gap-1 md:col-span-2\\\\\\\">\\\\n              <label className=\\\\\\\"text-sm font-medium\\\\\\\">Description</label>\\\\n              <textarea\\\\n                className=\\\\\\\"border rounded px-2 py-1 text-sm\\\\\\\"\\\\n                value={newSvc.description}\\\\n                onChange={e => setNewSvc({ ...newSvc, description: e.target.value })}\\\\n                placeholder=\\\\\\\"What does this provider fetch?\\\\\\\"\\\\n              />\\\\n            </div>\\\\n\\\\n            <div className=\\\\\\\"flex flex-col gap-1 md:col-span-2\\\\\\\">\\\\n              <label className=\\\\\\\"text-sm font-medium\\\\\\\">Fetch URL (for JSON provider)</label>\\\\n              <input\\\\n                className=\\\\\\\"border rounded px-2 py-1 text-sm\\\\\\\"\\\\n                value={newSvc.url}\\\\n                onChange={e => setNewSvc({ ...newSvc, url: e.target.value })}\\\\n                placeholder=\\\\\\\"https://example.com/data.json\\\\\\\"\\\\n              />\\\\n              <span className=\\\\\\\"text-xs text-gray-500\\\\\\\">If provided, this provider will fetch JSON from the URL using the generic fetcher.</span>\\\\n            </div>\\\\n\\\\n            <div className=\\\\\\\"flex flex-col gap-1\\\\\\\">\\\\n              <label className=\\\\\\\"text-sm font-medium\\\\\\\">Freshness policy</label>\\\\n              <Select\\\\n                value={newSvc.freshnessPolicy}\\\\n                onValueChange={(val: LiveDataProvider['freshnessPolicy']) =>\\\\n                  setNewSvc({ ...newSvc, freshnessPolicy: val })\\\\n                }\\\\n              >\\\\n                <SelectTrigger size=\\\\\\\"sm\\\\\\\">\\\\n                  <SelectValue placeholder=\\\\\\\"Select policy\\\\\\\" />\\\\n                </SelectTrigger>\\\\n                <SelectContent>\\\\n                  <SelectItem value=\\\\\\\"daily\\\\\\\">Daily</SelectItem>\\\\n                  <SelectItem value=\\\\\\\"weekly\\\\\\\">Weekly</SelectItem>\\\\n                  <SelectItem value=\\\\\\\"monthly\\\\\\\">Monthly</SelectItem>\\\\n                </SelectContent>\\\\n              </Select>\\\\n            </div>\\\\n\\\\n            <div className=\\\\\\\"flex flex-col gap-2\\\\\\\">\\\\n              <Switch\\\\n                checked={!!newSvc.autoEnabled}\\\\n                onCheckedChange={(checked) => setNewSvc({ ...newSvc, autoEnabled: checked })}\\\\n                label=\\\\\\\"Automated checks\\\\\\\"\\\\n              />\\\\n              {newSvc.autoEnabled && (\\\\n                <div className=\\\\\\\"flex items-center gap-2\\\\\\\">\\\\n                  <span className=\\\\\\\"text-sm text-[var(--text-secondary)]\\\\\\\">When:</span>\\\\n                  <Select\\\\n                    value={newSvc.autoTrigger}\\\\n                    onValueChange={(val: 'onAppLaunch' | 'scheduled') => setNewSvc({ ...newSvc, autoTrigger: val })}\\\\n                  >\\\\n                    <SelectTrigger size=\\\\\\\"sm\\\\\\\" className=\\\\\\\"w-[200px]\\\\\\\">\\\\n                      <SelectValue />\\\\n                    </SelectTrigger>\\\\n                    <SelectContent>\\\\n                      <SelectItem value=\\\\\\\"onAppLaunch\\\\\\\">On app launch</SelectItem>\\\\n                      <SelectItem value=\\\\\\\"scheduled\\\\\\\">On schedule</SelectItem>\\\\n                    </SelectContent>\\\\n                  </Select>\\\\n                </div>\\\\n              )}\\\\n            </div>\\\\n          </div>\\\\n\\\\n          <div className=\\\\\\\"mt-3 flex gap-2\\\\\\\">\\\\n            <button\\\\n              disabled={savingNew}\\\\n              onClick={handleSaveNewService}\\\\n              className={`px-3 py-1 rounded text-white ${savingNew ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'}`}\\\\n            >\\\\n              {savingNew ? 'Adding…' : 'Add provider'}\\\\n            </button>\\\\n            <button\\\\n              disabled={savingNew}\\\\n              onClick={() => { setShowAddForm(false); resetAddForm(); }}\\\\n              className=\\\\\\\"px-3 py-1 rounded border text-gray-800 hover:bg-gray-50\\\\\\\"\\\\n            >\\\\n              Cancel\\\\n            </button>\\\\n          </div>\\\\n        </div>\\\\n      )}\\\\n\\\\n      {services.length === 0 ? (\\\\n        <div className=\\\\\\\"mt-4 text-gray-700\\\\\\\">No live data services are configured.</div>\\\\n      ) : (\\\\n        <div className=\\\\\\\"mt-4 space-y-3\\\\\\\">\\\\n          {services.map((s) => (\\\\n            <div key={s.id} className=\\\\\\\"border rounded p-3\\\\\\\">\\\\n              <div className=\\\\\\\"flex items-center justify-between\\\\\\\">\\\\n                <div>\\\\n                  <div className=\\\\\\\"font-semibold\\\\\\\">{s.name}</div>\\\\n                  {s.description && <div className=\\\\\\\"text-sm text-gray-600\\\\\\\">{s.description}</div>}\\\\n                </div>\\\\n                <div className=\\\\\\\"flex items-center gap-2\\\\\\\">\\\\n                  <button\\\\n                    onClick={() => toggleViewer(s)}\\\\n                    className=\\\\\\\"px-3 py-1 rounded border text-gray-800 hover:bg-gray-50\\\\\\\"\\\\n                  >\\\\n                    {openViewer[s.id] ? 'Hide data' : 'Show data'}\\\\n                  </button>\\\\n                  <button\\\\n                    disabled={!!s.isUpdating}\\\\n                    onClick={() => handleUpdateNow(s)}\\\\n                    className={`px-3 py-1 rounded text-white ${s.isUpdating ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'}`}\\\\n                  >\\\\n                    {s.isUpdating ? 'Updating…' : 'Update now'}\\\\n                  </button>\\\\n                </div>\\\\n              </div>\\\\n\\\\n              {/* Status row */}\\\\n              <div className=\\\\\\\"mt-2 text-sm text-gray-700 flex flex-wrap gap-4\\\\\\\">\\\\n                <span>\\\\n                  Status: <span className={s.isFresh ? 'text-green-600' : 'text-amber-700'}>{s.isFresh ? 'Up to date' : 'Stale'}</span>\\\\n                </span>\\\\n                <span>Last updated: {formatLastUpdated(s.lastUpdated)}</span>\\\\n              </div>\\\\n\\\\n              {/* JSON viewer */}\\\\n              {openViewer[s.id] && (\\\\n                <div className=\\\\\\\"mt-3\\\\\\\">\\\\n                  {loadingData[s.id] ? (\\\\n                    <div className=\\\\\\\"text-sm text-gray-600\\\\\\\">Loading latest data…</div>\\\\n                  ) : errorByService[s.id] ? (\\\\n                    <div className=\\\\\\\"text-sm text-red-600\\\\\\\">{errorByService[s.id]}</div>\\\\n                  ) : (\\\\n                    <JsonBlock data={serviceData[s.id]} />\\\\n                  )}\\\\n                  <div className=\\\\\\\"mt-2\\\\\\\">\\\\n                    <button\\\\n                      onClick={() => fetchLatestForService(s)}\\\\n                      className=\\\\\\\"text-xs text-blue-700 underline\\\\\\\"\\\\n                    >\\\\n                      Refresh data preview\\\\n                    </button>\\\\n                  </div>\\\\n                </div>\\\\n              )}\\\\n\\\\n              {/* Configuration controls */}\\\\n              <div className=\\\\\\\"mt-3 grid grid-cols-1 md:grid-cols-2 gap-4\\\\\\\">\\\\n                {/* Freshness policy */}\\\\n                <div className=\\\\\\\"flex flex-col gap-1\\\\\\\">\\\\n                  <label className=\\\\\\\"text-sm font-medium text-[var(--text-primary)]\\\\\\\">Freshness policy</label>\\\\n                  <Select\\\\n                    value={s.freshnessPolicy}\\\\n                    onValueChange={(val: LiveDataProvider['freshnessPolicy']) =>\\\\n                      updateConfig(s.id, { freshnessPolicy: val })\\\\n                    }\\\\n                  >\\\\n                    <SelectTrigger size=\\\\\\\"sm\\\\\\\">\\\\n                      <SelectValue placeholder=\\\\\\\"Select policy\\\\\\\" />\\\\n                    </SelectTrigger>\\\\n                    <SelectContent>\\\\n                      <SelectItem value=\\\\\\\"daily\\\\\\\">Daily</SelectItem>\\\\n                      <SelectItem value=\\\\\\\"weekly\\\\\\\">Weekly</SelectItem>\\\\n                      <SelectItem value=\\\\\\\"monthly\\\\\\\">Monthly</SelectItem>\\\\n                    </SelectContent>\\\\n                  </Select>\\\\n                </div>\\\\n\\\\n                {/* Auto-update toggle and trigger */}\\\\n                <div className=\\\\\\\"flex flex-col gap-2\\\\\\\">\\\\n                  <Switch\\\\n                    checked={!!s.autoUpdate?.enabled}\\\\n                    onCheckedChange={(checked) =>\\\\n                      updateConfig(s.id, { autoUpdate: { ...(s.autoUpdate || { trigger: 'onAppLaunch' }), enabled: checked } })\\\\n                    }\\\\n                    label=\\\\\\\"Automated checks\\\\\\\"\\\\n                  />\\\\n                  {s.autoUpdate?.enabled && (\\\\n                    <div className=\\\\\\\"flex items-center gap-2\\\\\\\">\\\\n                      <span className=\\\\\\\"text-sm text-[var(--text-secondary)]\\\\\\\">When:</span>\\\\n                      <Select\\\\n                        value={s.autoUpdate?.trigger || 'onAppLaunch'}\\\\n                        onValueChange={(val: 'onAppLaunch' | 'scheduled') =>\\\\n                          updateConfig(s.id, { autoUpdate: { ...(s.autoUpdate || { enabled: true }), trigger: val } })\\\\n                        }\\\\n                      >\\\\n                        <SelectTrigger size=\\\\\\\"sm\\\\\\\" className=\\\\\\\"w-[200px]\\\\\\\">\\\\n                          <SelectValue />\\\\n                        </SelectTrigger>\\\\n                        <SelectContent>\\\\n                          <SelectItem value=\\\\\\\"onAppLaunch\\\\\\\">On app launch</SelectItem>\\\\n                          <SelectItem value=\\\\\\\"scheduled\\\\\\\">On schedule</SelectItem>\\\\n                        </SelectContent>\\\\n                      </Select>\\\\n                    </div>\\\\n                  )}\\\\n                </div>\\\\n              </div>\\\\n            </div>\\\\n          ))}\\\\n        </div>\\\\n      )}\\\\n    </div>\\\\n  );\\\\n}\\\\n\\\",\\\"src/renderer/hooks/useLiveData.tsx\\\":\\\"import { useEffect, useState } from 'react';\\\\nimport { LiveDataProvider, LiveDataProviderStatus } from '../../live-data/LiveDataTypes';\\\\nimport { liveDataService } from '../services/liveDataService';\\\\n\\\\nexport default function useLiveData() {\\\\n  const [services, setServices] = useState<LiveDataProviderStatus[]>([]);\\\\n  const [servicesById, setServicesById] = useState<Record<string,LiveDataProviderStatus>>({});\\\\n\\\\n  const update = async () => {\\\\n      const services = await liveDataService.getStatus()\\\\n      updateCurrentServices(services)\\\\n  }\\\\n  const updateCurrentServices = (services: LiveDataProvider[]) => {\\\\n    setServices(services)\\\\n    \\\\n    let newServicesById : Record<string,LiveDataProvider> = {}\\\\n    for(const s of services){\\\\n      newServicesById[s.id] = s\\\\n    }\\\\n    setServicesById(newServicesById)\\\\n  }\\\\n  \\\\n  useEffect(() => {\\\\n    update();\\\\n\\\\n    const unsubscribe = liveDataService.subscribe(updateCurrentServices);\\\\n\\\\n    return () => {\\\\n      unsubscribe();\\\\n    };\\\\n  }, []);\\\\n\\\\n  const triggerUpdate = async (serviceId: string) : Promise<LiveDataProviderStatus | undefined> =>  {\\\\n    return await liveDataService.triggerUpdate(serviceId)\\\\n  }\\\\n  const updateConfig = async (serviceId: string, updates: Partial<Omit<LiveDataProvider,\\\\\\\"id\\\\\\\">>) : Promise<LiveDataProviderStatus> =>  {\\\\n    return liveDataService.updateConfig(serviceId, updates)\\\\n  }\\\\n  const addService = async (service: LiveDataProvider) : Promise<LiveDataProviderStatus> => {\\\\n    return await liveDataService.addService(service)\\\\n  }\\\\n  const removeService = async (serviceId: string) : Promise<boolean> => {\\\\n    return await liveDataService.removeService(serviceId)\\\\n  }\\\\n\\\\n  return { services, servicesById, triggerUpdate, updateConfig, addService, removeService };\\\\n}\\\",\\\"src/renderer/services/liveDataService.ts\\\":\\\"import { LiveDataProvider, LiveDataProviderStatus } from \\\\\\\"src/live-data/LiveDataTypes\\\\\\\"\\\\n\\\\nexport type LiveDataService = {\\\\n  subscribe: (callback: (statuses: LiveDataProviderStatus[]) => void) => () => void\\\\n  getStatus: () => Promise<LiveDataProviderStatus[]>\\\\n  triggerUpdate: (serviceId: string) => Promise<LiveDataProviderStatus | undefined>\\\\n  updateConfig: (serviceId: string, updates: Partial<Omit<LiveDataProvider, \\\\\\\"id\\\\\\\">>) => Promise<LiveDataProviderStatus>\\\\n  getData: (serviceId: string) => Promise<any>\\\\n  addService: (service: LiveDataProvider) => Promise<LiveDataProviderStatus>\\\\n  removeService: (serviceId: string) => Promise<boolean>\\\\n}\\\\n\\\\nexport const liveDataService: LiveDataService = { ...window.liveDataService }\\\"}\"}]",
        "featureId": "ada1bb79-e120-493b-b0ba-13d11951b42b",
        "agentType": "developer",
        "turn": 1,
        "source": "tools",
        "createdAt": "2025-09-09T17:59:19.643Z"
      },
      {
        "role": "assistant",
        "content": "{\"thoughts\":\"Implement scope support: added scope and projectId fields to LiveDataProvider types, normalized in LiveDataManager, marked Agent Prices as global, updated renderer hook to filter services by active project, and expanded LiveDataView to let users set scope when adding a provider and show scope in the list.\",\"tool_calls\":[{\"tool_name\":\"write_file\",\"arguments\":{\"filename\":\"src/live-data/LiveDataTypes.ts\",\"content\":\"export type LiveDataProviderFreshnessPolicy = 'daily' | 'weekly' | 'monthly';\\nexport type LiveDataProviderAutoUpdateTrigger = 'onAppLaunch' | 'scheduled';\\nexport type LiveDataProviderScope = 'global' | 'project';\\n\\nexport interface LiveDataProviderAutoUpdateSettings {\\n  enabled: boolean;\\n  trigger: LiveDataProviderAutoUpdateTrigger;\\n  time?: number; // Unix timestamp\\n}\\n\\nexport interface LiveDataProvider {\\n  id: string;\\n  name: string;\\n  description: string;\\n  lastUpdated: number; // Unix timestamp\\n  freshnessPolicy: LiveDataProviderFreshnessPolicy;\\n  autoUpdate: LiveDataProviderAutoUpdateSettings;\\n  config: any; // Service-specific configuration\\n  // Scope controls visibility/ownership of this provider\\n  scope?: LiveDataProviderScope; // default: 'global'\\n  projectId?: string | null; // when scope === 'project'\\n}\\n\\nexport interface LiveDataProviderStatus extends LiveDataProvider {\\n  isUpdating?: boolean;\\n  isFresh?: boolean;\\n};\\n\"}},{\"tool_name\":\"write_file\",\"arguments\":{\"filename\":\"src/live-data/LiveDataManager.js\",\"content\":\"import { ipcMain } from 'electron';\\nimport IPC_HANDLER_KEYS from '../ipcHandlersKeys';\\nimport { LiveDataStore } from './LiveDataStore';\\nimport { LiveDataRegistry } from './LiveDataRegistry';\\nimport { createAgentPricesProvider } from './providers/agentPricesProvider';\\nimport { createFetchJsonProvider } from './providers/fetchJsonProvider';\\n\\nconst DEFAULT_SERVICES = [\\n  {\\n    id: 'agent-prices',\\n    name: 'Agent Prices',\\n    description: 'Fetches the latest prices for common AI models from various providers.',\\n    freshnessPolicy: 'daily',\\n    autoUpdate: { enabled: true, trigger: 'onAppLaunch' },\\n    lastUpdated: 0,\\n    config: { url: 'https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json' },\\n    isUpdating: false,\\n    scope: 'global',\\n    projectId: null,\\n  },\\n  // Example slot for a dynamic JSON fetch service (user can add more via UI in future)\\n  // { id: 'my-json-service', name: 'My JSON', description: 'Fetches custom JSON', freshnessPolicy: 'weekly', autoUpdate: { enabled: false }, config: { url: 'https://example.com/data.json' } }\\n];\\n\\nexport class LiveDataManager {\\n  constructor(projectRoot, window) {\\n    this.projectRoot = projectRoot;\\n    this.window = window;\\n\\n    this.store = new LiveDataStore();\\n    this.registry = new LiveDataRegistry();\\n    this._ipcBound = false;\\n\\n    this.services = this._loadServices();\\n\\n    // Register built-in providers\\n    this.registry.register(createAgentPricesProvider(this.store));\\n    // Generic provider enables future-proof dynamic services by URL\\n    this.registry.register(createFetchJsonProvider(this.store));\\n  }\\n\\n  _loadServices() {\\n    const stored = this.store.getServices();\\n    if (stored && Array.isArray(stored)) {\\n      const normalized = stored.map(s => normalizeService(s));\\n      // Ensure defaults exist\\n      const ids = new Set(normalized.map(s => s.id));\\n      for (const def of DEFAULT_SERVICES) {\\n        if (!ids.has(def.id)) normalized.push(normalizeService(def));\\n      }\\n      return normalized;\\n    }\\n    return DEFAULT_SERVICES.map(s => normalizeService(s));\\n  }\\n\\n  _saveServices() {\\n    this.store.setServices(this.services);\\n  }\\n\\n  async init() {\\n    this._registerIpcHandlers();\\n    this._maybeTriggerOnLaunchUpdates();\\n  }\\n\\n  _registerIpcHandlers() {\\n    if (this._ipcBound) return;\\n\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_GET_STATUS, () => this.getServicesStatus());\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_TRIGGER_UPDATE, (_event, { serviceId }) => this.triggerUpdate(serviceId));\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_UPDATE_CONFIG, (_event, { serviceId, updates }) => this.updateServiceConfig(serviceId, updates));\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_GET_DATA, (_event, { serviceId }) => this.getServiceData(serviceId));\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_ADD_SERVICE, (_event, { service }) => this.addService(service));\\n    ipcMain.handle(IPC_HANDLER_KEYS.LIVE_DATA_REMOVE_SERVICE, (_event, { serviceId }) => this.removeService(serviceId));\\n\\n    this._ipcBound = true;\\n  }\\n\\n  getServicesStatus() {\\n    return this.services.map(svc => ({ ...svc, isFresh: computeIsFresh(svc) }));\\n  }\\n\\n  updateServiceConfig(serviceId, updates) {\\n    const idx = this.services.findIndex(s => s.id === serviceId);\\n    if (idx === -1) return null;\\n    const merged = normalizeService({ ...this.services[idx], ...updates });\\n    this.services[idx] = merged;\\n    this._saveServices();\\n    this._emitStatus();\\n    return merged;\\n  }\\n\\n  addService(service) {\\n    // Allows users to add new services by specifying id, name, url, and update settings.\\n    if (!service?.id) throw new Error('Service id is required');\\n    const exists = this.services.some(s => s.id === service.id);\\n    if (exists) throw new Error('Service with this id already exists');\\n\\n    // If service.type is 'fetch-json' we keep its id unique and will use generic provider.\\n    // If service.id matches a provider id (like 'agent-prices'), it will use that provider.\\n\\n    const merged = normalizeService(service);\\n    this.services.push(merged);\\n    this._saveServices();\\n    this._emitStatus();\\n    return merged;\\n  }\\n\\n  removeService(serviceId) {\\n    const idx = this.services.findIndex(s => s.id === serviceId);\\n    if (idx === -1) return false;\\n    this.services.splice(idx, 1);\\n    this._saveServices();\\n    this._emitStatus();\\n    return true;\\n  }\\n\\n  async triggerUpdate(serviceId) {\\n    const svc = this.services.find(s => s.id === serviceId);\\n    if (!svc || svc.isUpdating) return this.getServicesStatus();\\n\\n    svc.isUpdating = true;\\n    this._emitStatus();\\n\\n    try {\\n      // Select provider by most specific: service.id, or fall back to generic fetch-json\\n      let provider = this.registry.get(svc.id);\\n      if (!provider && svc.config?.url) {\\n        provider = this.registry.get('fetch-json');\\n      }\\n\\n      if (provider && typeof provider.update === 'function') {\\n        await provider.update(svc);\\n      } else {\\n        // No provider registered; do nothing but simulate delay\\n        await new Promise(r => setTimeout(r, 500));\\n      }\\n\\n      svc.lastUpdated = Date.now();\\n    } catch (e) {\\n      console.error(`[live-data] update failed for ${serviceId}:`, e?.message || e);\\n    } finally {\\n      svc.isUpdating = false;\\n      this._saveServices();\\n      this._emitStatus();\\n    }\\n\\n    return this.getServicesStatus();\\n  }\\n\\n  async getServiceData(serviceId) {\\n    const svc = this.services.find(s => s.id === serviceId);\\n    if (!svc) return null;\\n\\n    try {\\n      let provider = this.registry.get(svc.id);\\n      if (!provider && svc.config?.url) provider = this.registry.get('fetch-json');\\n      if (provider && typeof provider.getData === 'function') {\\n        return await provider.getData(svc);\\n      }\\n      return this.store.getServiceData(serviceId);\\n    } catch (e) {\\n      console.warn('[live-data] getServiceData error for', serviceId, e?.message || e);\\n      return this.store.getServiceData(serviceId) || null;\\n    }\\n  }\\n\\n  _emitStatus() {\\n    if (!this.window || this.window.isDestroyed()) return;\\n    try {\\n      this.window.webContents.send(IPC_HANDLER_KEYS.LIVE_DATA_SUBSCRIBE, this.getServicesStatus());\\n    } catch (e) {\\n      console.warn('Failed to emit LIVE_DATA_SUBSCRIBE:', e);\\n    }\\n  }\\n\\n  _maybeTriggerOnLaunchUpdates() {\\n    for (const svc of this.services) {\\n      if (svc.autoUpdate?.enabled && (svc.autoUpdate?.trigger === 'onAppLaunch')) {\\n        if (!computeIsFresh(svc)) {\\n          this.triggerUpdate(svc.id); // fire-and-forget\\n        }\\n      }\\n    }\\n  }\\n\\n  stopWatching() {\\n    // Placeholder for future scheduled triggers\\n  }\\n}\\n\\n// Normalize shape for service entries read from storage or defaults\\nexport function normalizeService(service) {\\n  return {\\n    id: service.id,\\n    name: service.name,\\n    description: service.description,\\n    freshnessPolicy: service.freshnessPolicy || service.freshnessPolicy || 'daily',\\n    autoUpdate: typeof service.autoUpdate === 'object'\\n      ? { enabled: !!service.autoUpdate.enabled, trigger: service.autoUpdate.trigger || 'onAppLaunch', time: service.autoUpdate.time }\\n      : { enabled: !!service.autoUpdate, trigger: 'onAppLaunch' },\\n    lastUpdated: typeof service.lastUpdated === 'number'\\n      ? service.lastUpdated\\n      : (service.lastUpdated ? new Date(service.lastUpdated).getTime() : 0),\\n    config: service.config || {}, // free-form; may include url, headers, params, etc.\\n    isUpdating: !!service.isUpdating,\\n    scope: service.scope === 'project' ? 'project' : 'global',\\n    projectId: service.scope === 'project' ? (service.projectId || null) : null,\\n  };\\n}\\n\\n// Interface (documentation) for providers\\n// A provider implementation must expose: { id, update(service, deps), getData(service, deps) }\\n// - id: string (matches service id for built-ins or a generic provider id for dynamic services)\\n// - update: performs network or internal refresh, should persist data via store if applicable\\n// - getData: returns current data snapshot for the service\\n\\nexport function computeIsFresh(service, now = Date.now()) {\\n  if (!service.lastUpdated) return false;\\n  const diffMs = now - service.lastUpdated;\\n  const dayMs = 24 * 60 * 60 * 1000;\\n  switch (service.freshnessPolicy) {\\n    case 'daily':\\n      return diffMs < dayMs;\\n    case 'weekly':\\n      return diffMs < 7 * dayMs;\\n    case 'monthly':\\n      return diffMs < 30 * dayMs; // Approximate month\\n    default:\\n      return false;\\n  }\\n}\\n\"}},{\"tool_name\":\"write_file\",\"arguments\":{\"filename\":\"src/renderer/hooks/useLiveData.tsx\",\"content\":\"import { useEffect, useMemo, useState } from 'react';\\nimport { LiveDataProviderStatus, LiveDataProvider } from '../../live-data/LiveDataTypes';\\nimport { liveDataService } from '../services/liveDataService';\\nimport { useActiveProject } from '../projects/ProjectContext';\\n\\nexport default function useLiveData() {\\n  const { projectId: activeProjectId } = useActiveProject();\\n\\n  const [allServices, setAllServices] = useState<LiveDataProviderStatus[]>([]);\\n  const [services, setServices] = useState<LiveDataProviderStatus[]>([]);\\n  const [servicesById, setServicesById] = useState<Record<string,LiveDataProviderStatus>>({});\\n\\n  const filterForProject = (items: LiveDataProviderStatus[], projectId: string) => {\\n    return (items || []).filter(s => (s.scope !== 'project') || (s.projectId === projectId));\\n  };\\n\\n  const recomputeVisible = (items: LiveDataProviderStatus[], projectId: string) => {\\n    const filtered = filterForProject(items, projectId);\\n    setServices(filtered);\\n    const map: Record<string, LiveDataProviderStatus> = {};\\n    for (const s of filtered) map[s.id] = s;\\n    setServicesById(map);\\n  };\\n\\n  const update = async () => {\\n    const statuses = await liveDataService.getStatus();\\n    setAllServices(statuses);\\n    recomputeVisible(statuses, activeProjectId);\\n  };\\n\\n  const updateCurrentServices = (statuses: LiveDataProviderStatus[]) => {\\n    setAllServices(statuses);\\n    recomputeVisible(statuses, activeProjectId);\\n  };\\n  \\n  useEffect(() => {\\n    update();\\n\\n    const unsubscribe = liveDataService.subscribe(updateCurrentServices);\\n\\n    return () => {\\n      unsubscribe();\\n    };\\n  // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, []);\\n\\n  // If active project changes, re-filter without refetching\\n  useEffect(() => {\\n    recomputeVisible(allServices, activeProjectId);\\n  // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, [activeProjectId]);\\n\\n  const triggerUpdate = async (serviceId: string) : Promise<LiveDataProviderStatus | undefined> =>  {\\n    return await liveDataService.triggerUpdate(serviceId)\\n  }\\n  const updateConfig = async (serviceId: string, updates: Partial<Omit<LiveDataProvider,\\\"id\\\">>) : Promise<LiveDataProviderStatus> =>  {\\n    return liveDataService.updateConfig(serviceId, updates)\\n  }\\n  const addService = async (service: LiveDataProvider) : Promise<LiveDataProviderStatus> => {\\n    return await liveDataService.addService(service)\\n  }\\n  const removeService = async (serviceId: string) : Promise<boolean> => {\\n    return await liveDataService.removeService(serviceId)\\n  }\\n\\n  return { services, servicesById, triggerUpdate, updateConfig, addService, removeService };\\n}\"}},{\"tool_name\":\"write_file\",\"arguments\":{\"filename\":\"src/renderer/screens/LiveDataView.tsx\",\"content\":\"import { useState } from 'react';\\nimport type { LiveDataProvider, LiveDataProviderStatus } from '../../live-data/LiveDataTypes';\\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/Select';\\nimport { Switch } from '../components/ui/Switch';\\nimport useLiveData from '../hooks/useLiveData';\\nimport { useActiveProject } from '../projects/ProjectContext';\\n\\nfunction formatLastUpdated(ts: number | undefined | null) {\\n  if (!ts) return 'never';\\n  try {\\n    return new Date(ts).toLocaleString();\\n  } catch {\\n    return 'never';\\n  }\\n}\\n\\nfunction JsonBlock({ data }: { data: any }) {\\n  return (\\n    <pre className=\\\"mt-2 max-h-80 overflow-auto rounded bg-gray-50 p-2 text-xs text-gray-800 border\\\">\\n      {data == null ? 'No data available.' : JSON.stringify(data, null, 2)}\\n    </pre>\\n  );\\n}\\n\\ntype NewServiceForm = {\\n  id: string;\\n  name: string;\\n  description: string;\\n  url: string;\\n  freshnessPolicy: LiveDataProvider['freshnessPolicy'];\\n  autoEnabled: boolean;\\n  autoTrigger: 'onAppLaunch' | 'scheduled';\\n  scope: 'global' | 'project';\\n};\\n\\nexport default function LiveDataView() {\\n  const { projectId: activeProjectId } = useActiveProject();\\n  const { services, servicesById, triggerUpdate, updateConfig, addService } = useLiveData()\\n  const [openViewer, setOpenViewer] = useState<Record<string, boolean>>({});\\n  const [loadingData, setLoadingData] = useState<Record<string, boolean>>({});\\n  const [serviceData, setServiceData] = useState<Record<string, any>>({});\\n  const [errorByService, setErrorByService] = useState<Record<string, string | undefined>>({});\\n\\n  const [showAddForm, setShowAddForm] = useState(false);\\n  const [savingNew, setSavingNew] = useState(false);\\n  const [addError, setAddError] = useState<string | undefined>(undefined);\\n  const [newSvc, setNewSvc] = useState<NewServiceForm>({\\n    id: '',\\n    name: '',\\n    description: '',\\n    url: '',\\n    freshnessPolicy: 'daily',\\n    autoEnabled: true,\\n    autoTrigger: 'onAppLaunch',\\n    scope: 'project',\\n  });\\n\\n  const toggleViewer = async (s: LiveDataProviderStatus) => {\\n    const isOpen = !!openViewer[s.id];\\n    const next = { ...openViewer, [s.id]: !isOpen };\\n    setOpenViewer(next);\\n\\n    // If opening and no data loaded yet, try to fetch it now.\\n    if (!isOpen && serviceData[s.id] === undefined) {\\n      await fetchLatestForService(s);\\n    }\\n  };\\n\\n  const fetchLatestForService = async (s: LiveDataProviderStatus) => {\\n    setLoadingData(prev => ({ ...prev, [s.id]: true }));\\n    setErrorByService(prev => ({ ...prev, [s.id]: undefined }));\\n\\n    try {\\n      let data: any = null;\\n      if ((window as any).liveDataService?.getData) {\\n        data = await (window as any).liveDataService.getData(s.id);\\n      }\\n      setServiceData(prev => ({ ...prev, [s.id]: data }));\\n    } catch (e: any) {\\n      setErrorByService(prev => ({ ...prev, [s.id]: e?.message || 'Failed to load latest data' }));\\n    } finally {\\n      setLoadingData(prev => ({ ...prev, [s.id]: false }));\\n    }\\n  };\\n\\n  const handleUpdateNow = async (s: LiveDataProviderStatus) => {\\n    try {\\n      await triggerUpdate(s.id);\\n    } finally {\\n      // If the JSON viewer is open for this service, refresh its data preview to reflect latest updates\\n      if (openViewer[s.id]) {\\n        await fetchLatestForService(s);\\n      }\\n    }\\n  };\\n\\n  const resetAddForm = () => {\\n    setNewSvc({ id: '', name: '', description: '', url: '', freshnessPolicy: 'daily', autoEnabled: true, autoTrigger: 'onAppLaunch', scope: 'project' });\\n    setAddError(undefined);\\n  };\\n\\n  const handleSaveNewService = async () => {\\n    setAddError(undefined);\\n    if (!newSvc.id || !newSvc.name) {\\n      setAddError('Please provide both an ID and a Name.');\\n      return;\\n    }\\n    // Basic URL check if provided\\n    if (newSvc.url && !/^https?:\\\\/\\\\//i.test(newSvc.url)) {\\n      setAddError('URL must start with http:// or https://');\\n      return;\\n    }\\n\\n    setSavingNew(true);\\n    try {\\n      const payload: LiveDataProvider = {\\n        id: newSvc.id.trim(),\\n        name: newSvc.name.trim(),\\n        description: newSvc.description?.trim() || '',\\n        lastUpdated: 0,\\n        freshnessPolicy: newSvc.freshnessPolicy,\\n        autoUpdate: { enabled: !!newSvc.autoEnabled, trigger: newSvc.autoTrigger },\\n        config: newSvc.url ? { url: newSvc.url.trim() } : {},\\n        scope: newSvc.scope,\\n        projectId: newSvc.scope === 'project' ? activeProjectId : null,\\n      };\\n      await addService(payload);\\n      setShowAddForm(false);\\n      resetAddForm();\\n    } catch (e: any) {\\n      setAddError(e?.message || 'Failed to add service');\\n    } finally {\\n      setSavingNew(false);\\n    }\\n  };\\n\\n  return (\\n    <div className=\\\"p-4\\\">\\n      <div className=\\\"flex items-center justify-between\\\">\\n        <h1 className=\\\"text-2xl font-bold\\\">Live Data</h1>\\n        <button\\n          className=\\\"px-3 py-1 rounded bg-blue-600 text-white hover:bg-blue-700\\\"\\n          onClick={() => setShowAddForm(v => !v)}\\n        >\\n          {showAddForm ? 'Cancel' : '+ Add provider'}\\n        </button>\\n      </div>\\n\\n      {showAddForm && (\\n        <div className=\\\"mt-4 border rounded p-3 bg-white\\\">\\n          <div className=\\\"font-semibold mb-2\\\">Add live data provider</div>\\n\\n          {addError && <div className=\\\"text-sm text-red-700 mb-2\\\">{addError}</div>}\\n\\n          <div className=\\\"grid grid-cols-1 md:grid-cols-2 gap-4\\\">\\n            <div className=\\\"flex flex-col gap-1\\\">\\n              <label className=\\\"text-sm font-medium\\\">ID</label>\\n              <input\\n                className=\\\"border rounded px-2 py-1 text-sm\\\"\\n                value={newSvc.id}\\n                onChange={e => setNewSvc({ ...newSvc, id: e.target.value })}\\n                placeholder=\\\"unique-id\\\"\\n              />\\n              <span className=\\\"text-xs text-gray-500\\\">Must be unique. For custom JSON providers, choose any id.</span>\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1\\\">\\n              <label className=\\\"text-sm font-medium\\\">Name</label>\\n              <input\\n                className=\\\"border rounded px-2 py-1 text-sm\\\"\\n                value={newSvc.name}\\n                onChange={e => setNewSvc({ ...newSvc, name: e.target.value })}\\n                placeholder=\\\"Display name\\\"\\n              />\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1 md:col-span-2\\\">\\n              <label className=\\\"text-sm font-medium\\\">Description</label>\\n              <textarea\\n                className=\\\"border rounded px-2 py-1 text-sm\\\"\\n                value={newSvc.description}\\n                onChange={e => setNewSvc({ ...newSvc, description: e.target.value })}\\n                placeholder=\\\"What does this provider fetch?\\\"\\n              />\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1 md:col-span-2\\\">\\n              <label className=\\\"text-sm font-medium\\\">Fetch URL (for JSON provider)</label>\\n              <input\\n                className=\\\"border rounded px-2 py-1 text-sm\\\"\\n                value={newSvc.url}\\n                onChange={e => setNewSvc({ ...newSvc, url: e.target.value })}\\n                placeholder=\\\"https://example.com/data.json\\\"\\n              />\\n              <span className=\\\"text-xs text-gray-500\\\">If provided, this provider will fetch JSON from the URL using the generic fetcher.</span>\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1\\\">\\n              <label className=\\\"text-sm font-medium\\\">Freshness policy</label>\\n              <Select\\n                value={newSvc.freshnessPolicy}\\n                onValueChange={(val: LiveDataProvider['freshnessPolicy']) =>\\n                  setNewSvc({ ...newSvc, freshnessPolicy: val })\\n                }\\n              >\\n                <SelectTrigger size=\\\"sm\\\">\\n                  <SelectValue placeholder=\\\"Select policy\\\" />\\n                </SelectTrigger>\\n                <SelectContent>\\n                  <SelectItem value=\\\"daily\\\">Daily</SelectItem>\\n                  <SelectItem value=\\\"weekly\\\">Weekly</SelectItem>\\n                  <SelectItem value=\\\"monthly\\\">Monthly</SelectItem>\\n                </SelectContent>\\n              </Select>\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-1\\\">\\n              <label className=\\\"text-sm font-medium\\\">Visibility</label>\\n              <Select\\n                value={newSvc.scope}\\n                onValueChange={(val: 'global' | 'project') => setNewSvc({ ...newSvc, scope: val })}\\n              >\\n                <SelectTrigger size=\\\"sm\\\">\\n                  <SelectValue placeholder=\\\"Select scope\\\" />\\n                </SelectTrigger>\\n                <SelectContent>\\n                  <SelectItem value=\\\"project\\\">This project only</SelectItem>\\n                  <SelectItem value=\\\"global\\\">All projects (global)</SelectItem>\\n                </SelectContent>\\n              </Select>\\n              <span className=\\\"text-xs text-gray-500\\\">\\n                {newSvc.scope === 'project' ? `Will be attached to project: ${activeProjectId}` : 'Visible from every project.'}\\n              </span>\\n            </div>\\n\\n            <div className=\\\"flex flex-col gap-2\\\">\\n              <Switch\\n                checked={!!newSvc.autoEnabled}\\n                onCheckedChange={(checked) => setNewSvc({ ...newSvc, autoEnabled: checked })}\\n                label=\\\"Automated checks\\\"\\n              />\\n              {newSvc.autoEnabled && (\\n                <div className=\\\"flex items-center gap-2\\\">\\n                  <span className=\\\"text-sm text-[var(--text-secondary)]\\\">When:</span>\\n                  <Select\\n                    value={newSvc.autoTrigger}\\n                    onValueChange={(val: 'onAppLaunch' | 'scheduled') => setNewSvc({ ...newSvc, autoTrigger: val })}\\n                  >\\n                    <SelectTrigger size=\\\"sm\\\" className=\\\"w-[200px]\\\">\\n                      <SelectValue />\\n                    </SelectTrigger>\\n                    <SelectContent>\\n                      <SelectItem value=\\\"onAppLaunch\\\">On app launch</SelectItem>\\n                      <SelectItem value=\\\"scheduled\\\">On schedule</SelectItem>\\n                    </SelectContent>\\n                  </Select>\\n                </div>\\n              )}\\n            </div>\\n          </div>\\n\\n          <div className=\\\"mt-3 flex gap-2\\\">\\n            <button\\n              disabled={savingNew}\\n              onClick={handleSaveNewService}\\n              className={`px-3 py-1 rounded text-white ${savingNew ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'}`}\\n            >\\n              {savingNew ? 'Adding…' : 'Add provider'}\\n            </button>\\n            <button\\n              disabled={savingNew}\\n              onClick={() => { setShowAddForm(false); resetAddForm(); }}\\n              className=\\\"px-3 py-1 rounded border text-gray-800 hover:bg-gray-50\\\"\\n            >\\n              Cancel\\n            </button>\\n          </div>\\n        </div>\\n      )}\\n\\n      {services.length === 0 ? (\\n        <div className=\\\"mt-4 text-gray-700\\\">No live data services are configured for this project.</div>\\n      ) : (\\n        <div className=\\\"mt-4 space-y-3\\\">\\n          {services.map((s) => (\\n            <div key={s.id} className=\\\"border rounded p-3\\\">\\n              <div className=\\\"flex items-center justify-between\\\">\\n                <div>\\n                  <div className=\\\"font-semibold flex items-center gap-2\\\">\\n                    <span>{s.name}</span>\\n                    <span className={`text-xs px-2 py-0.5 rounded-full border ${s.scope === 'project' ? 'text-purple-700 border-purple-300 bg-purple-50' : 'text-gray-700 border-gray-300 bg-gray-50'}`}>\\n                      {s.scope === 'project' ? 'Project' : 'Global'}\\n                    </span>\\n                  </div>\\n                  {s.description && <div className=\\\"text-sm text-gray-600\\\">{s.description}</div>}\\n                </div>\\n                <div className=\\\"flex items-center gap-2\\\">\\n                  <button\\n                    onClick={() => toggleViewer(s)}\\n                    className=\\\"px-3 py-1 rounded border text-gray-800 hover:bg-gray-50\\\"\\n                  >\\n                    {openViewer[s.id] ? 'Hide data' : 'Show data'}\\n                  </button>\\n                  <button\\n                    disabled={!!s.isUpdating}\\n                    onClick={() => handleUpdateNow(s)}\\n                    className={`px-3 py-1 rounded text-white ${s.isUpdating ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'}`}\\n                  >\\n                    {s.isUpdating ? 'Updating…' : 'Update now'}\\n                  </button>\\n                </div>\\n              </div>\\n\\n              {/* Status row */}\\n              <div className=\\\"mt-2 text-sm text-gray-700 flex flex-wrap gap-4\\\">\\n                <span>\\n                  Status: <span className={s.isFresh ? 'text-green-600' : 'text-amber-700'}>{s.isFresh ? 'Up to date' : 'Stale'}</span>\\n                </span>\\n                <span>Last updated: {formatLastUpdated(s.lastUpdated)}</span>\\n              </div>\\n\\n              {/* JSON viewer */}\\n              {openViewer[s.id] && (\\n                <div className=\\\"mt-3\\\">\\n                  {loadingData[s.id] ? (\\n                    <div className=\\\"text-sm text-gray-600\\\">Loading latest data…</div>\\n                  ) : errorByService[s.id] ? (\\n                    <div className=\\\"text-sm text-red-600\\\">{errorByService[s.id]}</div>\\n                  ) : (\\n                    <JsonBlock data={serviceData[s.id]} />\\n                  )}\\n                  <div className=\\\"mt-2\\\">\\n                    <button\\n                      onClick={() => fetchLatestForService(s)}\\n                      className=\\\"text-xs text-blue-700 underline\\\"\\n                    >\\n                      Refresh data preview\\n                    </button>\\n                  </div>\\n                </div>\\n              )}\\n\\n              {/* Configuration controls */}\\n              <div className=\\\"mt-3 grid grid-cols-1 md:grid-cols-2 gap-4\\\">\\n                {/* Freshness policy */}\\n                <div className=\\\"flex flex-col gap-1\\\">\\n                  <label className=\\\"text-sm font-medium text-[var(--text-primary)]\\\">Freshness policy</label>\\n                  <Select\\n                    value={s.freshnessPolicy}\\n                    onValueChange={(val: LiveDataProvider['freshnessPolicy']) =>\\n                      updateConfig(s.id, { freshnessPolicy: val })\\n                    }\\n                  >\\n                    <SelectTrigger size=\\\"sm\\\">\\n                      <SelectValue placeholder=\\\"Select policy\\\" />\\n                    </SelectTrigger>\\n                    <SelectContent>\\n                      <SelectItem value=\\\"daily\\\">Daily</SelectItem>\\n                      <SelectItem value=\\\"weekly\\\">Weekly</SelectItem>\\n                      <SelectItem value=\\\"monthly\\\">Monthly</SelectItem>\\n                    </SelectContent>\\n                  </Select>\\n                </div>\\n\\n                {/* Auto-update toggle and trigger */}\\n                <div className=\\\"flex flex-col gap-2\\\">\\n                  <Switch\\n                    checked={!!s.autoUpdate?.enabled}\\n                    onCheckedChange={(checked) =>\\n                      updateConfig(s.id, { autoUpdate: { ...(s.autoUpdate || { trigger: 'onAppLaunch' }), enabled: checked } })\\n                    }\\n                    label=\\\"Automated checks\\\"\\n                  />\\n                  {s.autoUpdate?.enabled && (\\n                    <div className=\\\"flex items-center gap-2\\\">\\n                      <span className=\\\"text-sm text-[var(--text-secondary)]\\\">When:</span>\\n                      <Select\\n                        value={s.autoUpdate?.trigger || 'onAppLaunch'}\\n                        onValueChange={(val: 'onAppLaunch' | 'scheduled') =>\\n                          updateConfig(s.id, { autoUpdate: { ...(s.autoUpdate || { enabled: true }), trigger: val } })\\n                        }\\n                      >\\n                        <SelectTrigger size=\\\"sm\\\" className=\\\"w-[200px]\\\">\\n                          <SelectValue />\\n                        </SelectTrigger>\\n                        <SelectContent>\\n                          <SelectItem value=\\\"onAppLaunch\\\">On app launch</SelectItem>\\n                          <SelectItem value=\\\"scheduled\\\">On schedule</SelectItem>\\n                        </SelectContent>\\n                      </Select>\\n                    </div>\\n                  )}\\n                </div>\\n              </div>\\n            </div>\\n          ))}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\"}},{\"tool_name\":\"write_file\",\"arguments\":{\"filename\":\"src/renderer/services/liveDataService.ts\",\"content\":\"import { LiveDataProvider, LiveDataProviderStatus } from \\\"src/live-data/LiveDataTypes\\\"\\n\\nexport type LiveDataService = {\\n  subscribe: (callback: (statuses: LiveDataProviderStatus[]) => void) => () => void\\n  getStatus: () => Promise<LiveDataProviderStatus[]>\\n  triggerUpdate: (serviceId: string) => Promise<LiveDataProviderStatus | undefined>\\n  updateConfig: (serviceId: string, updates: Partial<Omit<LiveDataProvider, \\\"id\\\">>) => Promise<LiveDataProviderStatus>\\n  getData: (serviceId: string) => Promise<any>\\n  addService: (service: LiveDataProvider) => Promise<LiveDataProviderStatus>\\n  removeService: (serviceId: string) => Promise<boolean>\\n}\\n\\nexport const liveDataService: LiveDataService = { ...window.liveDataService }\"}},{\"tool_name\":\"finish_feature\",\"arguments\":{}}]}",
        "featureId": "ada1bb79-e120-493b-b0ba-13d11951b42b",
        "agentType": "developer",
        "turn": 2,
        "askedAt": "2025-09-09T17:56:43.011Z",
        "createdAt": "2025-09-09T17:59:19.643Z"
      }
    ],
    "endDate": "2025-09-09T17:59:19.643Z"
  }
}