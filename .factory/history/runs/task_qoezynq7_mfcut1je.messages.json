{
  "753f6df3-59a8-4fe0-972b-1dae53c20a15": {
    "featureId": "753f6df3-59a8-4fe0-972b-1dae53c20a15",
    "startDate": "2025-09-09T17:58:03.820Z",
    "messages": [
      {
        "role": "user",
        "content": "# Developer Agent Steps Execution\n\nYou are the Developer Agent. You will be assigned a single feature to implement. Your goal is to complete it by following these steps precisely.\n\n## Workflow\n\n1.  **Analyze the Feature**: Read the feature's title, description and rejection (if provided) to understand its goal.\n2.  **Consult the File Structure**: Use the provided `docs/FILE_ORGANISATION.md` to understand the project context.\n3.  **Implement**: Write or modify files to meet the feature's acceptance criteria. Use the `write_file`, `rename_file`, `delete_file`, `list_files` and `search_files` tools for all file operations.\n4.  **Complete the Feature**: When the feature is complete, you **MUST** call the `finish_feature` tool. This is your final step for a successful implementation.\n5.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_feature` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n## Notes\n\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\n#CURRENT TASK (ID: 89257920-d018-41bf-892a-583569d11d53)\n##TITLE:\nOngoing improvements\n##DESCRIPTION:\n\n\n\n#ASSIGNED FEATURE: Just like webSearchApiKeys are passed in - so should be githubCredentials (ID: 753f6df3-59a8-4fe0-972b-1dae53c20a15)\n##DESCRIPTION: Inside @src/orchestrator.ts for the 'startRun' function we are accepting webSearchApiKeys - we must also accept githubCredentials that will be used for all git operations (we cannot rely on any env variables).\n\n\n\n\n#ACCEPTANCE CRITERIA:\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- write_file(filename: str, content: str) - Create or overwrite a file with the given content. Always use this to write code or docs.\n- rename_file(filename: str, new_filename: str) - Rename or move a file from one path to another.\n- delete_file(filename: str) - Delete a file. Use with caution and only when necessary.\n- run_test() -> str - Run the test for the current feature and return the output. Use to verify implementation.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n[object Object]\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\nAs responses to the tool calls you will send, you will also receive JSON objects in the form:\n```json\n{\n\"name\":\"tool_name\",\n\"result\":\"...\"\n}\n```\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"# Project File and Tooling Organisation\\n\\n## Overview\\n- This repository implements a multi-agent development workflow, with tools for reading/writing files, managing tasks and features, running tests, and exposing these as chat-callable tools.\\n- Source code lives under src/. Tasks and artifacts live under tasks/. Documentation lives under docs/.\\n- The main toolsets are composed in src/tools/tools.ts.\\n\\n## Top-level Layout\\n- docs/: Human-facing documentation for agents, communication protocol, and project overview.\\n- src/: Source code for orchestration, tooling, and types.\\n- tasks/: Per-task directories containing task.json and related test files.\\n- types/: Type declaration helpers (e.g., markdown.d.ts).\\n- package.json, tsconfig.json, vitest.config.ts: Build/test configuration.\\n\\n## Key Source Modules\\n- src/index.ts: Entry point/export surface for the library (may wire up orchestrator/tools; see code for details in this repo version).\\n- src/orchestrator.ts: Orchestration logic to coordinate agents and tools (drives workflows around tasks/features).\\n- src/gitManager.ts: Thin wrapper managing git operations (e.g., pushAll) used by task and feature flows.\\n- src/logger.ts: Logging utilities.\\n- src/completion.ts: AI completion utilities.\\n- src/pricing.ts: Default/model pricing utilities (used by orchestration and completion logic).\\n- src/utils.ts: Misc helpers and utilities for filesystem-safe operations and path helpers:\\n  - ensureDir(dir)\\n  - isWithinRoot(root, abs)\\n  - getTasksDir(root)\\n  - getTaskPath(root, taskId)\\n  - getTestPath(root, taskId, featureId)\\n  - getProjectsDir(root)\\n  - getProjectPath(root, projectId)\\n  - uuidv4()\\n\\n## Tasks and Features\\n- tasks/<taskId>/\\n  - task.json: canonical task spec with features and status.\\n  - tests/ or per-feature test paths as determined by getTestPath in workflowUtils.\\n\\n## Documentation (docs/)\\n- AGENT_* files describe roles and protocols: Developer, Planner, Tester, Speccer, Contexter.\\n- AGENT_COMMUNICATION_PROTOCOL.md: General messaging and tool-calling protocols.\\n- FILE_ORGANISATION.md: This file.\\n\\n## Tools Overview (src/tools)\\nAll toolsets are factory functions taking a projectRoot (string) unless stateless.\\n\\n### fileTools (src/tools/fileTools.ts)\\n- createFileTools(projectRoot): returns FileTools API\\n  - listFiles(path): string[] — list entries of a directory (project-relative). Returns [] if invalid.\\n  - readFiles(paths: string[]): JSON-stringified map relPath -> content|listing|error.\\n  - writeFile(path, content): writes text content; creates directories; security checked.\\n  - renameFile(src, dst): rename/move with security checks.\\n  - deleteFile(path): deletes file or directory (non-recursive rmdir for directories).\\n  - searchFiles(query, path='.'): filesystem scan.\\n\\n### taskTools (src/tools/taskTools.ts)\\n- createTaskTools(projectRoot): returns TaskTools API operating on tasks/<taskId>/task.json.\\n  - listTasks(): Task[] — enumerate tasks by reading all tasks/*/task.json.\\n  - getTask(taskId): Task\\n  - saveTask(task): void\\n  - updateTaskStatus(taskId, status): Task\\n  - blockTask(taskId, reason, agentType, git): Task — sets blocked, commits via git.pushAll.\\n  - finishSpec(taskId, agentType, git): void — marks spec finished via git.\\n  - getFeatureFromIndex(taskId, index): Feature|undefined — resolve feature by display index.\\n  - createFeature(taskId, title, description): Feature — updates indices and task status.\\n  - updateFeatureStatus(taskId, featureId, status): Feature|undefined\\n  - updateFeaturePlan(taskId, featureId, plan): Feature|undefined — persists plan (stringified).\\n  - updateFeatureContext(taskId, featureId, context: string[]): Feature|undefined\\n  - updateFeatureAcceptance(taskId, featureId, acceptance): Feature|undefined\\n  - blockFeature(taskId, featureId, reason, agentType, git): Feature|undefined — sets blocked and commits.\\n  - finishFeature(taskId, featureId, agentType, git): string — updates feature status based on agent and commits.\\n\\n### projectTools (src/tools/projectTools.ts)\\n- createProjectTools(projectRoot): returns ProjectTools API for project metadata.\\n  - getProject(projectId): ProjectSpec — loads project spec at getProjectPath(root, projectId).\\n  - getProjectDir(projectId): string — resolves the project working directory under getProjectsDir(root) + project.path.\\n  - getTaskIdFromIndex(projectId, index): string|undefined — reverse-lookup task id by display index from project.taskIdToDisplayIndex.\\n\\n### testTools (src/tools/testTools.ts)\\n- createTestTools(projectRoot): returns TestTools API; test files are Python scripts addressed by task/feature.\\n  - getTest(taskId, featureId): string — reads contents or returns not-found message.\\n  - updateTest(taskId, featureId, test: string): string — writes test to path from getTestPath.\\n  - deleteTest(taskId, featureId): string — deletes if present.\\n  - runTest(taskId, featureId): string — executes python3 on the test file with a 30s kill timeout; returns PASS/FAIL and captured output.\\n\\n### webSearchTools (src/tools/webSearchTools.ts)\\n- createWebSearchTools(webSearchApiKeys): returns WebSearchTools API for normalized web search across providers.\\n  - webSearch({ query, limit?, providers? }): chooses provider by availability or explicit in order of selection.\\n\\n### chatTools (src/tools/chatTools.ts)\\n- buildChatTools({ repoRoot, projectId }): returns { tools, callTool } for LLM tool calling.\\n  - tools: array of ChatTool descriptors (OpenAI function tool format) exposing various other tools:\\n    - list_tasks\\n    - get_task_reference(reference: '#<task>[.<feature>]')\\n    - list_files(path)\\n    - search_files(query[, path])\\n    - read_files(paths[])\\n    - write_file(name, content)\\n    - web_search(query[, limit, providers])\\n\\n\\n## Tool Composition (src/tools/tools.ts)\\n- createTools(projectRoot, webSearchApiKeys) merges APIs:\\n  - ...createTaskTools(projectRoot)\\n  - ...createTestTools(projectRoot)\\n  - ...createFileTools(projectRoot)\\n  - ...createProjectTools(projectRoot)\\n  - ...createWebSearchTools(webSearchApiKeys)\\n\\n## Extending Tools\\n- Add a new toolset file under src/tools/, export a factory createXTools(projectRoot) returning an object of functions.\\n- Update src/tools/tools.ts to spread ...createXTools(projectRoot) into the composed API.\\n- If you want the tool callable from chat, add a ChatTool descriptor to tools[] and a case in callTool(name, args) in src/tools/chatTools.ts.\\n- Follow security patterns: resolve absolute paths using project root, guard with isWithinRoot for filesystem operations, and ensure directories exist via ensureDir.\\n\\n## Conventions and Notes\\n- All filesystem operations are project-root-scoped and must not escape the repo.\\n- Search is keyword-based, space-separated, case-insensitive, and size-limited to 2MB files.\\n- GitManager is expected to implement pushAll(message) used by task/feature state transitions.\\n\",\"src/orchestrator.ts\":\"import fs from 'node:fs';\\nimport fsp from 'node:fs/promises';\\nimport path from 'node:path';\\nimport os from 'node:os';\\nimport { AgentResponse, AgentType, CompletionClient, CompletionMessage, Feature, MatchAgentResponse, MatchToolCall, Task, ToolCall, ToolResult, WebSearchApiKeys } from './types.js';\\nimport type { GitManager } from './gitManager';\\nimport { logger, logLLMStep } from './logger';\\nimport agent_response_example from '../docs/agent_response_example.json'\\nimport { getAgentFile, normalizeToolArguments, findNextAvailableFeature } from './utils';\\nimport { createTools, Tools } from './tools/tools';\\n\\nconst MAX_TURNS_PER_FEATURE = 100;\\n\\nconst NEWLINE = '\\\\n';\\n\\nconst PROTOCOL_INSTRUCTIONS = (() => {\\n  return [\\n    'You **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:',\\n    '```json',\\n    agent_response_example,\\n    '```',\\n    'The thoughts field is for your reasoning, and tool_calls is a list of actions to execute.',\\n    'Your response will be parsed as JSON. Do not include any text outside of this JSON object.',\\n    'As responses to the tool calls you will send, you will also receive JSON objects in the form:',\\n    '```json',\\n    '{\\\\n\\\"name\\\":\\\"tool_name\\\",\\\\n\\\"result\\\":\\\"...\\\"\\\\n}',\\n    '```',\\n  ].join('\\\\n');\\n})();\\n\\n// Human-readable descriptions for tools to avoid duplicating them in agent docs\\nconst TOOL_DESCRIPTIONS: Record<string, string> = {\\n  // Base tools\\n  read_files: 'Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).',\\n  search_files: 'Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords',\\n  list_files: 'List files and directories at a relative path from the project root.',\\n  finish_feature: 'Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.',\\n  block_feature: 'Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).',\\n\\n  // Speccer\\n  create_feature: 'Define and add a new, atomic feature to the task. Include a concise title and a clear description.',\\n  finish_spec: 'Signal that the feature specification is complete for the current task.',\\n  block_task: 'Stop work on the task and report why you are blocked at the task level.',\\n\\n  // Developer\\n  write_file: 'Create or overwrite a file with the given content. Always use this to write code or docs.',\\n  rename_file: 'Rename or move a file from one path to another.',\\n  delete_file: 'Delete a file. Use with caution and only when necessary.',\\n  run_test: 'Run the test for the current feature and return the output. Use to verify implementation.',\\n\\n  // Planner\\n  update_feature_plan: 'Save a concise, step-by-step implementation plan for the assigned feature.',\\n\\n  // Tester\\n  update_feature_acceptance: 'Save a clear, verifiable list of acceptance criteria for the assigned feature.',\\n  update_test: 'Save the Python test script that validates the acceptance criteria for this feature.',\\n\\n  // Contexter\\n  update_feature_context: 'Save the minimal set of file paths (relative to repo root) required to implement the feature.'\\n};\\n\\nfunction toolSigsForAgent(agent: string, tools: Tools, git: GitManager): [Record<string, (args: any) => Promise<any> | any>, string[]] {\\n  const base: Record<string, [(args: any) => Promise<any> | any, string]> = {\\n    read_files: [ (args: { paths: string[] }) => tools.readFiles(args.paths), \\\"read_files(paths: list[str]) -> list[str]\\\" ],\\n    search_files: [ (args: { query: string; path?: string }) => tools.searchFiles(args.query, args.path ?? '.'), \\\"search_files(query: str, path: str = '.') -> list[str]\\\" ],\\n    block_feature: [ (args: { task_id: string; feature_id: string; reason: string }) => tools.blockFeature?.(args.task_id, args.feature_id, args.reason, agent, git), 'block_feature(reason: str)' ],\\n    finish_feature: [ (args: { task_id: string; feature_id: string }) => tools.finishFeature?.(args.task_id, args.feature_id, agent, git), 'finish_feature()' ],\\n    list_files: [ (args: { path: string }) => tools.listFiles(args.path), 'list_files(path: str)' ],\\n  };\\n\\n  const agentTools: Record<string, [(args: any) => Promise<any> | any, string]> = {};\\n\\n  if (agent === 'speccer') {\\n    agentTools.create_feature = [ (args: { task_id: string; title: string; description: string }) => tools.createFeature(args.task_id, args.title, args.description), 'create_feature(title: str, description: str)' ];\\n    agentTools.finish_spec = [ (args: { task_id: string }) => tools.finishSpec(args.task_id, agent, git), 'finish_spec()' ];\\n    agentTools.block_task = [ (args: { task_id: string; reason: string }) => tools.blockTask(args.task_id, args.reason, agent, git), 'block_task()' ];\\n  } else if (agent === 'developer') {\\n    agentTools.write_file = [ (args: { filename: string; content: string }) => tools.writeFile(args.filename, args.content), 'write_file(filename: str, content: str)' ];\\n    agentTools.rename_file = [ (args: { filename: string; new_filename: string }) => tools.renameFile(args.filename, args.new_filename), 'rename_file(filename: str, new_filename: str)' ];\\n    agentTools.delete_file = [ (args: { filename: string }) => tools.deleteFile(args.filename), 'delete_file(filename: str)' ];\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => tools.runTest(args.task_id, args.feature_id), 'run_test() -> str' ];\\n  } else if (agent === 'planner') {\\n    agentTools.update_feature_plan = [ (args: { task_id: string; feature_id: string; plan: any }) => tools.updateFeaturePlan(args.task_id, args.feature_id, args.plan), 'update_feature_plan(plan: str)' ];\\n  } else if (agent === 'tester') {\\n    agentTools.update_feature_acceptance = [ (args: { task_id: string; feature_id: string; criteria: string }) => tools.updateFeatureAcceptance(args.task_id, args.feature_id, args.criteria), 'update_feature_acceptance(criteria: str)' ];\\n    agentTools.update_test = [ (args: { task_id: string; feature_id: string; test: string }) => tools.updateTest(args.task_id, args.feature_id, args.test), 'update_test(test: str)' ];\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => tools.runTest(args.task_id, args.feature_id), 'run_test() -> str' ];\\n  } else if (agent === 'contexter') {\\n    agentTools.update_feature_context = [ (args: { task_id: string; feature_id: string; context: string[] }) => tools.updateFeatureContext(args.task_id, args.feature_id, args.context), 'update_feature_context(context: list[str])' ];\\n  }\\n\\n  const merged = { ...base, ...agentTools };\\n  const funcs: Record<string, (args: any) => Promise<any> | any> = {};\\n  const sigs: string[] = [];\\n  for (const [name, [fn, sig]] of Object.entries(merged)) {\\n    if (fn) {\\n      funcs[name] = fn;\\n      const desc = TOOL_DESCRIPTIONS[name] ? ` - ${TOOL_DESCRIPTIONS[name]}` : '';\\n      sigs.push(`${sig}${desc}`);\\n    }\\n  }\\n  return [funcs, sigs];\\n}\\n\\nfunction constructSystemPrompt(agent: string, task: Task, feature: Feature | null, agentSystemPrompt: string, context: string, toolSignatures: string[]): string {\\n  const plan = feature && (agent === 'developer' || agent === 'tester' || agent === 'contexter' || agent === 'planner') ? feature.plan : undefined;\\n  const acceptance = feature && (agent === 'developer' || agent === 'tester') ? feature.acceptance : undefined\\n  const toolSignaturesStr = toolSignatures.map(sig => `- ${sig}`).join('\\\\n');\\n\\n  const featureBlock = feature ? `#ASSIGNED FEATURE: ${feature.title} (ID: ${feature.id})${NEWLINE}##DESCRIPTION: ${feature.description}${NEWLINE}` : '';\\n  const featureRejection = feature?.rejection ? `##REJECTION REASON:${NEWLINE}${feature.rejection}${NEWLINE}` : '';\\n  const taskRejection = task.rejection ? `##REJECTION REASON:${NEWLINE}${task.rejection}` : '';\\n\\n  return [\\n    agentSystemPrompt,\\n    `#CURRENT TASK (ID: ${task.id})`,\\n    '##TITLE:',\\n    task.title,\\n    '##DESCRIPTION:',\\n    task.description,\\n    taskRejection,\\n    '',\\n    featureBlock,\\n    featureRejection,\\n    plan ? '#THE PLAN' + plan : '',\\n    '',\\n    acceptance ? '#ACCEPTANCE CRITERIA:' + acceptance : '',\\n    '',\\n    '#TOOL SIGNATURES:',\\n    `${toolSignaturesStr}`,\\n    '',\\n    '#RESPONSE FORMAT INSTRUCTIONS:',\\n    PROTOCOL_INSTRUCTIONS,\\n    '',\\n    '#CONTEXT FILES PROVIDED:',\\n    context,\\n    '',\\n    'Begin now.'\\n  ].join('\\\\n');\\n}\\n\\n// Attach metadata to messages so history can be reconstructed reliably after persistence\\nfunction annotateMessage<T extends CompletionMessage>(msg: T, meta: { featureId?: string; agentType?: string; turn?: number; source?: string; marker?: string; askedAt?: string }): T {\\n  const anyMsg = msg as any;\\n  if (meta.featureId) anyMsg.featureId = meta.featureId;\\n  if (meta.agentType) anyMsg.agentType = meta.agentType;\\n  if (typeof meta.turn === 'number') anyMsg.turn = meta.turn;\\n  if (meta.source) anyMsg.source = meta.source;\\n  if (meta.marker) anyMsg.marker = meta.marker;\\n  if (meta.askedAt) anyMsg.askedAt = meta.askedAt;\\n  anyMsg.createdAt = new Date().toISOString();\\n  return msg;\\n}\\n\\n// Grouped history structure for persistence/readability\\ntype FeatureMessagesGroup = { startDate: string; endDate?: string; featureId: string; messages: CompletionMessage[] };\\n\\nfunction ensureGroup(groups: Record<string, FeatureMessagesGroup>, featureId: string): FeatureMessagesGroup {\\n  if (!groups[featureId]) {\\n    groups[featureId] = { featureId, startDate: new Date().toISOString(), messages: [] };\\n  }\\n  return groups[featureId];\\n}\\n\\nfunction parseAgentResponse(content: string) : AgentResponse | undefined\\n{\\n  let parsed: MatchAgentResponse | undefined;\\n  try { parsed = JSON.parse(content) as MatchAgentResponse; } catch {}\\n\\n  if (!parsed) { return }\\n  const thoughts = parsed.thoughts\\n  const toolCallsMatched: MatchToolCall[] = parsed.tool_calls ?? parsed.tools ?? parsed.calls ?? []; \\n\\n  let tool_calls : ToolCall[] = []\\n  for(const t of toolCallsMatched){\\n    tool_calls.push({\\n      tool_name: t.tool_name ?? t.name ?? t.tool ?? \\\"\\\",\\n      arguments: t.arguments ?? t.args ?? t.parameters ?? t.params,\\n    })\\n  }\\n  return { thoughts, tool_calls }\\n}\\n\\nasync function runConversation(opts: {\\n  model: string;\\n  availableTools: Record<string, (args: any) => Promise<any> | any>;\\n  systemPrompt: string;\\n  task: Task;\\n  feature: Feature | null;\\n  agentType: string;\\n  toolFunctions: Tools;\\n  git: GitManager;\\n  completion: CompletionClient;\\n  complete: (why: 'finish' | 'block' | 'max_turns', info?: any) => void;\\n  emit?: (e: { type: string; payload?: any }) => void; // event sink for logging/stats\\n}) {\\n  const { model, availableTools, systemPrompt, task, feature, agentType, toolFunctions, git, completion, complete, emit } = opts;\\n  const doEmit = (e: { type: string; payload?: any }) => { try { emit?.(e); } catch {} };\\n\\n  const featureKey = feature?.id ?? '__task__';\\n\\n  const initialUser: CompletionMessage = annotateMessage(\\n    { role: 'user', content: systemPrompt } as any,\\n    { featureId: featureKey, agentType, turn: 0, source: 'initial' }\\n  );\\n  const messages: CompletionMessage[] = [initialUser];\\n  doEmit({ type: 'llm/messages/init', payload: { messages: messages.slice(), featureId: featureKey, turn: 0 } });\\n\\n  for (let i = 0; i < MAX_TURNS_PER_FEATURE; i++) {\\n    try {\\n      // Emit snapshot of request context before calling the LLM\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i } });\\n      const startedAt = Date.now();\\n      const res = await completion({ model, messages, response_format: { type: 'json_object' } });\\n      const durationMs = Date.now() - startedAt;\\n\\n      const agentResponse = parseAgentResponse(res.message.content)\\n\\n      const assistant = annotateMessage(\\n        { role: 'assistant' as const, content: JSON.stringify(agentResponse) ?? res.message.content },\\n        { featureId: featureKey, agentType, turn: i, askedAt: new Date(startedAt).toISOString() }\\n      );\\n      messages.push(assistant);\\n      // Emit assistant message and timing\\n      doEmit({ type: 'llm/message', payload: { message: assistant, featureId: featureKey, durationMs } });\\n\\n      // Parse and log succinct info\\n      logLLMStep({ turn: i, thoughts: agentResponse?.thoughts, toolCalls: agentResponse?.tool_calls, durationMs, tag: agentType });\\n\\n      if (!agentResponse?.tool_calls?.length) {\\n        // No tool calls; continue loop.\\n        doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i, note: 'no_tool_calls' } });\\n        doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} complete` } });\\n        continue;\\n      }\\n\\n      const toolOutputs: ToolResult[] = [];\\n\\n      for (const call of agentResponse.tool_calls) {\\n        const toolName = call.tool_name;\\n        let args = normalizeToolArguments(call.arguments, toolName);\\n\\n        if (availableTools[toolName]) {\\n          if (!('task_id' in args)) args.task_id = task.id;\\n          if (feature && !('feature_id' in args)) args.feature_id = feature.id;\\n          const result = await Promise.resolve(availableTools[toolName](args));\\n          toolOutputs.push({ name: toolName, result });\\n        } else {\\n          toolOutputs.push({ name: toolName, result: `Error: Tool '${toolName}' not found.` });\\n        }\\n\\n        // Termination tools mirror Python; do not append a tool result turn, final message is assistant\\n        if (['finish_feature', 'block_feature', 'finish_spec', 'block_task'].includes(toolName)) {\\n          doEmit({ type: 'llm/messages/final', payload: { messages: messages.slice(), featureId: featureKey, tool: toolName } });\\n          complete(toolName === 'block_feature' || toolName === 'block_task' ? 'block' : 'finish');\\n          return;\\n        }\\n      }\\n\\n      // Append tool results as a dedicated 'user' role message to avoid confusing with user turns\\n      const toolResultMsg: CompletionMessage = annotateMessage(\\n        { role: 'user', content: JSON.stringify(toolOutputs) } as any,\\n        { featureId: featureKey, agentType, turn: i, source: 'tools' }\\n      );\\n      messages.push(toolResultMsg);\\n      doEmit({ type: 'llm/message', payload: { message: toolResultMsg, featureId: featureKey, turn: i, source: 'tools' } });\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i, note: 'tools_appended' } });\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} tool calls processed` } });\\n    } catch (e) {\\n      if (feature) {\\n        await toolFunctions.blockFeature(task.id, feature.id, `Agent loop failed: ${e}`, agentType, git);\\n      } else {\\n        await toolFunctions.blockTask(task.id, `Agent loop failed: ${e}`, agentType, git);\\n      }\\n      doEmit({ type: 'llm/messages/error', payload: { error: String(e), messages: messages.slice(), featureId: featureKey } });\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: undefined, message: 'Error encountered' } });\\n      logger.error('Agent loop error:', e as any);\\n      complete('block', e);\\n      return;\\n    }\\n  }\\n\\n  // Max turns reached -> block\\n  if (feature) {\\n    await toolFunctions.blockFeature(task.id, feature.id, 'Agent loop exceeded max turns', agentType, git);\\n  } else {\\n    await toolFunctions.blockTask(task.id, 'Agent loop exceeded max turns', agentType, git);\\n  }\\n  doEmit({ type: 'llm/messages/final', payload: { messages: [{ role: 'system', content: systemPrompt }] as CompletionMessage[], featureId: featureKey, reason: 'max_turns' } });\\n  doEmit({ type: 'run/progress/snapshot', payload: { progress: 1, message: 'Max turns reached' } });\\n  logger.warn('Max turns reached without completion.');\\n  complete('max_turns');\\n}\\n\\nasync function runAgentOnTask(model: string, agentType: AgentType, task: Task, toolFunctions: Tools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\n  logger.debug(`\\\\n--- Activating Agent ${agentType} for task: [${task.id}] ${task.title} ---`);\\n  const agentDocs = getAgentFile(agentType);\\n  const contextFiles = ['docs/FILE_ORGANISATION.md'];\\n  const [funcs, sigs] = toolSigsForAgent(agentType, toolFunctions, git);\\n  const context = await Promise.resolve(toolFunctions.readFiles(contextFiles));\\n  const systemPrompt = constructSystemPrompt(agentType, task, null, agentDocs, context, sigs);\\n\\n  // Maintain grouped structure for task-level chat\\n  const groups: Record<string, FeatureMessagesGroup> = {};\\n  const fid = '__task__';\\n  ensureGroup(groups, fid);\\n\\n  await runConversation({\\n    model,\\n    availableTools: funcs,\\n    systemPrompt,\\n    task,\\n    feature: null,\\n    agentType,\\n    toolFunctions,\\n    git,\\n    completion,\\n    complete: () => {},\\n    emit: (e) => {\\n      // Pass-through event, but attach grouped messages snapshot when available\\n      try {\\n        if (e?.payload?.messages && Array.isArray(e.payload.messages)) {\\n          // Update group messages with annotated copies\\n          const msgs = (e.payload.messages as CompletionMessage[]).map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? fid, agentType, turn: (m as any).turn ?? idx }));\\n          groups[fid].messages = msgs;\\n          if (e.type === 'llm/messages/final') groups[fid].endDate = new Date().toISOString();\\n          emit?.({ ...e, payload: { ...e.payload, messageGroups: { ...groups }, featureId: fid } });\\n          return;\\n        }\\n      } catch {}\\n      emit?.(e);\\n    },\\n  });\\n}\\n\\nasync function runAgentOnFeature(model: string, agentType: AgentType, task: Task, feature: Feature, toolFunctions: Tools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\n  logger.debug(`\\\\n--- Activating Agent ${agentType} for Feature: [${feature.id}] ${feature.title} ---`);\\n\\n  if (agentType === 'developer') await toolFunctions.updateFeatureStatus(task.id, feature.id, '~');\\n\\n  const agentDocs = getAgentFile(agentType);\\n  const featureContextFiles = ['docs/FILE_ORGANISATION.md', ...(feature.context ?? [])];\\n  const [funcs, sigs] = toolSigsForAgent(agentType, toolFunctions, git);\\n  const context = await Promise.resolve(toolFunctions.readFiles(featureContextFiles));\\n  const systemPrompt = constructSystemPrompt(agentType, task, feature, agentDocs, context, sigs);\\n\\n  if (agentType === 'developer') await toolFunctions.updateFeatureStatus(task.id, feature.id, '~');\\n\\n  await runConversation({\\n    model,\\n    availableTools: funcs,\\n    systemPrompt,\\n    task,\\n    feature,\\n    agentType,\\n    toolFunctions,\\n    git,\\n    completion,\\n    complete: () => {},\\n    emit,\\n  });\\n}\\n\\nasync function runOrchestrator(opts: {\\n  model: string;\\n  agentType: AgentType;\\n  taskId: string; \\n  featureId?: string; \\n  tools: Tools;\\n  git: GitManager;\\n  completion: CompletionClient;\\n  emit?: (e: { type: string; payload?: any }) => void;\\n}) {\\n  const { model, agentType, taskId, tools, git, completion, emit } = opts;\\n\\n  const currentTask: Task = await tools.getTask(taskId);\\n  if (!currentTask) {\\n    logger.warn('No available tasks to work on in the repository.');\\n    return;\\n  }\\n\\n  logger.debug(`Selected Task: [${currentTask.id}] ${currentTask.title}`);\\n\\n  const branch = `features/${currentTask.id}`;\\n  try {\\n    await git.checkoutBranch(branch, true);\\n  } catch (e) {\\n    logger.warn(`Could not create or checkout branch '${branch}': ${e}`);\\n    await git.checkoutBranch(branch, false);\\n  }\\n  try {\\n    await git.pull(branch);\\n  } catch (e) {\\n    logger.warn(`Could not pull branch '${branch}': ${e}`);\\n  }\\n\\n  const processed = new Set<string>();\\n\\n  // Aggregate all messages across features for this run\\n  let aggregatedMessages: CompletionMessage[] = [];\\n  const aggregatedGroups: Record<string, FeatureMessagesGroup> = {};\\n\\n  if (agentType === 'speccer') {\\n    const freshTask = await tools.getTask(currentTask.id);\\n    await runAgentOnTask(model, agentType, freshTask, tools, git, completion, (e) => {\\n      // For task-level runs, forward events and add grouped snapshot for persistence\\n      if (e?.payload?.messages) {\\n        const msgs = e.payload.messages as CompletionMessage[];\\n        const fid = '__task__';\\n        const annotated = msgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? fid, agentType, turn: (m as any).turn ?? idx }));\\n        aggregatedMessages = annotated.slice();\\n        const group = ensureGroup(aggregatedGroups, fid);\\n        group.messages = annotated.slice();\\n        if (e.type === 'llm/messages/final') group.endDate = new Date().toISOString();\\n        emit?.({ ...e, payload: { ...e.payload, featureId: fid, messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups } } });\\n      } else {\\n        emit?.(e);\\n      }\\n    });\\n    return;\\n  }\\n\\n  while (true) {\\n    const freshTask = await tools.getTask(currentTask.id);\\n    const next = findNextAvailableFeature(freshTask, processed, agentType !== 'developer');\\n    if (!next) {\\n      logger.debug(`\\\\nNo more available features for task ${freshTask.id}.`);\\n      break;\\n    }\\n\\n    // Ensure a group exists for this feature\\n    ensureGroup(aggregatedGroups, next.id);\\n\\n    // Insert a system marker before each feature to clearly separate in UI and history (flat array only)\\n    const featureMarker: CompletionMessage = annotateMessage(\\n      { role: 'system', content: `--- BEGIN FEATURE ${next.id}: ${next.title} ---` } as any,\\n      { featureId: next.id, agentType, marker: 'feature_begin' }\\n    );\\n    aggregatedMessages.push(featureMarker);\\n    emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'feature_begin', featureId: next.id } });\\n\\n    // Wrap emit to merge current feature's messages with the aggregate so far\\n    let lastFeatureMessages: CompletionMessage[] = [];\\n    const baseEmit = emit;\\n    const wrappedEmit = (e: { type: string; payload?: any }) => {\\n      const t = e?.type;\\n      if ((t === 'llm/messages/init' || t === 'llm/messages/snapshot' || t === 'llm/messages/final') && e?.payload?.messages) {\\n        try {\\n          const featureMsgs: CompletionMessage[] = e.payload.messages || [];\\n          // Ensure every message is tagged with this feature id and agentType for persistence\\n          const ensured = featureMsgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? next.id, agentType, turn: (m as any).turn ?? idx }));\\n          lastFeatureMessages = ensured.slice();\\n          // Update groups\\n          const g = ensureGroup(aggregatedGroups, next.id);\\n          g.messages = ensured.slice();\\n          if (t === 'llm/messages/final') g.endDate = new Date().toISOString();\\n          // Update flat aggregate for readability (kept for backward compatibility)\\n          const combined = aggregatedMessages.concat(ensured);\\n          const payload = { ...e.payload, featureId: next.id, messages: combined, messageGroups: { ...aggregatedGroups } };\\n          baseEmit?.({ ...e, payload });\\n          return;\\n        } catch {}\\n      }\\n      baseEmit?.(e);\\n    };\\n\\n    await runAgentOnFeature(model, agentType, freshTask, next, tools, git, completion, wrappedEmit);\\n\\n    // After the feature completes, fold its messages into the aggregate\\n    if (lastFeatureMessages && lastFeatureMessages.length) {\\n      aggregatedMessages = aggregatedMessages.concat(lastFeatureMessages);\\n      // Emit a snapshot to persist the full sequence after folding\\n      emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'feature_folded', featureId: next.id } });\\n    }\\n\\n    processed.add(next.id);\\n  }\\n\\n  // Emit final snapshot at end of task run with complete sequence of feature conversations\\n  emit?.({ type: 'llm/messages/final', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'task_run_complete' } });\\n}\\n\\n// --- Isolated Runner (mimic Python run.py) ---\\n\\nfunction shouldIgnoreCopy(relPath: string): boolean {\\n  // Ignore common build, cache, and IDE artifacts for TypeScript/Node/Electron projects\\n  // Preserve .git (do NOT ignore)\\n  const parts = relPath.split(path.sep);\\n  const name = parts[parts.length - 1] || relPath;\\n\\n  // If path is within .git, do not ignore (preserve repo history/branches)\\n  if (parts.includes('.git')) return false;\\n\\n  const dirIgnore = new Set([\\n    // Package managers and caches\\n    'node_modules', '.pnpm', '.pnp', '.pnp.cjs', '.pnp.js', '.npm', '.yarn', '.yarn-cache', '.yarnrc',\\n    // Build/output directories\\n    'dist', 'build', 'out', 'release', 'storybook-static',\\n    // Framework-specific\\n    '.next', 'next', '.nuxt', '.svelte-kit',\\n    // Bundlers and dev servers caches\\n    '.vite', '.rollup.cache', '.parcel-cache', '.webpack',\\n    // Test/coverage\\n    'coverage', '.nyc_output',\\n    // Monorepo/turbo caches\\n    '.turbo',\\n    // Generic caches\\n    '.cache', '.eslintcache', '.rpt2_cache', '.tscache',\\n    // Editors/IDE\\n    '.idea', '.vscode',\\n    // Python (from original mirror)\\n    'venv', '__pycache__',\\n    // Logs and temp\\n    'logs', 'tmp', 'temp'\\n  ]);\\n\\n  // If any path segment matches an ignored dir name\\n  if (parts.some(p => dirIgnore.has(p))) return true;\\n\\n  // Ignore specific file patterns\\n  const lower = name.toLowerCase();\\n  if (lower === '.ds_Store'.toLowerCase() || lower === 'thumbs.db') return true;\\n  if (lower.endsWith('.log')) return true; // npm/yarn/pnpm debug logs\\n  if (lower.endsWith('.pyc')) return true; // Python bytecode files\\n  if (lower.endsWith('.tsbuildinfo')) return true; // TypeScript incremental build info\\n\\n  // Ignore Electron asar content markers when encountered as path segments\\n  if (parts.some(p => p.endsWith('.asar') || p.endsWith('.asar.unpacked'))) return true;\\n\\n  return false;\\n}\\n\\nasync function copyTree(src: string, dest: string) {\\n  // Recursively copy, respecting ignore patterns and skipping asar/virtual entries\\n  let stat: fs.Stats;\\n  try {\\n    stat = await fsp.stat(src);\\n  } catch (e: any) {\\n    throw new Error(`Source path does not exist or is not accessible: ${src} (${e?.code || e})`);\\n    }\\n  if (!stat.isDirectory()) throw new Error(`Source ${src} is not a directory`);\\n  await fsp.mkdir(dest, { recursive: true });\\n\\n  const walk = async (from: string, to: string) => {\\n    let entries: fs.Dirent[] = [] as unknown as fs.Dirent[];\\n    try {\\n      entries = await fsp.readdir(from, { withFileTypes: true });\\n    } catch (e: any) {\\n      // Skip unreadable directories (e.g., asar virtuals)\\n      logger.warn(`copyTree: Skipping unreadable directory ${from}: ${e?.code || e}`);\\n      return;\\n    }\\n    for (const entry of entries) {\\n      const rel = path.relative(src, path.join(from, entry.name));\\n      if (shouldIgnoreCopy(rel)) continue;\\n      const srcPath = path.join(from, entry.name);\\n      const dstPath = path.join(to, entry.name);\\n\\n      // Skip any path that traverses into an asar archive\\n      if (srcPath.includes('.asar')) continue;\\n\\n      try {\\n        if (entry.isDirectory()) {\\n          await fsp.mkdir(dstPath, { recursive: true });\\n          await walk(srcPath, dstPath);\\n        } else if (entry.isSymbolicLink()) {\\n          // Resolve symlink target and copy contents (best-effort)\\n          try {\\n            const linkTarget = await fsp.readlink(srcPath);\\n            const resolved = path.resolve(path.dirname(srcPath), linkTarget);\\n            const st = await fsp.stat(resolved);\\n            if (st.isDirectory()) {\\n              await fsp.mkdir(dstPath, { recursive: true });\\n              await walk(resolved, dstPath);\\n            } else {\\n              await fsp.copyFile(resolved, dstPath);\\n            }\\n          } catch {\\n            // Fallback: copy file bytes of the link itself (as file)\\n            try { await fsp.copyFile(srcPath, dstPath); } catch {}\\n          }\\n        } else if (entry.isFile()) {\\n          await fsp.copyFile(srcPath, dstPath);\\n        }\\n      } catch (e: any) {\\n        // Skip problematic entries (e.g., ENOENT due to virtualized packaging paths)\\n        if (e && (e.code === 'ENOENT' || e.code === 'EBUSY' || e.code === 'EPERM')) {\\n          logger.warn(`copyTree: Skipping ${srcPath}: ${e.code}`);\\n          continue;\\n        }\\n        throw e;\\n      }\\n    }\\n  };\\n\\n  await walk(src, dest);\\n}\\n\\nexport async function runIsolatedOrchestrator(opts: {\\n  model: string;\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\n  projectId: string; \\n  taskId: string;\\n  featureId?: string; \\n  webSearchApiKeys?: WebSearchApiKeys;\\n  gitFactory: (projectRoot: string) => GitManager;  // git bound to projectRoot\\n  completion: CompletionClient;\\n  emit?: (e: { type: string; payload?: any }) => void;\\n}) {\\n  const { model, agentType, projectId, taskId, featureId, webSearchApiKeys, gitFactory, completion, emit } = opts;\\n\\n\\n  // Create temp workspace\\n  const tmpBase = fs.mkdtempSync(path.join(os.tmpdir(), 'thefactory-tools-'));\\n  // Keep a subfolder to host the copied source\\n  const workspace = path.join(tmpBase, 'workspace');\\n\\n  const projectTools = createTools(process.cwd(), webSearchApiKeys);\\n  const projectDir = await projectTools.getProjectDir(projectId);\\n\\n  logger.info(`Copying repository from '${projectDir}' to temporary workspace: '${workspace}'`);\\n  try {\\n    await copyTree(projectDir, workspace);\\n  } catch (e) {\\n    logger.error(`FATAL: Failed to copy repository to temporary directory from '${projectDir}' -> '${workspace}': ${e}`);\\n    // best-effort cleanup\\n    try { fs.rmSync(tmpBase, { recursive: true, force: true }); } catch {}\\n    return;\\n  }\\n\\n  const git = gitFactory(workspace);\\n  const tools = createTools(workspace, webSearchApiKeys);\\n\\n  try {\\n    await runOrchestrator({\\n      model,\\n      agentType,\\n      taskId,\\n      featureId,\\n      tools,\\n      git,\\n      completion,\\n      emit,\\n    });\\n  } catch (e) {\\n    logger.error(`An error occurred while running the agent orchestrator: ${e}`);\\n  } finally {\\n    // Cleanup temporary directory\\n    try {\\n      fs.rmSync(tmpBase, { recursive: true, force: true });\\n      logger.info('Agent run finished. Temporary directory cleaned up.');\\n    } catch (e) {\\n      logger.warn(`Failed to cleanup temporary directory '${tmpBase}': ${e}`);\\n    }\\n  }\\n}\\n\"}\n\nBegin now.",
        "featureId": "753f6df3-59a8-4fe0-972b-1dae53c20a15",
        "agentType": "developer",
        "turn": 0,
        "source": "initial",
        "createdAt": "2025-09-09T18:00:16.121Z"
      },
      {
        "role": "assistant",
        "content": "{\"thoughts\":\"The user wants to add `githubCredentials` to the main entry point of the orchestrator, similar to how `webSearchApiKeys` are handled. The goal is to use these credentials for all git operations instead of relying on environment variables.\\n\\nThe main entry point seems to be `runIsolatedOrchestrator` in `src/orchestrator.ts`. I need to:\\n\\n1.  **Define `GithubCredentials` type**: I'll look at `src/types.ts` to see how `WebSearchApiKeys` is defined and add a similar type for `GithubCredentials`. I will assume it is a string for now, representing a token.\\n2.  **Update `runIsolatedOrchestrator`**: I'll modify the function signature in `src/orchestrator.ts` to accept the new `githubCredentials` parameter.\\n3.  **Update `gitFactory`**: The `gitFactory` function is used to create a `GitManager` instance. I need to update its signature to accept `githubCredentials` and then pass them when it's called inside `runIsolatedOrchestrator`.\\n\\nI will start by reading `src/types.ts` and `src/gitManager.ts` to get more context on how to implement this.\",\"tool_calls\":[{\"tool_name\":\"read_files\",\"arguments\":{\"paths\":[\"src/types.ts\",\"src/gitManager.ts\"]}}]}",
        "featureId": "753f6df3-59a8-4fe0-972b-1dae53c20a15",
        "agentType": "developer",
        "turn": 0,
        "askedAt": "2025-09-09T17:58:03.827Z",
        "createdAt": "2025-09-09T18:00:16.121Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"read_files\",\"result\":\"{\\\"src/types.ts\\\":\\\"export type Status = '+' | '-' | '~' | '?' | '=';\\\\nexport interface Feature {\\\\n  id: string;\\\\n  status: Status;\\\\n  title: string;\\\\n  description: string;\\\\n  context: string[];\\\\n  plan?: string;\\\\n  acceptance?: string;\\\\n  blockers?: string[];\\\\n  rejection?: string;\\\\n}\\\\nexport interface Task {\\\\n  id: string;\\\\n  title: string;\\\\n  description: string;\\\\n  status: Status;\\\\n  features: Feature[];\\\\n  featureIdToDisplayIndex: Record<string, number>;\\\\n  blockers?: string[];\\\\n  rejection?: string;\\\\n}\\\\nexport interface ProjectRequirement {\\\\n  id: number;\\\\n  status: Status;\\\\n  description: string;\\\\n  tasks: string[];\\\\n}\\\\nexport interface ProjectSpec {\\\\n  id: string;\\\\n  title: string;\\\\n  description: string;\\\\n  path: string;\\\\n  repo_url: string;\\\\n  requirements: ProjectRequirement[];\\\\n  taskIdToDisplayIndex: Record<string, number>;\\\\n  metadata?: Record<string,any>;\\\\n}\\\\nexport type CompletionMessageRole = 'system' | 'user' | 'assistant';\\\\nexport type CompletionMessage = { role: CompletionMessageRole; content: string };\\\\nexport type CompletionUsage = {\\\\n  promptTokens?: number;\\\\n  completionTokens?: number;\\\\n  totalTokens?: number;\\\\n  costUSD?: number;\\\\n  provider?: string;\\\\n  model?: string;\\\\n};\\\\nexport type CompletionResponse = { message: { role: 'assistant'; content: string }; usage?: CompletionUsage };\\\\nexport type CompletionClient = (req: { model: string; messages: CompletionMessage[]; response_format?: any }) => Promise<CompletionResponse>;\\\\nexport type ToolCall = { tool_name: string; arguments?: any;};\\\\nexport type MatchToolCall = { tool_name?: string; tool?: string; name?: string; arguments?: any; args?: any; parameters?: any; params?: any };\\\\nexport type ToolResult = { name: string; result: string };\\\\nexport type AgentResponse = { thoughts?: string; tool_calls?: ToolCall[] };\\\\nexport type MatchAgentResponse = { thoughts?: string; tool_calls?: ToolCall[]; tools?: ToolCall[]; calls?: ToolCall[]; };\\\\n\\\\nexport type LLMConfig = {\\\\n  model: string;\\\\n  provider: string; // e.g., openai, azure, together, groq, openrouter, ollama, custom\\\\n  apiKey: string;\\\\n  apiBaseUrl: string;\\\\n\\\\n  // extra provider fields (azure etc.) tolerated\\\\n  [key: string]: any;\\\\n};\\\\n\\\\nexport type AgentType = 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\\\nexport type AgentRun = {\\\\n  agent: AgentType;\\\\n  projectId: string;\\\\n  taskId: string;\\\\n  featureId?: string;\\\\n  llmConfig: LLMConfig;\\\\n  webSearchApiKeys?: WebSearchApiKeys;\\\\n  options?: {\\\\n    budgetUSD?: number;\\\\n    metadata?: Record<string, any>;\\\\n  }\\\\n};\\\\nexport type RunEvent = { type: string; payload?: any };\\\\n\\\\n\\\\nexport type WebSearchApiKeys = Record<string,string>\\\\nexport type WebSearchProvider = 'exa' | 'tavily' | 'serpapi'\\\\n\\\\nexport interface WebSearchQueryOptions {\\\\n  query: string\\\\n  limit?: number\\\\n}\\\\nexport interface WebSearchOptions extends WebSearchQueryOptions {\\\\n  providers?: WebSearchProvider[]\\\\n}\\\\n\\\\nexport interface WebSearchResultItem {\\\\n  title: string\\\\n  url: string\\\\n  snippet?: string\\\\n  // Optional provider-specific fields for extensibility\\\\n  [key: string]: any\\\\n}\\\\n\\\\nexport interface WebSearchResponse {\\\\n  provider: WebSearchProvider\\\\n  query: string\\\\n  items: WebSearchResultItem[]\\\\n  raw?: any\\\\n}\\\",\\\"src/gitManager.ts\\\":\\\"import { execFile } from 'node:child_process';\\\\nimport path from 'node:path';\\\\nimport fs from 'node:fs';\\\\n\\\\n// Best-effort dotenv loader that reads a .env from repoPath (and optionally its parent)\\\\nfunction loadDotenv(repoPath: string) {\\\\n  try {\\\\n    // Lazy require dotenv to avoid bundling if not needed\\\\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\\\\n    const dotenv = require('dotenv') as typeof import('dotenv');\\\\n    const candidates = [\\\\n      path.join(repoPath, '.env'),\\\\n      path.join(path.dirname(repoPath), '.env'),\\\\n    ];\\\\n    for (const file of candidates) {\\\\n      if (fs.existsSync(file)) {\\\\n        dotenv.config({ path: file });\\\\n        break; // first match wins\\\\n      }\\\\n    }\\\\n  } catch {\\\\n    // If dotenv isn't available or fails, ignore silently\\\\n  }\\\\n}\\\\n\\\\nfunction runGit(cwd: string, args: string[]): Promise<string> {\\\\n  return new Promise((resolve, reject) => {\\\\n    execFile('git', args, { cwd }, (error, stdout, stderr) => {\\\\n      if (error) {\\\\n        const err = new Error(`Git command failed: git ${args.join(' ')}\\\\\\\\nStderr: ${stderr || error.message}`);\\\\n        // @ts-ignore attach code for debugging\\\\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\\\\n        (err as any).stderr = stderr;\\\\n        reject(err);\\\\n        return;\\\\n      }\\\\n      resolve(String(stdout || '').trim());\\\\n    });\\\\n  });\\\\n}\\\\n\\\\nfunction getEnv(name: string): string | undefined {\\\\n  const v = process.env[name];\\\\n  return v && v.length ? v : undefined;\\\\n}\\\\n\\\\nasync function safeRunGit(cwd: string, args: string[]): Promise<string | undefined> {\\\\n  try {\\\\n    return await runGit(cwd, args);\\\\n  } catch {\\\\n    return undefined;\\\\n  }\\\\n}\\\\n\\\\nasync function getCurrentBranch(cwd: string): Promise<string | undefined> {\\\\n  // Try symbolic-ref first (fast), fallback to rev-parse\\\\n  const ref = await safeRunGit(cwd, ['symbolic-ref', '--short', 'HEAD']);\\\\n  if (ref) return ref;\\\\n  return await safeRunGit(cwd, ['rev-parse', '--abbrev-ref', 'HEAD']);\\\\n}\\\\n\\\\nasync function hasRemote(cwd: string, name: string): Promise<boolean> {\\\\n  const remotes = await safeRunGit(cwd, ['remote']);\\\\n  return !!remotes && remotes.split(/\\\\\\\\r?\\\\\\\\n/).some(r => r.trim() === name);\\\\n}\\\\n\\\\nasync function getRemoteUrl(cwd: string, name: string): Promise<string | undefined> {\\\\n  return await safeRunGit(cwd, ['remote', 'get-url', name]);\\\\n}\\\\n\\\\nfunction normalizeCreds() {\\\\n  // Accept multiple token/user env var options\\\\n  const repoUrl = getEnv('GIT_REPO_URL') || getEnv('REPOSITORY_URL') || getEnv('REPO_URL');\\\\n  const username = getEnv('GIT_USER_NAME') || getEnv('GIT_USERNAME') || getEnv('GITHUB_USERNAME');\\\\n  const token = getEnv('GIT_PAT') || getEnv('GIT_TOKEN') || getEnv('GITHUB_TOKEN') || getEnv('GH_TOKEN');\\\\n  const email = getEnv('GIT_USER_EMAIL') || getEnv('GIT_EMAIL') || getEnv('GITHUB_EMAIL');\\\\n  return { repoUrl, username, token, email };\\\\n}\\\\n\\\\nfunction buildHttpsUrlWithToken(repoUrl: string, username: string, token: string): string {\\\\n  try {\\\\n    const url = new URL(repoUrl);\\\\n    // Only inject credentials for https protocol\\\\n    if (!/^https?:$/.test(url.protocol)) return repoUrl;\\\\n    return `${url.protocol}//${encodeURIComponent(username)}:${encodeURIComponent(token)}@${url.host}${url.pathname}`;\\\\n  } catch {\\\\n    return repoUrl;\\\\n  }\\\\n}\\\\n\\\\nfunction httpsToSsh(repoUrl: string): string | undefined {\\\\n  try {\\\\n    const url = new URL(repoUrl);\\\\n    if (url.protocol.startsWith('http')) {\\\\n      const pathname = url.pathname.replace(/^\\\\\\\\//, '');\\\\n      return `git@${url.host}:${pathname}`;\\\\n    }\\\\n  } catch {\\\\n    // ignore\\\\n  }\\\\n  return undefined;\\\\n}\\\\n\\\\nexport class GitManager {\\\\n  private repoPath: string;\\\\n  private branchName?: string;\\\\n\\\\n  constructor(repoPath: string, branchName?: string) {\\\\n    this.repoPath = path.resolve(repoPath);\\\\n    this.branchName = branchName;\\\\n\\\\n    // Load .env from repo to populate process.env if the host hasn't loaded it.\\\\n    loadDotenv(this.repoPath);\\\\n\\\\n    const { username, email } = normalizeCreds();\\\\n    const userName = username || getEnv('GIT_USER_NAME');\\\\n    const userEmail = email || getEnv('GIT_USER_EMAIL');\\\\n    if (!userName || !userEmail) {\\\\n      // Warn but do not throw. Users may rely on global git config or credential managers.\\\\n      console.error('WARNING: Git user.name and/or user.email not provided via env. Falling back to git global config.');\\\\n    } else {\\\\n      // Best-effort configure\\\\n      safeRunGit(this.repoPath, ['config', 'user.name', userName]);\\\\n      safeRunGit(this.repoPath, ['config', 'user.email', userEmail]);\\\\n    }\\\\n  }\\\\n\\\\n  async checkoutBranch(name: string, create: boolean = true): Promise<void> {\\\\n    if (create) {\\\\n      await runGit(this.repoPath, ['checkout', '-b', name]);\\\\n    } else {\\\\n      await runGit(this.repoPath, ['checkout', name]);\\\\n    }\\\\n    this.branchName = name;\\\\n  }\\\\n\\\\n  async pull(name?: string): Promise<void> {\\\\n    const branch = name || this.branchName || (await getCurrentBranch(this.repoPath)) || '';\\\\n    const hasOrigin = await hasRemote(this.repoPath, 'origin');\\\\n    if (!hasOrigin) return; // Nothing to pull from\\\\n    await runGit(this.repoPath, ['pull', 'origin', branch]);\\\\n  }\\\\n\\\\n  async stageAll(): Promise<void> {\\\\n    await runGit(this.repoPath, ['add', '-A']);\\\\n  }\\\\n\\\\n  async commit(message: string): Promise<void> {\\\\n    // Commit only if there is something to commit\\\\n    const status = await runGit(this.repoPath, ['status', '--porcelain']);\\\\n    if (!status) return; // nothing to commit\\\\n    await runGit(this.repoPath, ['commit', '-m', message]);\\\\n  }\\\\n\\\\n  async push(): Promise<void> {\\\\n    // Determine branch\\\\n    const branch = this.branchName || (await getCurrentBranch(this.repoPath));\\\\n\\\\n    // Ensure .env is loaded before checking env vars (in case push() is called later)\\\\n    loadDotenv(this.repoPath);\\\\n    const { repoUrl, username, token } = normalizeCreds();\\\\n\\\\n    // If there is no origin remote, attempt to set one from env if available; otherwise, skip with informative error\\\\n    const originExists = await hasRemote(this.repoPath, 'origin');\\\\n\\\\n    // If an origin remote exists, try a plain push first. This supports SSH remotes and credential managers.\\\\n    if (originExists) {\\\\n      try {\\\\n        await runGit(this.repoPath, ['push', '-u', 'origin', branch || '']);\\\\n        return;\\\\n      } catch (err) {\\\\n        // If push failed, attempt a staged fallback strategy\\\\n        // 1) If we have HTTPS repo URL and token creds, try embedding credentials.\\\\n        if (repoUrl && username && token) {\\\\n          try {\\\\n            const authenticatedUrl = buildHttpsUrlWithToken(repoUrl, username, token);\\\\n            await runGit(this.repoPath, ['remote', 'set-url', 'origin', authenticatedUrl]);\\\\n            await runGit(this.repoPath, ['push', '-u', 'origin', branch || '']);\\\\n            return;\\\\n          } catch (err2) {\\\\n            // 2) If https failed, and the remote is https, try converting to SSH and pushing (SSH agent may be available)\\\\n            try {\\\\n              const sshUrl = httpsToSsh(repoUrl || (await getRemoteUrl(this.repoPath, 'origin')) || '');\\\\n              if (sshUrl) {\\\\n                await runGit(this.repoPath, ['remote', 'set-url', 'origin', sshUrl]);\\\\n                await runGit(this.repoPath, ['push', '-u', 'origin', branch || '']);\\\\n                return;\\\\n              }\\\\n            } catch {\\\\n              // ignore\\\\n            }\\\\n            // rethrow deepest err\\\\n            throw err2;\\\\n          }\\\\n        }\\\\n        // 2) Without creds, if current origin is https, try switching to SSH (if possible)\\\\n        try {\\\\n          const currentUrl = await getRemoteUrl(this.repoPath, 'origin');\\\\n          const sshUrl = currentUrl ? httpsToSsh(currentUrl) : undefined;\\\\n          if (sshUrl) {\\\\n            await runGit(this.repoPath, ['remote', 'set-url', 'origin', sshUrl]);\\\\n            await runGit(this.repoPath, ['push', '-u', 'origin', branch || '']);\\\\n            return;\\\\n          }\\\\n        } catch {\\\\n          // ignore\\\\n        }\\\\n\\\\n        // No credentials in env and no SSH fallback worked: rethrow with a friendlier message\\\\n        const e = new Error(\\\\n          'Git push failed. Ensure your repository has a valid remote and authentication (SSH agent, credential manager, or set GIT_REPO_URL + GIT_USER_NAME + GIT_PAT / GIT_TOKEN / GITHUB_TOKEN in .env).\\\\\\\\n' +\\\\n            `Details: ${(err as Error).message}`\\\\n        );\\\\n        throw e;\\\\n      }\\\\n    }\\\\n\\\\n    // No origin remote configured. If we have env settings, configure and push; otherwise, provide a helpful error.\\\\n    if (repoUrl && username && token) {\\\\n      const authenticatedUrl = buildHttpsUrlWithToken(repoUrl, username, token);\\\\n      await runGit(this.repoPath, ['remote', 'add', 'origin', authenticatedUrl]);\\\\n      await runGit(this.repoPath, ['push', '-u', 'origin', branch || '']);\\\\n      return;\\\\n    }\\\\n\\\\n    // If repoUrl exists but token missing, try adding SSH origin from https URL\\\\n    if (repoUrl) {\\\\n      const sshUrl = httpsToSsh(repoUrl);\\\\n      if (sshUrl) {\\\\n        await runGit(this.repoPath, ['remote', 'add', 'origin', sshUrl]);\\\\n        try {\\\\n          await runGit(this.repoPath, ['push', '-u', 'origin', branch || '']);\\\\n          return;\\\\n        } catch {\\\\n          // fall-through to error below\\\\n        }\\\\n      }\\\\n    }\\\\n\\\\n    throw new Error(\\\\n      'No Git remote \\\\\\\"origin\\\\\\\" found and no usable credentials provided. Configure a remote (e.g., SSH) or set GIT_REPO_URL along with GIT_USER_NAME and a token (GIT_PAT/GIT_TOKEN/GITHUB_TOKEN) in a .env at the repo root to enable push operations.'\\\\n    );\\\\n  }\\\\n  \\\\n  async pushAll(message: string)\\\\n  {\\\\n    try { await this.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    try { await this.commit(message); console.log(`Committed changes with message: '${message}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await this.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n    console.log(message);\\\\n  }\\\\n}\\\\n\\\\nexport default GitManager;\\\\n\\\"}\"}]",
        "featureId": "753f6df3-59a8-4fe0-972b-1dae53c20a15",
        "agentType": "developer",
        "turn": 0,
        "source": "tools",
        "createdAt": "2025-09-09T18:00:16.121Z"
      },
      {
        "role": "assistant",
        "content": "{\"thoughts\":\"The user wants to pass `githubCredentials` to the `runIsolatedOrchestrator` function, similar to `webSearchApiKeys`, so that git operations can be authenticated without relying on environment variables. This involves updating type definitions, the `GitManager` class to accept and use these credentials, and the orchestrator logic to handle passing them down.\\n\\nMy plan is as follows:\\n1.  **Update `src/types.ts`**: Define a new `GithubCredentials` type and add it as an optional property to the `AgentRun` type.\\n2.  **Update `src/orchestrator.ts`**: Modify the `runIsolatedOrchestrator` function signature to accept the new `githubCredentials` parameter. Update the type signature for `gitFactory` within the options object and pass the credentials when calling it.\\n\\nBased on my analysis, these two files are the only ones that need changes to fulfill the request. I will now proceed with modifying these files.\",\"tool_calls\":[{\"tool_name\":\"write_file\",\"arguments\":{\"filename\":\"src/types.ts\",\"content\":\"export type Status = '+' | '-' | '~' | '?' | '=';\\nexport interface Feature {\\n  id: string;\\n  status: Status;\\n  title: string;\\n  description: string;\\n  context: string[];\\n  plan?: string;\\n  acceptance?: string;\\n  blockers?: string[];\\n  rejection?: string;\\n}\\nexport interface Task {\\n  id: string;\\n  title: string;\\n  description: string;\\n  status: Status;\\n  features: Feature[];\\n  featureIdToDisplayIndex: Record<string, number>;\\n  blockers?: string[];\\n  rejection?: string;\\n}\\nexport interface ProjectRequirement {\\n  id: number;\\n  status: Status;\\n  description: string;\\n  tasks: string[];\\n}\\nexport interface ProjectSpec {\\n  id: string;\\n  title: string;\\n  description: string;\\n  path: string;\\n  repo_url: string;\\n  requirements: ProjectRequirement[];\\n  taskIdToDisplayIndex: Record<string, number>;\\n  metadata?: Record<string,any>;\\n}\\nexport type CompletionMessageRole = 'system' | 'user' | 'assistant';\\nexport type CompletionMessage = { role: CompletionMessageRole; content: string };\\nexport type CompletionUsage = {\\n  promptTokens?: number;\\n  completionTokens?: number;\\n  totalTokens?: number;\\n  costUSD?: number;\\n  provider?: string;\\n  model?: string;\\n};\\nexport type CompletionResponse = { message: { role: 'assistant'; content: string }; usage?: CompletionUsage };\\nexport type CompletionClient = (req: { model: string; messages: CompletionMessage[]; response_format?: any }) => Promise<CompletionResponse>;\\nexport type ToolCall = { tool_name: string; arguments?: any;};\\nexport type MatchToolCall = { tool_name?: string; tool?: string; name?: string; arguments?: any; args?: any; parameters?: any; params?: any };\\nexport type ToolResult = { name: string; result: string };\\nexport type AgentResponse = { thoughts?: string; tool_calls?: ToolCall[] };\\nexport type MatchAgentResponse = { thoughts?: string; tool_calls?: ToolCall[]; tools?: ToolCall[]; calls?: ToolCall[]; };\\n\\nexport type LLMConfig = {\\n  model: string;\\n  provider: string; // e.g., openai, azure, together, groq, openrouter, ollama, custom\\n  apiKey: string;\\n  apiBaseUrl: string;\\n\\n  // extra provider fields (azure etc.) tolerated\\n  [key: string]: any;\\n};\\n\\nexport type AgentType = 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\nexport type AgentRun = {\\n  agent: AgentType;\\n  projectId: string;\\n  taskId: string;\\n  featureId?: string;\\n  llmConfig: LLMConfig;\\n  webSearchApiKeys?: WebSearchApiKeys;\\n  githubCredentials?: GithubCredentials;\\n  options?: {\\n    budgetUSD?: number;\\n    metadata?: Record<string, any>;\\n  }\\n};\\nexport type RunEvent = { type: string; payload?: any };\\n\\n\\nexport type WebSearchApiKeys = Record<string,string>\\nexport type WebSearchProvider = 'exa' | 'tavily' | 'serpapi'\\n\\nexport interface WebSearchQueryOptions {\\n  query: string\\n  limit?: number\\n}\\nexport interface WebSearchOptions extends WebSearchQueryOptions {\\n  providers?: WebSearchProvider[]\\n}\\n\\nexport interface WebSearchResultItem {\\n  title: string\\n  url: string\\n  snippet?: string\\n  // Optional provider-specific fields for extensibility\\n  [key: string]: any\\n}\\n\\nexport interface WebSearchResponse {\\n  provider: WebSearchProvider\\n  query: string\\n  items: WebSearchResultItem[]\\n  raw?: any\\n}\\n\\nexport type GithubCredentials = {\\n  repoUrl?: string;\\n  username?: string;\\n  token?: string;\\n  email?: string;\\n};\"}},{\"tool_name\":\"write_file\",\"arguments\":{\"filename\":\"src/orchestrator.ts\",\"content\":\"import fs from 'node:fs';\\nimport fsp from 'node:fs/promises';\\nimport path from 'node:path';\\nimport os from 'node:os';\\nimport { AgentResponse, AgentType, CompletionClient, CompletionMessage, Feature, GithubCredentials, MatchAgentResponse, MatchToolCall, Task, ToolCall, ToolResult, WebSearchApiKeys } from './types.js';\\nimport type { GitManager } from './gitManager';\\nimport { logger, logLLMStep } from './logger';\\nimport agent_response_example from '../docs/agent_response_example.json'\\nimport { getAgentFile, normalizeToolArguments, findNextAvailableFeature } from './utils';\\nimport { createTools, Tools } from './tools/tools';\\n\\nconst MAX_TURNS_PER_FEATURE = 100;\\n\\nconst NEWLINE = '\\\\n';\\n\\nconst PROTOCOL_INSTRUCTIONS = (() => {\\n  return [\\n    'You **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:',\\n    '```json',\\n    agent_response_example,\\n    '```',\\n    'The thoughts field is for your reasoning, and tool_calls is a list of actions to execute.',\\n    'Your response will be parsed as JSON. Do not include any text outside of this JSON object.',\\n    'As responses to the tool calls you will send, you will also receive JSON objects in the form:',\\n    '```json',\\n    '{\\\\n\\\"name\\\":\\\"tool_name\\\",\\\\n\\\"result\\\":\\\"...\\\"\\\\n}',\\n    '```',\\n  ].join('\\\\n');\\n})();\\n\\n// Human-readable descriptions for tools to avoid duplicating them in agent docs\\nconst TOOL_DESCRIPTIONS: Record<string, string> = {\\n  // Base tools\\n  read_files: 'Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).',\\n  search_files: 'Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords',\\n  list_files: 'List files and directories at a relative path from the project root.',\\n  finish_feature: 'Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.',\\n  block_feature: 'Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).',\\n\\n  // Speccer\\n  create_feature: 'Define and add a new, atomic feature to the task. Include a concise title and a clear description.',\\n  finish_spec: 'Signal that the feature specification is complete for the current task.',\\n  block_task: 'Stop work on the task and report why you are blocked at the task level.',\\n\\n  // Developer\\n  write_file: 'Create or overwrite a file with the given content. Always use this to write code or docs.',\\n  rename_file: 'Rename or move a file from one path to another.',\\n  delete_file: 'Delete a file. Use with caution and only when necessary.',\\n  run_test: 'Run the test for the current feature and return the output. Use to verify implementation.',\\n\\n  // Planner\\n  update_feature_plan: 'Save a concise, step-by-step implementation plan for the assigned feature.',\\n\\n  // Tester\\n  update_feature_acceptance: 'Save a clear, verifiable list of acceptance criteria for the assigned feature.',\\n  update_test: 'Save the Python test script that validates the acceptance criteria for this feature.',\\n\\n  // Contexter\\n  update_feature_context: 'Save the minimal set of file paths (relative to repo root) required to implement the feature.'\\n};\\n\\nfunction toolSigsForAgent(agent: string, tools: Tools, git: GitManager): [Record<string, (args: any) => Promise<any> | any>, string[]] {\\n  const base: Record<string, [(args: any) => Promise<any> | any, string]> = {\\n    read_files: [ (args: { paths: string[] }) => tools.readFiles(args.paths), \\\"read_files(paths: list[str]) -> list[str]\\\" ],\\n    search_files: [ (args: { query: string; path?: string }) => tools.searchFiles(args.query, args.path ?? '.'), \\\"search_files(query: str, path: str = '.') -> list[str]\\\" ],\\n    block_feature: [ (args: { task_id: string; feature_id: string; reason: string }) => tools.blockFeature?.(args.task_id, args.feature_id, args.reason, agent, git), 'block_feature(reason: str)' ],\\n    finish_feature: [ (args: { task_id: string; feature_id: string }) => tools.finishFeature?.(args.task_id, args.feature_id, agent, git), 'finish_feature()' ],\\n    list_files: [ (args: { path: string }) => tools.listFiles(args.path), 'list_files(path: str)' ],\\n  };\\n\\n  const agentTools: Record<string, [(args: any) => Promise<any> | any, string]> = {};\\n\\n  if (agent === 'speccer') {\\n    agentTools.create_feature = [ (args: { task_id: string; title: string; description: string }) => tools.createFeature(args.task_id, args.title, args.description), 'create_feature(title: str, description: str)' ];\\n    agentTools.finish_spec = [ (args: { task_id: string }) => tools.finishSpec(args.task_id, agent, git), 'finish_spec()' ];\\n    agentTools.block_task = [ (args: { task_id: string; reason: string }) => tools.blockTask(args.task_id, args.reason, agent, git), 'block_task()' ];\\n  } else if (agent === 'developer') {\\n    agentTools.write_file = [ (args: { filename: string; content: string }) => tools.writeFile(args.filename, args.content), 'write_file(filename: str, content: str)' ];\\n    agentTools.rename_file = [ (args: { filename: string; new_filename: string }) => tools.renameFile(args.filename, args.new_filename), 'rename_file(filename: str, new_filename: str)' ];\\n    agentTools.delete_file = [ (args: { filename: string }) => tools.deleteFile(args.filename), 'delete_file(filename: str)' ];\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => tools.runTest(args.task_id, args.feature_id), 'run_test() -> str' ];\\n  } else if (agent === 'planner') {\\n    agentTools.update_feature_plan = [ (args: { task_id: string; feature_id: string; plan: any }) => tools.updateFeaturePlan(args.task_id, args.feature_id, args.plan), 'update_feature_plan(plan: str)' ];\\n  } else if (agent === 'tester') {\\n    agentTools.update_feature_acceptance = [ (args: { task_id: string; feature_id: string; criteria: string }) => tools.updateFeatureAcceptance(args.task_id, args.feature_id, args.criteria), 'update_feature_acceptance(criteria: str)' ];\\n    agentTools.update_test = [ (args: { task_id: string; feature_id: string; test: string }) => tools.updateTest(args.task_id, args.feature_id, args.test), 'update_test(test: str)' ];\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => tools.runTest(args.task_id, args.feature_id), 'run_test() -> str' ];\\n  } else if (agent === 'contexter') {\\n    agentTools.update_feature_context = [ (args: { task_id: string; feature_id: string; context: string[] }) => tools.updateFeatureContext(args.task_id, args.feature_id, args.context), 'update_feature_context(context: list[str])' ];\\n  }\\n\\n  const merged = { ...base, ...agentTools };\\n  const funcs: Record<string, (args: any) => Promise<any> | any> = {};\\n  const sigs: string[] = [];\\n  for (const [name, [fn, sig]] of Object.entries(merged)) {\\n    if (fn) {\\n      funcs[name] = fn;\\n      const desc = TOOL_DESCRIPTIONS[name] ? ` - ${TOOL_DESCRIPTIONS[name]}` : '';\\n      sigs.push(`${sig}${desc}`);\\n    }\\n  }\\n  return [funcs, sigs];\\n}\\n\\nfunction constructSystemPrompt(agent: string, task: Task, feature: Feature | null, agentSystemPrompt: string, context: string, toolSignatures: string[]): string {\\n  const plan = feature && (agent === 'developer' || agent === 'tester' || agent === 'contexter' || agent === 'planner') ? feature.plan : undefined;\\n  const acceptance = feature && (agent === 'developer' || agent === 'tester') ? feature.acceptance : undefined\\n  const toolSignaturesStr = toolSignatures.map(sig => `- ${sig}`).join('\\\\n');\\n\\n  const featureBlock = feature ? `#ASSIGNED FEATURE: ${feature.title} (ID: ${feature.id})${NEWLINE}##DESCRIPTION: ${feature.description}${NEWLINE}` : '';\\n  const featureRejection = feature?.rejection ? `##REJECTION REASON:${NEWLINE}${feature.rejection}${NEWLINE}` : '';\\n  const taskRejection = task.rejection ? `##REJECTION REASON:${NEWLINE}${task.rejection}` : '';\\n\\n  return [\\n    agentSystemPrompt,\\n    `#CURRENT TASK (ID: ${task.id})`,\\n    '##TITLE:',\\n    task.title,\\n    '##DESCRIPTION:',\\n    task.description,\\n    taskRejection,\\n    '',\\n    featureBlock,\\n    featureRejection,\\n    plan ? '#THE PLAN' + plan : '',\\n    '',\\n    acceptance ? '#ACCEPTANCE CRITERIA:' + acceptance : '',\\n    '',\\n    '#TOOL SIGNATURES:',\\n    `${toolSignaturesStr}`,\\n    '',\\n    '#RESPONSE FORMAT INSTRUCTIONS:',\\n    PROTOCOL_INSTRUCTIONS,\\n    '',\\n    '#CONTEXT FILES PROVIDED:',\\n    context,\\n    '',\\n    'Begin now.'\\n  ].join('\\\\n');\\n}\\n\\n// Attach metadata to messages so history can be reconstructed reliably after persistence\\nfunction annotateMessage<T extends CompletionMessage>(msg: T, meta: { featureId?: string; agentType?: string; turn?: number; source?: string; marker?: string; askedAt?: string }): T {\\n  const anyMsg = msg as any;\\n  if (meta.featureId) anyMsg.featureId = meta.featureId;\\n  if (meta.agentType) anyMsg.agentType = meta.agentType;\\n  if (typeof meta.turn === 'number') anyMsg.turn = meta.turn;\\n  if (meta.source) anyMsg.source = meta.source;\\n  if (meta.marker) anyMsg.marker = meta.marker;\\n  if (meta.askedAt) anyMsg.askedAt = meta.askedAt;\\n  anyMsg.createdAt = new Date().toISOString();\\n  return msg;\\n}\\n\\n// Grouped history structure for persistence/readability\\ntype FeatureMessagesGroup = { startDate: string; endDate?: string; featureId: string; messages: CompletionMessage[] };\\n\\nfunction ensureGroup(groups: Record<string, FeatureMessagesGroup>, featureId: string): FeatureMessagesGroup {\\n  if (!groups[featureId]) {\\n    groups[featureId] = { featureId, startDate: new Date().toISOString(), messages: [] };\\n  }\\n  return groups[featureId];\\n}\\n\\nfunction parseAgentResponse(content: string) : AgentResponse | undefined\\n{\\n  let parsed: MatchAgentResponse | undefined;\\n  try { parsed = JSON.parse(content) as MatchAgentResponse; } catch {}\\n\\n  if (!parsed) { return }\\n  const thoughts = parsed.thoughts\\n  const toolCallsMatched: MatchToolCall[] = parsed.tool_calls ?? parsed.tools ?? parsed.calls ?? []; \\n\\n  let tool_calls : ToolCall[] = []\\n  for(const t of toolCallsMatched){\\n    tool_calls.push({\\n      tool_name: t.tool_name ?? t.name ?? t.tool ?? \\\"\\\",\\n      arguments: t.arguments ?? t.args ?? t.parameters ?? t.params,\\n    })\\n  }\\n  return { thoughts, tool_calls }\\n}\\n\\nasync function runConversation(opts: {\\n  model: string;\\n  availableTools: Record<string, (args: any) => Promise<any> | any>;\\n  systemPrompt: string;\\n  task: Task;\\n  feature: Feature | null;\\n  agentType: string;\\n  toolFunctions: Tools;\\n  git: GitManager;\\n  completion: CompletionClient;\\n  complete: (why: 'finish' | 'block' | 'max_turns', info?: any) => void;\\n  emit?: (e: { type: string; payload?: any }) => void; // event sink for logging/stats\\n}) {\\n  const { model, availableTools, systemPrompt, task, feature, agentType, toolFunctions, git, completion, complete, emit } = opts;\\n  const doEmit = (e: { type: string; payload?: any }) => { try { emit?.(e); } catch {} };\\n\\n  const featureKey = feature?.id ?? '__task__';\\n\\n  const initialUser: CompletionMessage = annotateMessage(\\n    { role: 'user', content: systemPrompt } as any,\\n    { featureId: featureKey, agentType, turn: 0, source: 'initial' }\\n  );\\n  const messages: CompletionMessage[] = [initialUser];\\n  doEmit({ type: 'llm/messages/init', payload: { messages: messages.slice(), featureId: featureKey, turn: 0 } });\\n\\n  for (let i = 0; i < MAX_TURNS_PER_FEATURE; i++) {\\n    try {\\n      // Emit snapshot of request context before calling the LLM\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i } });\\n      const startedAt = Date.now();\\n      const res = await completion({ model, messages, response_format: { type: 'json_object' } });\\n      const durationMs = Date.now() - startedAt;\\n\\n      const agentResponse = parseAgentResponse(res.message.content)\\n\\n      const assistant = annotateMessage(\\n        { role: 'assistant' as const, content: JSON.stringify(agentResponse) ?? res.message.content },\\n        { featureId: featureKey, agentType, turn: i, askedAt: new Date(startedAt).toISOString() }\\n      );\\n      messages.push(assistant);\\n      // Emit assistant message and timing\\n      doEmit({ type: 'llm/message', payload: { message: assistant, featureId: featureKey, durationMs } });\\n\\n      // Parse and log succinct info\\n      logLLMStep({ turn: i, thoughts: agentResponse?.thoughts, toolCalls: agentResponse?.tool_calls, durationMs, tag: agentType });\\n\\n      if (!agentResponse?.tool_calls?.length) {\\n        // No tool calls; continue loop.\\n        doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i, note: 'no_tool_calls' } });\\n        doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} complete` } });\\n        continue;\\n      }\\n\\n      const toolOutputs: ToolResult[] = [];\\n\\n      for (const call of agentResponse.tool_calls) {\\n        const toolName = call.tool_name;\\n        let args = normalizeToolArguments(call.arguments, toolName);\\n\\n        if (availableTools[toolName]) {\\n          if (!('task_id' in args)) args.task_id = task.id;\\n          if (feature && !('feature_id' in args)) args.feature_id = feature.id;\\n          const result = await Promise.resolve(availableTools[toolName](args));\\n          toolOutputs.push({ name: toolName, result });\\n        } else {\\n          toolOutputs.push({ name: toolName, result: `Error: Tool '${toolName}' not found.` });\\n        }\\n\\n        // Termination tools mirror Python; do not append a tool result turn, final message is assistant\\n        if (['finish_feature', 'block_feature', 'finish_spec', 'block_task'].includes(toolName)) {\\n          doEmit({ type: 'llm/messages/final', payload: { messages: messages.slice(), featureId: featureKey, tool: toolName } });\\n          complete(toolName === 'block_feature' || toolName === 'block_task' ? 'block' : 'finish');\\n          return;\\n        }\\n      }\\n\\n      // Append tool results as a dedicated 'user' role message to avoid confusing with user turns\\n      const toolResultMsg: CompletionMessage = annotateMessage(\\n        { role: 'user', content: JSON.stringify(toolOutputs) } as any,\\n        { featureId: featureKey, agentType, turn: i, source: 'tools' }\\n      );\\n      messages.push(toolResultMsg);\\n      doEmit({ type: 'llm/message', payload: { message: toolResultMsg, featureId: featureKey, turn: i, source: 'tools' } });\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i, note: 'tools_appended' } });\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} tool calls processed` } });\\n    } catch (e) {\\n      if (feature) {\\n        await toolFunctions.blockFeature(task.id, feature.id, `Agent loop failed: ${e}`, agentType, git);\\n      } else {\\n        await toolFunctions.blockTask(task.id, `Agent loop failed: ${e}`, agentType, git);\\n      }\\n      doEmit({ type: 'llm/messages/error', payload: { error: String(e), messages: messages.slice(), featureId: featureKey } });\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: undefined, message: 'Error encountered' } });\\n      logger.error('Agent loop error:', e as any);\\n      complete('block', e);\\n      return;\\n    }\\n  }\\n\\n  // Max turns reached -> block\\n  if (feature) {\\n    await toolFunctions.blockFeature(task.id, feature.id, 'Agent loop exceeded max turns', agentType, git);\\n  } else {\\n    await toolFunctions.blockTask(task.id, 'Agent loop exceeded max turns', agentType, git);\\n  }\\n  doEmit({ type: 'llm/messages/final', payload: { messages: [{ role: 'system', content: systemPrompt }] as CompletionMessage[], featureId: featureKey, reason: 'max_turns' } });\\n  doEmit({ type: 'run/progress/snapshot', payload: { progress: 1, message: 'Max turns reached' } });\\n  logger.warn('Max turns reached without completion.');\\n  complete('max_turns');\\n}\\n\\nasync function runAgentOnTask(model: string, agentType: AgentType, task: Task, toolFunctions: Tools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\n  logger.debug(`\\\\n--- Activating Agent ${agentType} for task: [${task.id}] ${task.title} ---`);\\n  const agentDocs = getAgentFile(agentType);\\n  const contextFiles = ['docs/FILE_ORGANISATION.md'];\\n  const [funcs, sigs] = toolSigsForAgent(agentType, toolFunctions, git);\\n  const context = await Promise.resolve(toolFunctions.readFiles(contextFiles));\\n  const systemPrompt = constructSystemPrompt(agentType, task, null, agentDocs, context, sigs);\\n\\n  // Maintain grouped structure for task-level chat\\n  const groups: Record<string, FeatureMessagesGroup> = {};\\n  const fid = '__task__';\\n  ensureGroup(groups, fid);\\n\\n  await runConversation({\\n    model,\\n    availableTools: funcs,\\n    systemPrompt,\\n    task,\\n    feature: null,\\n    agentType,\\n    toolFunctions,\\n    git,\\n    completion,\\n    complete: () => {},\\n    emit: (e) => {\\n      // Pass-through event, but attach grouped messages snapshot when available\\n      try {\\n        if (e?.payload?.messages && Array.isArray(e.payload.messages)) {\\n          // Update group messages with annotated copies\\n          const msgs = (e.payload.messages as CompletionMessage[]).map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? fid, agentType, turn: (m as any).turn ?? idx }));\\n          groups[fid].messages = msgs;\\n          if (e.type === 'llm/messages/final') groups[fid].endDate = new Date().toISOString();\\n          emit?.({ ...e, payload: { ...e.payload, messageGroups: { ...groups }, featureId: fid } });\\n          return;\\n        }\\n      } catch {}\\n      emit?.(e);\\n    },\\n  });\\n}\\n\\nasync function runAgentOnFeature(model: string, agentType: AgentType, task: Task, feature: Feature, toolFunctions: Tools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\n  logger.debug(`\\\\n--- Activating Agent ${agentType} for Feature: [${feature.id}] ${feature.title} ---`);\\n\\n  if (agentType === 'developer') await toolFunctions.updateFeatureStatus(task.id, feature.id, '~');\\n\\n  const agentDocs = getAgentFile(agentType);\\n  const featureContextFiles = ['docs/FILE_ORGANISATION.md', ...(feature.context ?? [])];\\n  const [funcs, sigs] = toolSigsForAgent(agentType, toolFunctions, git);\\n  const context = await Promise.resolve(toolFunctions.readFiles(featureContextFiles));\\n  const systemPrompt = constructSystemPrompt(agentType, task, feature, agentDocs, context, sigs);\\n\\n  if (agentType === 'developer') await toolFunctions.updateFeatureStatus(task.id, feature.id, '~');\\n\\n  await runConversation({\\n    model,\\n    availableTools: funcs,\\n    systemPrompt,\\n    task,\\n    feature,\\n    agentType,\\n    toolFunctions,\\n    git,\\n    completion,\\n    complete: () => {},\\n    emit,\\n  });\\n}\\n\\nasync function runOrchestrator(opts: {\\n  model: string;\\n  agentType: AgentType;\\n  taskId: string; \\n  featureId?: string; \\n  tools: Tools;\\n  git: GitManager;\\n  completion: CompletionClient;\\n  emit?: (e: { type: string; payload?: any }) => void;\\n}) {\\n  const { model, agentType, taskId, tools, git, completion, emit } = opts;\\n\\n  const currentTask: Task = await tools.getTask(taskId);\\n  if (!currentTask) {\\n    logger.warn('No available tasks to work on in the repository.');\\n    return;\\n  }\\n\\n  logger.debug(`Selected Task: [${currentTask.id}] ${currentTask.title}`);\\n\\n  const branch = `features/${currentTask.id}`;\\n  try {\\n    await git.checkoutBranch(branch, true);\\n  } catch (e) {\\n    logger.warn(`Could not create or checkout branch '${branch}': ${e}`);\\n    await git.checkoutBranch(branch, false);\\n  }\\n  try {\\n    await git.pull(branch);\\n  } catch (e) {\\n    logger.warn(`Could not pull branch '${branch}': ${e}`);\\n  }\\n\\n  const processed = new Set<string>();\\n\\n  // Aggregate all messages across features for this run\\n  let aggregatedMessages: CompletionMessage[] = [];\\n  const aggregatedGroups: Record<string, FeatureMessagesGroup> = {};\\n\\n  if (agentType === 'speccer') {\\n    const freshTask = await tools.getTask(currentTask.id);\\n    await runAgentOnTask(model, agentType, freshTask, tools, git, completion, (e) => {\\n      // For task-level runs, forward events and add grouped snapshot for persistence\\n      if (e?.payload?.messages) {\\n        const msgs = e.payload.messages as CompletionMessage[];\\n        const fid = '__task__';\\n        const annotated = msgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? fid, agentType, turn: (m as any).turn ?? idx }));\\n        aggregatedMessages = annotated.slice();\\n        const group = ensureGroup(aggregatedGroups, fid);\\n        group.messages = annotated.slice();\\n        if (e.type === 'llm/messages/final') group.endDate = new Date().toISOString();\\n        emit?.({ ...e, payload: { ...e.payload, featureId: fid, messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups } } });\\n      } else {\\n        emit?.(e);\\n      }\\n    });\\n    return;\\n  }\\n\\n  while (true) {\\n    const freshTask = await tools.getTask(currentTask.id);\\n    const next = findNextAvailableFeature(freshTask, processed, agentType !== 'developer');\\n    if (!next) {\\n      logger.debug(`\\\\nNo more available features for task ${freshTask.id}.`);\\n      break;\\n    }\\n\\n    // Ensure a group exists for this feature\\n    ensureGroup(aggregatedGroups, next.id);\\n\\n    // Insert a system marker before each feature to clearly separate in UI and history (flat array only)\\n    const featureMarker: CompletionMessage = annotateMessage(\\n      { role: 'system', content: `--- BEGIN FEATURE ${next.id}: ${next.title} ---` } as any,\\n      { featureId: next.id, agentType, marker: 'feature_begin' }\\n    );\\n    aggregatedMessages.push(featureMarker);\\n    emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'feature_begin', featureId: next.id } });\\n\\n    // Wrap emit to merge current feature's messages with the aggregate so far\\n    let lastFeatureMessages: CompletionMessage[] = [];\\n    const baseEmit = emit;\\n    const wrappedEmit = (e: { type: string; payload?: any }) => {\\n      const t = e?.type;\\n      if ((t === 'llm/messages/init' || t === 'llm/messages/snapshot' || t === 'llm/messages/final') && e?.payload?.messages) {\\n        try {\\n          const featureMsgs: CompletionMessage[] = e.payload.messages || [];\\n          // Ensure every message is tagged with this feature id and agentType for persistence\\n          const ensured = featureMsgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? next.id, agentType, turn: (m as any).turn ?? idx }));\\n          lastFeatureMessages = ensured.slice();\\n          // Update groups\\n          const g = ensureGroup(aggregatedGroups, next.id);\\n          g.messages = ensured.slice();\\n          if (t === 'llm/messages/final') g.endDate = new Date().toISOString();\\n          // Update flat aggregate for readability (kept for backward compatibility)\\n          const combined = aggregatedMessages.concat(ensured);\\n          const payload = { ...e.payload, featureId: next.id, messages: combined, messageGroups: { ...aggregatedGroups } };\\n          baseEmit?.({ ...e, payload });\\n          return;\\n        } catch {}\\n      }\\n      baseEmit?.(e);\\n    };\\n\\n    await runAgentOnFeature(model, agentType, freshTask, next, tools, git, completion, wrappedEmit);\\n\\n    // After the feature completes, fold its messages into the aggregate\\n    if (lastFeatureMessages && lastFeatureMessages.length) {\\n      aggregatedMessages = aggregatedMessages.concat(lastFeatureMessages);\\n      // Emit a snapshot to persist the full sequence after folding\\n      emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'feature_folded', featureId: next.id } });\\n    }\\n\\n    processed.add(next.id);\\n  }\\n\\n  // Emit final snapshot at end of task run with complete sequence of feature conversations\\n  emit?.({ type: 'llm/messages/final', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'task_run_complete' } });\\n}\\n\\n// --- Isolated Runner (mimic Python run.py) ---\\n\\nfunction shouldIgnoreCopy(relPath: string): boolean {\\n  // Ignore common build, cache, and IDE artifacts for TypeScript/Node/Electron projects\\n  // Preserve .git (do NOT ignore)\\n  const parts = relPath.split(path.sep);\\n  const name = parts[parts.length - 1] || relPath;\\n\\n  // If path is within .git, do not ignore (preserve repo history/branches)\\n  if (parts.includes('.git')) return false;\\n\\n  const dirIgnore = new Set([\\n    // Package managers and caches\\n    'node_modules', '.pnpm', '.pnp', '.pnp.cjs', '.pnp.js', '.npm', '.yarn', '.yarn-cache', '.yarnrc',\\n    // Build/output directories\\n    'dist', 'build', 'out', 'release', 'storybook-static',\\n    // Framework-specific\\n    '.next', 'next', '.nuxt', '.svelte-kit',\\n    // Bundlers and dev servers caches\\n    '.vite', '.rollup.cache', '.parcel-cache', '.webpack',\\n    // Test/coverage\\n    'coverage', '.nyc_output',\\n    // Monorepo/turbo caches\\n    '.turbo',\\n    // Generic caches\\n    '.cache', '.eslintcache', '.rpt2_cache', '.tscache',\\n    // Editors/IDE\\n    '.idea', '.vscode',\\n    // Python (from original mirror)\\n    'venv', '__pycache__',\\n    // Logs and temp\\n    'logs', 'tmp', 'temp'\\n  ]);\\n\\n  // If any path segment matches an ignored dir name\\n  if (parts.some(p => dirIgnore.has(p))) return true;\\n\\n  // Ignore specific file patterns\\n  const lower = name.toLowerCase();\\n  if (lower === '.ds_Store'.toLowerCase() || lower === 'thumbs.db') return true;\\n  if (lower.endsWith('.log')) return true; // npm/yarn/pnpm debug logs\\n  if (lower.endsWith('.pyc')) return true; // Python bytecode files\\n  if (lower.endsWith('.tsbuildinfo')) return true; // TypeScript incremental build info\\n\\n  // Ignore Electron asar content markers when encountered as path segments\\n  if (parts.some(p => p.endsWith('.asar') || p.endsWith('.asar.unpacked'))) return true;\\n\\n  return false;\\n}\\n\\nasync function copyTree(src: string, dest: string) {\\n  // Recursively copy, respecting ignore patterns and skipping asar/virtual entries\\n  let stat: fs.Stats;\\n  try {\\n    stat = await fsp.stat(src);\\n  } catch (e: any) {\\n    throw new Error(`Source path does not exist or is not accessible: ${src} (${e?.code || e})`);\\n    }\\n  if (!stat.isDirectory()) throw new Error(`Source ${src} is not a directory`);\\n  await fsp.mkdir(dest, { recursive: true });\\n\\n  const walk = async (from: string, to: string) => {\\n    let entries: fs.Dirent[] = [] as unknown as fs.Dirent[];\\n    try {\\n      entries = await fsp.readdir(from, { withFileTypes: true });\\n    } catch (e: any) {\\n      // Skip unreadable directories (e.g., asar virtuals)\\n      logger.warn(`copyTree: Skipping unreadable directory ${from}: ${e?.code || e}`);\\n      return;\\n    }\\n    for (const entry of entries) {\\n      const rel = path.relative(src, path.join(from, entry.name));\\n      if (shouldIgnoreCopy(rel)) continue;\\n      const srcPath = path.join(from, entry.name);\\n      const dstPath = path.join(to, entry.name);\\n\\n      // Skip any path that traverses into an asar archive\\n      if (srcPath.includes('.asar')) continue;\\n\\n      try {\\n        if (entry.isDirectory()) {\\n          await fsp.mkdir(dstPath, { recursive: true });\\n          await walk(srcPath, dstPath);\\n        } else if (entry.isSymbolicLink()) {\\n          // Resolve symlink target and copy contents (best-effort)\\n          try {\\n            const linkTarget = await fsp.readlink(srcPath);\\n            const resolved = path.resolve(path.dirname(srcPath), linkTarget);\\n            const st = await fsp.stat(resolved);\\n            if (st.isDirectory()) {\\n              await fsp.mkdir(dstPath, { recursive: true });\\n              await walk(resolved, dstPath);\\n            } else {\\n              await fsp.copyFile(resolved, dstPath);\\n            }\\n          } catch {\\n            // Fallback: copy file bytes of the link itself (as file)\\n            try { await fsp.copyFile(srcPath, dstPath); } catch {}\\n          }\\n        } else if (entry.isFile()) {\\n          await fsp.copyFile(srcPath, dstPath);\\n        }\\n      } catch (e: any) {\\n        // Skip problematic entries (e.g., ENOENT due to virtualized packaging paths)\\n        if (e && (e.code === 'ENOENT' || e.code === 'EBUSY' || e.code === 'EPERM')) {\\n          logger.warn(`copyTree: Skipping ${srcPath}: ${e.code}`);\\n          continue;\\n        }\\n        throw e;\\n      }\\n    }\\n  };\\n\\n  await walk(src, dest);\\n}\\n\\nexport async function runIsolatedOrchestrator(opts: {\\n  model: string;\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\n  projectId: string; \\n  taskId: string;\\n  featureId?: string; \\n  webSearchApiKeys?: WebSearchApiKeys;\\n  githubCredentials?: GithubCredentials;\\n  gitFactory: (projectRoot: string, githubCredentials?: GithubCredentials) => GitManager;  // git bound to projectRoot\\n  completion: CompletionClient;\\n  emit?: (e: { type: string; payload?: any }) => void;\\n}) {\\n  const { model, agentType, projectId, taskId, featureId, webSearchApiKeys, githubCredentials, gitFactory, completion, emit } = opts;\\n\\n\\n  // Create temp workspace\\n  const tmpBase = fs.mkdtempSync(path.join(os.tmpdir(), 'thefactory-tools-'));\\n  // Keep a subfolder to host the copied source\\n  const workspace = path.join(tmpBase, 'workspace');\\n\\n  const projectTools = createTools(process.cwd(), webSearchApiKeys);\\n  const projectDir = await projectTools.getProjectDir(projectId);\\n\\n  logger.info(`Copying repository from '${projectDir}' to temporary workspace: '${workspace}'`);\\n  try {\\n    await copyTree(projectDir, workspace);\\n  } catch (e) {\\n    logger.error(`FATAL: Failed to copy repository to temporary directory from '${projectDir}' -> '${workspace}': ${e}`);\\n    // best-effort cleanup\\n    try { fs.rmSync(tmpBase, { recursive: true, force: true }); } catch {}\\n    return;\\n  }\\n\\n  const git = gitFactory(workspace, githubCredentials);\\n  const tools = createTools(workspace, webSearchApiKeys);\\n\\n  try {\\n    await runOrchestrator({\\n      model,\\n      agentType,\\n      taskId,\\n      featureId,\\n      tools,\\n      git,\\n      completion,\\n      emit,\\n    });\\n  } catch (e) {\\n    logger.error(`An error occurred while running the agent orchestrator: ${e}`);\\n  } finally {\\n    // Cleanup temporary directory\\n    try {\\n      fs.rmSync(tmpBase, { recursive: true, force: true });\\n      logger.info('Agent run finished. Temporary directory cleaned up.');\\n    } catch (e) {\\n      logger.warn(`Failed to cleanup temporary directory '${tmpBase}': ${e}`);\\n    }\\n  }\\n}\"}},{\"tool_name\":\"finish_feature\",\"arguments\":{}}]}",
        "featureId": "753f6df3-59a8-4fe0-972b-1dae53c20a15",
        "agentType": "developer",
        "turn": 1,
        "askedAt": "2025-09-09T17:58:28.290Z",
        "createdAt": "2025-09-09T18:00:16.121Z"
      }
    ],
    "endDate": "2025-09-09T18:00:16.121Z"
  }
}