[
  {
    "role": "system",
    "content": "--- BEGIN FEATURE 5f2a9d3e-dfa3-4e79-ba0b-8b2252556681: When editing/creating a feature allow quick file lookups ---"
  },
  {
    "role": "user",
    "content": "# Developer Agent Steps Execution\n\nYou are the Developer Agent. You will be assigned a single feature to implement. Your goal is to complete it by following these steps precisely.\n\n## Workflow\n\n1.  **Analyze the Feature**: Read the feature's title, description and rejection (if provided) to understand its goal.\n2.  **Consult the File Structure**: Use the provided `docs/FILE_ORGANISATION.md` to understand the project context.\n3.  **Implement**: Write or modify files to meet the feature's acceptance criteria. Use the `write_file`, `rename_file`, `delete_file`, `list_files` and `search_files` tools for all file operations.\n4.  **Complete the Feature**: When the feature is complete, you **MUST** call the `finish_feature` tool. This is your final step for a successful implementation.\n5.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_feature` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n## Notes\n\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\n#CURRENT TASK (ID: f67e8921-b197-40c9-9154-e95db8f27deb)\n##TITLE:\nFactory-ts improvements\n##DESCRIPTION:\nVarious improvements to add to the project and the factory-ts package\n\n\n#ASSIGNED FEATURE: When editing/creating a feature allow quick file lookups (ID: 5f2a9d3e-dfa3-4e79-ba0b-8b2252556681)\n##DESCRIPTION: When a user types in the description and starts typing \"@\" a file lookup search tooltip should show above that will filter files based on what the user types. The user can then select the appropriate file. It should also automatically add this file into the Context Files list.\n\nThis feature is currently implemented seperately inside @src/renderer/screens/ChatView.tsx  and @src/renderer/components/tasks/FeatureForm.tsx \nthe files responsible are:\n@src/renderer/components/ui/FileMentionsTextarea.tsx and @src/renderer/hooks/useFilesAutocomplete.ts   \n\n@src/renderer/screens/ChatView.tsx actually also uses @src/renderer/hooks/useReferencesAutocomplete.ts which allows the text input to display references. Both of these ideas are relevant for @src/renderer/components/tasks/FeatureForm.tsx and @src/renderer/screens/ChatView.tsx . Both should allow the display of references lookup and file lookup - they simply must be able to have callbacks so that they can do extra things with them (FeatureForm needs to add/remove files to/from the context and add/remove blockers to/from the feature - this is missing right now).\n\n\n\n\n\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- write_file(filename: str, content: str) - Create or overwrite a file with the given content. Always use this to write code or docs.\n- rename_file(filename: str, new_filename: str) - Rename or move a file from one path to another.\n- delete_file(filename: str) - Delete a file. Use with caution and only when necessary.\n- run_test() -> str - Run the test for the current feature and return the output. Use to verify implementation.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n{\n  \"thoughts\": \"A string explaining your reasoning, analysis, and plan for this step. For example: 'I need to create the main application file and then add the basic boilerplate.'\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"name_of_the_tool_to_call\",\n      \"arguments\": {\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\"\n      }\n    }\n  ]\n}\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\nAs responses to the tool calls you will send, you will also receive JSON objects in the form:\n```json\n{\n\"name\":\"tool_name\",\n\"result\":\"...\"\n}\n```\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"# File Organisation\\n\\nPurpose\\n- Provide a high-level map of the repository so contributors and agents can quickly find the right area.\\n- This is not a change log and not a per-file inventory.\\n\\nEditing Rules (read before updating)\\n- Only document major directories and subsystems. Do not list individual files.\\n- Keep bullets short (one sentence) and avoid \\\"New:\\\" or historical notes.\\n- When adding/removing a major directory or moving a subsystem, update a single bullet here.\\n- Prefer linking or pointing to deeper docs (README/OVERVIEW) rather than describing internals here.\\n- Never document build related artifacts.\\n\\nTop-Level Layout\\n- docs/: Project-wide documentation and specs; single source of truth for protocols and workflows.\\n- src/: Application source (Electron app: main, preload, renderer, and tooling).\\n  - renderer/: React UI (components, screens, hooks, services, navigation, preview runtime).\\n    - components/agents/: Agent-specific UI (status chips, run bullets, model selectors, project/cost/token chips).\\n    - services/: Renderer-side services (e.g., pricingService for LLM price lookup via IPC).\\n  - tools/: Developer and agent tooling (preview analyzer, factory integration, helpers).\\n  - main.js: Electron main process entry.\\n  - preload.js: Safe IPC surface exposed to the renderer.\\n- packages/: Local monorepo packages.\\n  - factory-ts/: Agent orchestration library (orchestrator, pricing, history, completion, git integration).\\n- scripts/: Project automation scripts and CLIs.\\n- Root config files: package.json, tsconfig.json, tailwind/postcss configs, vite configs, forge config, .env.\\n\\nWhere to Learn More\\n- Agents and roles: packages/factory-ts/docs (AGENT_*.md).\\n- Factory TS overview and APIs: packages/factory-ts (see README/OVERVIEW files in that package).\\n- Preview system: see src/renderer/preview and related docs in docs/ (preview usage and analyzer).\\n- IPC and factory integration: src/tools/factory (renderer bridge and main process handlers).\\n\\nConventions (brief)\\n- Keep cross-cutting documentation in docs/; place domain-specific or area-specific READMEs next to the code they describe.\\n- Use descriptive directory names and keep responsibilities separated by area (renderer vs main vs tools vs packages).\\n\\nEnvironment & Credentials\\n- .env at the repo root is used for local development (e.g., credentials consumed by tooling and factory-ts).\\n\\nNotes\\n- If you are unsure whether something belongs here, it probably belongs in a local README under its directory, with this file providing only a one-line pointer to that area.\\n\",\"src/renderer/screens/ChatView.tsx\":\"import React, { useState, useEffect, useRef, useMemo } from 'react'\\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/Select'\\nimport { useChats } from '../hooks/useChats'\\nimport { useFilesAutocomplete } from '../hooks/useFilesAutocomplete'\\nimport { useReferencesAutocomplete } from '../hooks/useReferencesAutocomplete'\\nimport { useLLMConfig } from '../hooks/useLLMConfig'\\nimport { useNavigator } from '../navigation/Navigator'\\nimport CollapsibleSidebar from '../components/ui/CollapsibleSidebar'\\nimport FileDisplay from '../components/ui/FileDisplay'\\nimport useFiles, { inferFileType } from '../../renderer/hooks/useFiles';\\nimport { Chat, ChatMessage } from '../services/chatsService'\\nimport RichText from '../components/ui/RichText'\\n\\ninterface EnhancedMessage extends ChatMessage {\\n  showModel?: boolean\\n  isFirstInGroup?: boolean\\n}\\n\\nexport default function ChatView() {\\n  const {\\n    currentChatId,\\n    setCurrentChatId,\\n    chatsById,\\n    createChat,\\n    deleteChat,\\n    sendMessage\\n  } = useChats()\\n  const { files, filesByPath, uploadFile } = useFiles()\\n  const { configs, activeConfigId, activeConfig, isConfigured, setActive } = useLLMConfig()\\n  const { navigateView } = useNavigator()\\n\\n  const [currentChat, setCurrentChat] = useState<Chat | undefined>()\\n  const [input, setInput] = useState<string>('')\\n  const [pendingAttachments, setPendingAttachments] = useState<string[]>([])\\n  const messageListRef = useRef<HTMLDivElement>(null)\\n  const textareaRef = useRef<HTMLTextAreaElement>(null)\\n  const mirrorRef = useRef<HTMLDivElement>(null)\\n  const fileInputRef = useRef<HTMLInputElement>(null)\\n  const [messages, setMessages] = useState<ChatMessage[]>([])\\n\\n  const {\\n    isOpen: isAutocompleteOpen,\\n    matches: matchingDocs,\\n    position: autocompletePosition,\\n    onSelect: onAutocompleteSelect,\\n  } = useFilesAutocomplete({ filesList: files.map(f => f.path), input, setInput, textareaRef, mirrorRef })\\n\\n  const {\\n    isOpen: isRefsOpen,\\n    matches: matchingRefs,\\n    position: refsPosition,\\n    onSelect: onRefsSelect,\\n  } = useReferencesAutocomplete({ input, setInput, textareaRef, mirrorRef })\\n\\n  useEffect(() => {\\n    const el = messageListRef.current\\n    if (!el) return\\n    el.scrollTo({ top: el.scrollHeight })\\n  }, [chatsById])\\n\\n  useEffect(() => {\\n    if (currentChatId){\\n      const chat = chatsById[currentChatId]\\n      setCurrentChat(chat)\\n    }\\n  }, [currentChatId, chatsById])\\n\\n  useEffect(() => {\\n    if (currentChat){\\n      setMessages(currentChat.messages)\\n    }\\n  }, [currentChat])\\n\\n  \\n  const chatHistories = useMemo(() => {\\n    return Object.values(chatsById).sort((a,b) => new Date(a.updateDate).getTime() - new Date(b.updateDate).getTime())\\n  }, [chatsById])\\n\\n  const autoSizeTextarea = () => {\\n    const el = textareaRef.current\\n    if (!el) return\\n    el.style.height = 'auto'\\n    const max = 200\\n    const next = Math.min(el.scrollHeight, max)\\n    el.style.height = next + 'px'\\n  }\\n  useEffect(() => {\\n    autoSizeTextarea()\\n  }, [input])\\n\\n  const handleSend = async () => {\\n    if (!input.trim() || !activeConfig) return\\n    await sendMessage(input, activeConfig, pendingAttachments)\\n    setInput('')\\n    setPendingAttachments([])\\n    requestAnimationFrame(() => {\\n      if (textareaRef.current) {\\n        textareaRef.current.style.height = 'auto'\\n        textareaRef.current.focus()\\n      }\\n    })\\n  }\\n\\n  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    const file = e.target.files?.[0]\\n    if (!file) return\\n\\n    const reader = new FileReader()\\n    reader.onload = async (event) => {\\n      const content = event.target?.result as string\\n      const newPath = await uploadFile(file.name, content)\\n      console.log(\\\"newPath: \\\", newPath)\\n      if (newPath){\\n        setPendingAttachments((prev) => Array.from(new Set([...prev, newPath])))\\n      }\\n    }\\n    reader.readAsText(file)\\n    // e.currentTarget.value = ''\\n  }\\n\\n  const handleTextareaKeyDown: React.KeyboardEventHandler<HTMLTextAreaElement> = (e) => {\\n    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {\\n      e.preventDefault()\\n      handleSend()\\n    }\\n  }\\n\\n  const enhancedMessages: EnhancedMessage[] = useMemo(() => {\\n    return messages.map((msg, index) => {\\n      let showModel = false\\n      if (msg.role === 'assistant' && msg.model) {\\n        const prevAssistant = [...messages.slice(0, index)].reverse().find((m) => m.role === 'assistant')\\n        showModel = !prevAssistant || prevAssistant.model !== msg.model\\n      }\\n      const prev = messages[index - 1]\\n      const isFirstInGroup = !prev || prev.role !== msg.role || msg.role === 'system'\\n      return { ...msg, showModel, isFirstInGroup }\\n    })\\n  }, [messages])\\n\\n  const canSend = Boolean(input.trim() && activeConfig && isConfigured)\\n\\n  const chatItems = useMemo(() => chatHistories.map((chat) => ({\\n    id: chat.id,\\n    label: `Chat ${new Date(chat.creationDate)}`,\\n    icon: <span aria-hidden>💬</span>,\\n    accent: 'gray',\\n    action: (\\n      <button\\n        onClick={(e) => {\\n          e.stopPropagation()\\n          deleteChat(chat.id)\\n        }}\\n      >\\n        Delete\\n      </button>\\n    ),\\n  })), [chatHistories, deleteChat])\\n\\n  return (\\n    <CollapsibleSidebar\\n      items={chatItems}\\n      activeId={currentChatId || ''}\\n      onSelect={setCurrentChatId}\\n      storageKey=\\\"chat-sidebar-collapsed\\\"\\n      headerTitle=\\\"History\\\"\\n      headerSubtitle=\\\"\\\"\\n      headerAction={<button className=\\\"btn\\\" onClick={createChat} aria-label=\\\"Create new chat\\\">New</button>}\\n      emptyMessage=\\\"No chats yet\\\"\\n    >\\n      <section className=\\\"flex-1 flex flex-col w-full h-full bg-[var(--surface-base)] overflow-hidden\\\">\\n        <div\\n          ref={mirrorRef}\\n          aria-hidden=\\\"true\\\"\\n          className=\\\"absolute top-[-9999px] left-0 overflow-hidden whitespace-pre-wrap break-words pointer-events-none\\\"\\n        />\\n\\n        <header className=\\\"flex-shrink-0 px-4 py-2 border-b border-[var(--border-subtle)] bg-[var(--surface-raised)] flex items-center justify-between gap-3\\\">\\n          <div className=\\\"flex items-center gap-3 min-w-0\\\">\\n            <h1 className=\\\"m-0 text-[var(--text-primary)] text-[18px] leading-tight font-semibold truncate\\\">\\n              Project Chat {currentChat ? `(${new Date(currentChat.updateDate).toLocaleString()})` : ''}\\n            </h1>\\n          </div>\\n          <div className=\\\"flex items-center gap-2\\\">\\n            <Select value={activeConfigId || ''} onValueChange={setActive}>\\n              <SelectTrigger className=\\\"ui-select w-[220px]\\\">\\n                <SelectValue placeholder=\\\"Select Model\\\" />\\n              </SelectTrigger>\\n              <SelectContent>\\n                {configs.map((cfg) => (\\n                  <SelectItem key={cfg.id} value={cfg.id}>\\n                    {cfg.name} ({cfg.model})\\n                  </SelectItem>\\n                ))}\\n              </SelectContent>\\n            </Select>\\n            <button\\n              onClick={() => navigateView('Settings')}\\n              className=\\\"btn-secondary\\\"\\n              aria-label=\\\"Open Settings\\\"\\n            >\\n              Settings\\n            </button>\\n          </div>\\n        </header>\\n\\n        {!isConfigured && (\\n          <div\\n            className=\\\"flex-shrink-0 mx-4 mt-3 rounded-md border border-[var(--border-default)] p-2 text-[13px] flex items-center justify-between gap-2\\\"\\n            style={{\\n              background: 'color-mix(in srgb, var(--accent-primary) 10%, var(--surface-raised))',\\n              color: 'var(--text-primary)',\\n            }}\\n            role=\\\"status\\\"\\n          >\\n            <span>LLM not configured. Set your API key in Settings to enable sending messages.</span>\\n            <button className=\\\"btn\\\" onClick={() => navigateView('Settings')}>Configure</button>\\n          </div>\\n        )}\\n\\n        <div ref={messageListRef} className=\\\"flex-1 min-h-0 overflow-auto p-4\\\">\\n          {enhancedMessages.length === 0 ? (\\n            <div className=\\\"mt-10 mx-auto max-w-[720px] text-center text-[var(--text-secondary)]\\\">\\n              <div className=\\\"text-[18px] font-medium\\\">Start chatting about the project</div>\\n              <div className=\\\"text-[13px] mt-2\\\">Tip: Use Cmd/Ctrl+Enter to send • Shift+Enter for newline</div>\\n              <div className=\\\"mt-4 inline-block rounded-lg border border-[var(--border-default)] bg-[var(--surface-raised)] px-4 py-3 text-[13px]\\\">\\n                Attach markdown or text files to give context. Mention files with @, and reference tasks/features with #.\\n              </div>\\n            </div>\\n          ) : (\\n            <div className=\\\"mx-auto max-w-[960px] space-y-3\\\">\\n              {enhancedMessages.map((msg, index) => {\\n                const isUser = msg.role === 'user'\\n                const isSystem = msg.role === 'system'\\n\\n                if (isSystem) {\\n                  return (\\n                    <div key={index} className=\\\"flex justify-center\\\">\\n                      <div className=\\\"text-[12px] text-[var(--text-muted)] italic bg-[var(--surface-raised)] border border-[var(--border-subtle)] rounded-full px-3 py-1\\\">\\n                        <RichText text={msg.content} />\\n                      </div>\\n                    </div>\\n                  )\\n                }\\n\\n                return (\\n                  <div\\n                    key={index}\\n                    className={[\\n                      'flex items-start gap-2',\\n                      isUser ? 'flex-row-reverse' : 'flex-row',\\n                    ].join(' ')}\\n                  >\\n                    <div\\n                      className={[\\n                        'shrink-0 w-7 h-7 rounded-full flex items-center justify-center text-[11px] font-semibold',\\n                        isUser\\n                          ? 'bg-[var(--accent-primary)] text-[var(--text-inverted)]'\\n                          : 'bg-[color-mix(in_srgb,var(--accent-primary)_14%,transparent)] text-[var(--text-primary)] border border-[var(--border-subtle)]',\\n                      ].join(' ')}\\n                      aria-hidden=\\\"true\\\"\\n                    >\\n                      {isUser ? 'You' : 'AI'}\\n                    </div>\\n\\n                    <div className={['max-w-[72%] min-w-[80px] flex flex-col', isUser ? 'items-end' : 'items-start'].join(' ')}>\\n                      {!isUser && msg.showModel && msg.model && (\\n                        <div className=\\\"text-[11px] text-[var(--text-secondary)] mb-1 inline-flex items-center gap-1 border border-[var(--border-subtle)] bg-[var(--surface-overlay)] rounded-full px-2 py-[2px]\\\">\\n                          <span className=\\\"inline-block w-1.5 h-1.5 rounded-full bg-[var(--accent-primary)]\\\" />\\n                          {msg.model}\\n                        </div>\\n                      )}\\n\\n                      <div\\n                        className={[\\n                          'px-3 py-2 rounded-2xl whitespace-pre-wrap break-words shadow',\\n                          isUser\\n                            ? 'bg-[var(--accent-primary)] text-[var(--text-inverted)] rounded-br-md'\\n                            : 'bg-[var(--surface-raised)] text-[var(--text-primary)] border border-[var(--border-subtle)] rounded-bl-md',\\n                          msg.isFirstInGroup ? '' : isUser ? 'rounded-tr-md' : 'rounded-tl-md',\\n                        ].join(' ')}\\n                      >\\n                        <RichText text={msg.content} />\\n                      </div>\\n\\n                      {msg.attachments && msg.attachments.length > 0 && (\\n                        <div className={[\\n                          'mt-1 flex flex-wrap gap-1',\\n                          isUser ? 'justify-end' : 'justify-start'\\n                        ].join(' ')}>\\n                          {msg.attachments.map((path, i) => {\\n                            const meta = filesByPath[path]\\n                            const name = meta?.name || (path.split('/').pop() || path)\\n                            const type = meta?.type || inferFileType(path)\\n                            const size = meta?.size ?? undefined\\n                            const mtime = meta?.mtime ?? undefined\\n                            return (\\n                              <FileDisplay\\n                                key={`${index}-att-${i}-${path}`}\\n                                file={{ name, path, type, size, mtime }}\\n                                density=\\\"compact\\\"\\n                                interactive\\n                                showPreviewOnHover\\n                              />\\n                            )\\n                          })}\\n                        </div>\\n                      )}\\n                    </div>\\n                  </div>\\n                )\\n              })}\\n            </div>\\n          )}\\n        </div>\\n\\n        <div className=\\\"flex-shrink-0 border-t border-[var(--border-subtle)] bg-[var(--surface-raised)]\\\">\\n          <div className=\\\"p-3\\\">\\n            <div className=\\\"relative flex items-end gap-2\\\">\\n              <div className=\\\"flex-1 bg-[var(--surface-base)] border border-[var(--border-default)] rounded-md focus-within:ring-2 focus-within:ring-[var(--focus-ring)]\\\">\\n                <textarea\\n                  ref={textareaRef}\\n                  value={input}\\n                  onChange={(e) => setInput(e.target.value)}\\n                  onInput={autoSizeTextarea}\\n                  onKeyDown={handleTextareaKeyDown}\\n                  className=\\\"w-full resize-none bg-transparent px-3 py-2 text-[var(--text-primary)] outline-none\\\"\\n                  placeholder={isConfigured ? 'Type your message…' : 'You can compose a message and reference files (@) and tasks/features (#) even before configuring. Configure LLM to send.'}\\n                  rows={1}\\n                  aria-label=\\\"Message input\\\"\\n                  style={{ maxHeight: 200, overflowY: 'auto' }}\\n                />\\n                <div className=\\\"px-3 py-1 border-t border-[var(--border-subtle)]\\\">\\n                  {pendingAttachments.length > 0 && (\\n                    <div className=\\\"mb-1 flex flex-wrap gap-1\\\">\\n                      {pendingAttachments.map((path, idx) => {\\n                        const meta = filesByPath[path]\\n                        const name = meta?.name || (path.split('/').pop() || path)\\n                        const type = meta?.type || inferFileType(path)\\n                        const size = meta?.size ?? undefined\\n                        const mtime = meta?.mtime ?? undefined\\n                        return (\\n                          <div key={`${idx}-${path}`} className=\\\"inline-flex items-center gap-1\\\">\\n                            <FileDisplay\\n                              file={{ name, path, type, size, mtime }}\\n                              density=\\\"compact\\\"\\n                              interactive\\n                              showPreviewOnHover\\n                            />\\n                            <button\\n                              type=\\\"button\\\"\\n                              className=\\\"btn-secondary\\\"\\n                              aria-label={`Remove ${name}`}\\n                              onClick={() => setPendingAttachments((prev) => prev.filter((p) => p !== path))}\\n                            >\\n                              ✕\\n                            </button>\\n                          </div>\\n                        )}\\n                      )}\\n                    </div>\\n                  )}\\n                  <div className=\\\"flex items-center justify-between text-[12px] text-[var(--text-muted)]\\\">\\n                    <div className=\\\"flex items-center gap-2\\\">\\n                      <button\\n                        onClick={() => fileInputRef.current?.click()}\\n                        className=\\\"btn-secondary\\\"\\n                        aria-label=\\\"Attach a document\\\"\\n                        type=\\\"button\\\"\\n                      >\\n                        Attach\\n                      </button>\\n                      <input\\n                        type=\\\"file\\\"\\n                        accept=\\\".md,.txt,.json,.js,.jsx,.ts,.tsx,.css,.scss,.less,.html,.htm,.xml,.yml,.yaml,.csv,.log,.sh,.bash,.zsh,.bat,.ps1,.py,.rb,.java,.kt,.go,.rs,.c,.h,.cpp,.hpp,.m,.swift,.ini,.conf,.env\\\"\\n                        ref={fileInputRef}\\n                        style={{ display: 'none' }}\\n                        onChange={handleFileUpload}\\n                      />\\n                      <span className=\\\"hidden sm:inline\\\">Tip: Use @ for files • Use # for tasks and features</span>\\n                    </div>\\n                    <span>Cmd/Ctrl+Enter to send • Shift+Enter for newline</span>\\n                  </div>\\n                </div>\\n              </div>\\n\\n              <button onClick={handleSend} className=\\\"btn\\\" disabled={!canSend} aria-label=\\\"Send message\\\">\\n                Send\\n              </button>\\n\\n              {isAutocompleteOpen && autocompletePosition && (\\n                <div\\n                  className=\\\"fixed z-[var(--z-dropdown,1000)] min-w-[260px] max-h-[220px] overflow-auto rounded-md border border-[var(--border-default)] bg-[var(--surface-overlay)] shadow-[var(--shadow-3)] p-1\\\"\\n                  style={{ left: `${autocompletePosition.left}px`, top: `${autocompletePosition.top}px`, transform: 'translateY(-100%)' }}\\n                  role=\\\"listbox\\\"\\n                  aria-label=\\\"Files suggestions\\\"\\n                >\\n                  {matchingDocs.map((path, idx) => {\\n                    const meta = filesByPath[path]\\n                    const name = meta?.name || (path.split('/').pop() || path)\\n                    const type = meta?.type || inferFileType(path)\\n                    const size = meta?.size ?? undefined\\n                    const mtime = meta?.mtime ?? undefined\\n                    return (\\n                      <div key={idx} role=\\\"option\\\" className=\\\"px-1 py-0.5\\\">\\n                        <FileDisplay\\n                          file={{ name, path, type, size, mtime }}\\n                          density=\\\"compact\\\"\\n                          interactive\\n                          showPreviewOnHover\\n                          onClick={() => onAutocompleteSelect(path)}\\n                        />\\n                      </div>\\n                    )\\n                  })}\\n                </div>\\n              )}\\n\\n              {isRefsOpen && refsPosition && (\\n                <div\\n                  className=\\\"fixed z-[var(--z-dropdown,1000)] min-w-[260px] max-h-[220px] overflow-auto rounded-md border border-[var(--border-default)] bg-[var(--surface-overlay)] shadow-[var(--shadow-3)]\\\"\\n                  style={{ left: `${refsPosition.left}px`, top: `${refsPosition.top}px`, transform: 'translateY(-100%)' }}\\n                  role=\\\"listbox\\\"\\n                  aria-label=\\\"References suggestions\\\"\\n                >\\n                  {matchingRefs.map((item, idx) => (\\n                    <div\\n                      key={idx}\\n                      className=\\\"px-3 py-2 cursor-pointer hover:bg-[color-mix(in_srgb,var(--accent-primary)_8%,transparent)] text-[var(--text-primary)]\\\"\\n                      role=\\\"option\\\"\\n                      onClick={() => onRefsSelect(item.ref)}\\n                    >\\n                      #{item.display} - {item.title} ({item.type})\\n                    </div>\\n                  ))}\\n                </div>\\n              )}\\n            </div>\\n          </div>\\n        </div>\\n      </section>\\n    </CollapsibleSidebar>\\n  )\\n}\\n\",\"src/renderer/components/ui/FileMentionsTextarea.tsx\":\"import React, { useMemo, useRef } from 'react'\\nimport useFiles from '../../hooks/useFiles'\\nimport { useFilesAutocomplete } from '../../hooks/useFilesAutocomplete'\\n\\nexport type FileMentionsTextareaProps = {\\n  id?: string\\n  value: string\\n  onChange: (val: string) => void\\n  placeholder?: string\\n  rows?: number\\n  disabled?: boolean\\n  className?: string\\n  style?: React.CSSProperties\\n  ariaLabel?: string\\n  onFileMentionSelected?: (path: string) => void\\n}\\n\\nexport default function FileMentionsTextarea({\\n  id,\\n  value,\\n  onChange,\\n  placeholder,\\n  rows = 3,\\n  disabled,\\n  className,\\n  style,\\n  ariaLabel,\\n  onFileMentionSelected,\\n}: FileMentionsTextareaProps) {\\n  const { files } = useFiles()\\n  const textareaRef = useRef<HTMLTextAreaElement>(null)\\n  const mirrorRef = useRef<HTMLDivElement>(null)\\n\\n  const filesList = useMemo(() => files.map((f) => f.path), [files])\\n\\n  const { isOpen, matches, position, onSelect } = useFilesAutocomplete({\\n    filesList,\\n    input: value,\\n    setInput: onChange,\\n    textareaRef,\\n    mirrorRef,\\n  })\\n\\n  const handleSelect = (path: string) => {\\n    onSelect(path)\\n    if (onFileMentionSelected) onFileMentionSelected(path)\\n  }\\n\\n  return (\\n    <div className=\\\"relative\\\">\\n      <div\\n        ref={mirrorRef}\\n        aria-hidden=\\\"true\\\"\\n        className=\\\"absolute top-[-9999px] left-0 overflow-hidden whitespace-pre-wrap break-words pointer-events-none\\\"\\n      />\\n      <textarea\\n        id={id}\\n        ref={textareaRef}\\n        value={value}\\n        onChange={(e) => onChange(e.target.value)}\\n        placeholder={placeholder}\\n        rows={rows}\\n        disabled={disabled}\\n        className={className}\\n        style={style}\\n        aria-label={ariaLabel}\\n      />\\n\\n      {isOpen && position && (\\n        <div\\n          className=\\\"fixed z-[var(--z-dropdown,1000)] min-w-[260px] max-h-[220px] overflow-auto rounded-md border border-[var(--border-default)] bg-[var(--surface-overlay)] shadow-[var(--shadow-3)]\\\"\\n          style={{ left: `${position.left}px`, top: `${position.top}px`, transform: 'translateY(-100%)' }}\\n          role=\\\"listbox\\\"\\n          aria-label=\\\"Files suggestions\\\"\\n        >\\n          {matches.map((path, idx) => (\\n            <div\\n              key={idx}\\n              role=\\\"option\\\"\\n              className=\\\"px-3 py-2 cursor-pointer hover:bg-[color-mix(in_srgb,var(--accent-primary)_8%,transparent)] text-[var(--text-primary)] text-sm\\\"\\n              onClick={() => handleSelect(path)}\\n            >\\n              {path}\\n            </div>\\n          ))}\\n        </div>\\n      )}\\n    </div>\\n  )\\n}\\n\",\"src/renderer/hooks/useFilesAutocomplete.ts\":\"import { useEffect, useState } from 'react';\\n\\nexport function useFilesAutocomplete(params: {\\n  filesList: string[];\\n  input: string;\\n  setInput: (v: string) => void;\\n  textareaRef: React.RefObject<HTMLTextAreaElement>;\\n  mirrorRef: React.RefObject<HTMLDivElement>;\\n}) {\\n  const { filesList, input, setInput, textareaRef, mirrorRef } = params;\\n  const [isOpen, setIsOpen] = useState(false);\\n  const [matches, setMatches] = useState<string[]>([]);\\n  const [mentionStart, setMentionStart] = useState<number | null>(null);\\n  const [position, setPosition] = useState<{ left: number; top: number } | null>(null);\\n  const [caretPos, setCaretPos] = useState<number>(0);\\n\\n  function getCursorCoordinates(textarea: HTMLTextAreaElement, pos: number) {\\n    const mirror = mirrorRef.current;\\n    if (!mirror) return { x: 0, y: 0 };\\n\\n    const style = window.getComputedStyle(textarea);\\n    const stylesToCopy = [\\n      'boxSizing','borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth','fontFamily','fontSize','fontStyle','fontWeight','letterSpacing','lineHeight','paddingBottom','paddingLeft','paddingRight','paddingTop','textDecoration','textTransform','width'\\n    ] as const;\\n    stylesToCopy.forEach((key) => { (mirror.style as any)[key] = (style as any)[key]; });\\n    mirror.style.overflowWrap = 'break-word';\\n    mirror.style.whiteSpace = 'pre-wrap';\\n    mirror.style.wordBreak = 'break-word';\\n    mirror.style.height = 'auto';\\n\\n    mirror.textContent = input.slice(0, pos);\\n\\n    const marker = document.createElement('span');\\n    marker.style.display = 'inline-block';\\n    marker.style.width = '0';\\n    marker.textContent = '';\\n    mirror.appendChild(marker);\\n\\n    const mirrorRect = mirror.getBoundingClientRect();\\n    const markerRect = marker.getBoundingClientRect();\\n\\n    const x = markerRect.left - mirrorRect.left;\\n    const y = markerRect.top - mirrorRect.top;\\n\\n    mirror.textContent = '';\\n\\n    return { x, y };\\n  }\\n\\n  const checkForMention = (text: string, pos: number) => {\\n    let start = pos;\\n    while (start > 0 && text[start - 1] !== ' ' && text[start - 1] !== '\\\\n') {\\n      start--;\\n    }\\n    const word = text.slice(start, pos);\\n    if (word.startsWith('@')) {\\n      const query = word.slice(1);\\n      const filtered = filesList.filter((p) => p.toLowerCase().includes(query.toLowerCase()));\\n      setMatches(filtered);\\n      setMentionStart(start);\\n      if (filtered.length > 0) {\\n        const textarea = textareaRef.current!;\\n        const coords = getCursorCoordinates(textarea, pos);\\n        const textareaRect = textarea.getBoundingClientRect();\\n        const cursorLeft = textareaRect.left + coords.x;\\n        const topAboveTextarea = textareaRect.top + window.scrollY - 8; // 8px gap above input\\n        setPosition({ left: cursorLeft, top: topAboveTextarea });\\n        setIsOpen(true);\\n        return;\\n      }\\n    }\\n    setIsOpen(false);\\n  };\\n\\n  const onSelect = (path: string) => {\\n    const textarea = textareaRef.current;\\n    if (!textarea || mentionStart === null) return;\\n    const currentText = textarea.value;\\n    const currentPos = textarea.selectionStart;\\n    const before = currentText.slice(0, mentionStart);\\n    const after = currentText.slice(currentPos);\\n    const newText = `${before}@${path} ${after}`;\\n    setInput(newText);\\n    const newPos = before.length + 1 + path.length;\\n    setTimeout(() => {\\n      textarea.focus();\\n      textarea.setSelectionRange(newPos, newPos);\\n    }, 0);\\n    setIsOpen(false);\\n    setMentionStart(null);\\n  };\\n\\n  useEffect(() => {\\n    const handleSelectionChange = () => {\\n      const ta = textareaRef.current;\\n      if (!ta) return;\\n      if (document.activeElement === ta) {\\n        try {\\n          setCaretPos(ta.selectionStart ?? 0);\\n        } catch {\\n          // ignore\\n        }\\n      }\\n    };\\n    document.addEventListener('selectionchange', handleSelectionChange);\\n    return () => document.removeEventListener('selectionchange', handleSelectionChange);\\n  }, [textareaRef]);\\n\\n  // Compute suggestions purely from the controlled input and current caret position\\n  // Avoid including 'matches' in deps to prevent update loops when matches state updates\\n  useEffect(() => {\\n    const textarea = textareaRef.current;\\n    if (!textarea) return;\\n    const pos = textarea.selectionStart ?? caretPos;\\n    checkForMention(input, pos);\\n  }, [input, caretPos]);\\n\\n  return { isOpen, matches, position, onSelect };\\n}\\n\",\"src/renderer/hooks/useReferencesAutocomplete.ts\":\"import { useEffect, useMemo, useState } from 'react';\\nimport { useTasks } from './useTasks';\\nimport { useActiveProject } from '../projects/ProjectContext';\\n\\ntype RefItem = {\\n  ref: string;\\n  display: string;\\n  title: string;\\n  type: 'task' | 'feature';\\n};\\n\\nexport function useReferencesAutocomplete(params: {\\n  input: string;\\n  setInput: (v: string) => void;\\n  textareaRef: React.RefObject<HTMLTextAreaElement>;\\n  mirrorRef: React.RefObject<HTMLDivElement>;\\n}) {\\n  const { project } = useActiveProject();\\n  const { input, setInput, textareaRef, mirrorRef } = params;\\n  const { tasksById } = useTasks();\\n\\n  const references = useMemo<RefItem[]>(() => {\\n    if (!project) { return [] }\\n    const refs: RefItem[] = [];\\n    Object.values(tasksById).forEach((task) => {\\n      const taskDisplay = `${project.taskIdToDisplayIndex[task.id]}`\\n      refs.push({ ref: `${task.id}`, display: taskDisplay, title: task.title, type: 'task' });\\n      (task.features || []).forEach((f) => {\\n        const featureDisplay = `${task.featureIdToDisplayIndex[f.id]}`\\n        refs.push({ ref: `${task.id}.${f.id}`, display: `${taskDisplay}.${featureDisplay}`, title: f.title, type: 'feature' });\\n      });\\n    });\\n    return refs.sort((a, b) => a.ref.localeCompare(b.ref));\\n  }, [tasksById, project]);\\n\\n  const [isOpen, setIsOpen] = useState(false);\\n  const [matches, setMatches] = useState<RefItem[]>([]);\\n  const [mentionStart, setMentionStart] = useState<number | null>(null);\\n  const [position, setPosition] = useState<{ left: number; top: number } | null>(null);\\n  const [caretPos, setCaretPos] = useState<number>(0);\\n\\n  function getCursorCoordinates(textarea: HTMLTextAreaElement, pos: number) {\\n    const mirror = mirrorRef.current;\\n    if (!mirror) return { x: 0, y: 0 };\\n\\n    const style = window.getComputedStyle(textarea);\\n    const stylesToCopy = [\\n      'boxSizing',\\n      'borderBottomWidth',\\n      'borderLeftWidth',\\n      'borderRightWidth',\\n      'borderTopWidth',\\n      'fontFamily',\\n      'fontSize',\\n      'fontStyle',\\n      'fontWeight',\\n      'letterSpacing',\\n      'lineHeight',\\n      'paddingBottom',\\n      'paddingLeft',\\n      'paddingRight',\\n      'paddingTop',\\n      'textDecoration',\\n      'textTransform',\\n      'width',\\n    ] as const;\\n    stylesToCopy.forEach((key) => {\\n      (mirror.style as any)[key] = (style as any)[key];\\n    });\\n    mirror.style.overflowWrap = 'break-word';\\n    mirror.style.whiteSpace = 'pre-wrap';\\n    mirror.style.wordBreak = 'break-word';\\n    mirror.style.height = 'auto';\\n\\n    mirror.textContent = input.slice(0, pos);\\n\\n    const marker = document.createElement('span');\\n    marker.style.display = 'inline-block';\\n    marker.style.width = '0';\\n    marker.textContent = '';\\n    mirror.appendChild(marker);\\n\\n    const mirrorRect = mirror.getBoundingClientRect();\\n    const markerRect = marker.getBoundingClientRect();\\n\\n    const x = markerRect.left - mirrorRect.left;\\n    const y = markerRect.top - mirrorRect.top;\\n\\n    mirror.textContent = '';\\n\\n    return { x, y };\\n  }\\n\\n  const isBoundaryChar = (ch: string) => {\\n    return /[\\\\s\\\\n\\\\t\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}<>,.!?:;\\\"'`]/.test(ch);\\n  };\\n\\n  const checkForMention = (text: string, pos: number) => {\\n    let start = pos;\\n    while (start > 0 && !isBoundaryChar(text[start - 1])) {\\n      start--;\\n    }\\n    const word = text.slice(start, pos);\\n\\n    if (word.startsWith('#')) {\\n      const query = word.slice(1).toLowerCase();\\n      const filtered = references.filter(\\n        (item) => item.display.toLowerCase().startsWith(query) || item.title.toLowerCase().includes(query)\\n      );\\n      setMatches(filtered);\\n      setMentionStart(start);\\n\\n      const textarea = textareaRef.current!;\\n      const coords = getCursorCoordinates(textarea, pos);\\n      const textareaRect = textarea.getBoundingClientRect();\\n      const cursorLeft = textareaRect.left + window.scrollX + coords.x;\\n      const topAboveTextarea = textareaRect.top + window.scrollY - 8;\\n      setPosition({ left: cursorLeft, top: topAboveTextarea });\\n      setIsOpen(true);\\n      return;\\n    }\\n\\n    setIsOpen(false);\\n    setMentionStart(null);\\n  };\\n\\n  const onSelect = (selectedRef: string) => {\\n    const textarea = textareaRef.current;\\n    if (!textarea || mentionStart === null) return;\\n    const currentText = textarea.value;\\n    const currentPos = textarea.selectionStart;\\n    const before = currentText.slice(0, mentionStart);\\n    const after = currentText.slice(currentPos);\\n    const newText = `${before}#${selectedRef}${after}`;\\n    setInput(newText);\\n    const newPos = before.length + 1 + selectedRef.length;\\n    setTimeout(() => {\\n      textarea.focus();\\n      textarea.setSelectionRange(newPos, newPos);\\n    }, 0);\\n    setIsOpen(false);\\n    setMentionStart(null);\\n  };\\n\\n  useEffect(() => {\\n    const handleSelectionChange = () => {\\n      const ta = textareaRef.current;\\n      if (!ta) return;\\n      if (document.activeElement === ta) {\\n        try {\\n          setCaretPos(ta.selectionStart ?? 0);\\n        } catch {\\n          // ignore\\n        }\\n      }\\n    };\\n    document.addEventListener('selectionchange', handleSelectionChange);\\n    return () => document.removeEventListener('selectionchange', handleSelectionChange);\\n  }, [textareaRef]);\\n\\n  useEffect(() => {\\n    const textarea = textareaRef.current;\\n    if (!textarea) return;\\n    const pos = textarea.selectionStart ?? caretPos;\\n    checkForMention(input, pos);\\n    // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, [input, references, caretPos]);\\n\\n  return { isOpen, matches, position, onSelect };\\n}\\n\",\"src/renderer/components/tasks/FeatureForm.tsx\":\"import React, { useEffect, useMemo, useRef, useState } from 'react'\\nimport type { Status } from 'packages/factory-ts/src/types'\\nimport StatusControl from './StatusControl'\\nimport { DependencySelector } from './DependencySelector'\\nimport DependencyBullet from './DependencyBullet'\\nimport { FileSelector } from '../ui/FileSelector'\\nimport ContextFileChip from './ContextFileChip'\\nimport { Modal } from '../ui/Modal'\\nimport { IconDelete, IconPlus } from '../ui/Icons'\\nimport FileMentionsTextarea from '../ui/FileMentionsTextarea'\\n\\nexport type FeatureFormValues = {\\n  title: string\\n  description?: string\\n  rejection?: string\\n  status: Status\\n  blockers?: string[]\\n  context: string[]\\n}\\n\\ntype Props = {\\n  initialValues?: Partial<FeatureFormValues>\\n  onSubmit: (values: FeatureFormValues) => void | Promise<void>\\n  onCancel: () => void\\n  onDelete?: () => void\\n  submitting?: boolean\\n  titleRef?: React.RefObject<HTMLInputElement>\\n  taskId: string\\n  featureId?: string\\n}\\n\\nexport default function FeatureForm({\\n  initialValues,\\n  onSubmit,\\n  onCancel,\\n  onDelete,\\n  submitting = false,\\n  titleRef,\\n  taskId,\\n  featureId = undefined,\\n}: Props) {\\n  const [title, setTitle] = useState<string>(initialValues?.title ?? '')\\n  const [description, setDescription] = useState<string>(initialValues?.description ?? '')\\n  const [rejection, setRejection] = useState<string>(initialValues?.rejection ?? '')\\n  const [status, setStatus] = useState<Status>(initialValues?.status ?? '-')\\n  const [blockers, setBlockers] = useState<string[]>(initialValues?.blockers ?? [])\\n  const [context, setContext] = useState<string[]>(initialValues?.context ?? [])\\n  const [error, setError] = useState<string | null>(null)\\n  const [showSelector, setShowSelector] = useState(false)\\n  const [showFileSelector, setShowFileSelector] = useState(false)\\n\\n  const localTitleRef = useRef<HTMLInputElement>(null)\\n  const combinedTitleRef = titleRef ?? localTitleRef\\n  const isCreate = !(featureId !== null && featureId !== undefined)\\n\\n  useEffect(() => {\\n    if (combinedTitleRef?.current) {\\n      combinedTitleRef.current.focus()\\n      combinedTitleRef.current.select?.()\\n    }\\n  }, [combinedTitleRef])\\n\\n  const canSubmit = useMemo(() => title.trim().length > 0 && !submitting, [title, submitting])\\n\\n  function validate(): boolean {\\n    let valid = true\\n    if (!title.trim()) {\\n      setError('Title is required')\\n      valid = false\\n    } else {\\n      setError(null)\\n    }\\n\\n    return valid\\n  }\\n\\n  async function handleSubmit(e?: React.FormEvent) {\\n    e?.preventDefault()\\n    if (!validate()) return\\n    const payload: FeatureFormValues = {\\n      title: title.trim(),\\n      description: description?.trim() || '',\\n      rejection: rejection?.trim() || undefined,\\n      status,\\n      blockers,\\n      context,\\n    }\\n    await onSubmit(payload)\\n  }\\n\\n  function onKeyDown(e: React.KeyboardEvent) {\\n    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'enter') {\\n      e.preventDefault()\\n      if (canSubmit) handleSubmit()\\n    }\\n  }\\n\\n  function removeBlockerAt(idx: number) {\\n    setBlockers((deps) => deps.filter((_, i) => i !== idx))\\n  }\\n\\n  function removeContextAt(idx: number) {\\n    setContext((ctx) => ctx.filter((_, i) => i !== idx))\\n  }\\n\\n  const combinedTextForMentions = `${title}\\\\n${description}\\\\n${rejection}`\\n  const mentionedPaths = useMemo(() => {\\n    const res = new Set<string>()\\n    for (const p of context) {\\n      if (combinedTextForMentions.includes(`@${p}`)) res.add(p)\\n    }\\n    return res\\n  }, [combinedTextForMentions, context])\\n\\n  const handleFileMentionSelected = (path: string) => {\\n    setContext((prev) => (prev.includes(path) ? prev : [...prev, path]))\\n  }\\n\\n  return (\\n    <form onSubmit={handleSubmit} onKeyDown={onKeyDown} className=\\\"space-y-4\\\" aria-label={isCreate ? 'Create Feature' : 'Edit Feature'}>\\n      <div className=\\\"grid grid-cols-1 gap-3\\\">\\n        <StatusControl\\n          status={status}\\n          onChange={setStatus}\\n        />\\n        <div className=\\\"flex items-center gap-3\\\">\\n          <label htmlFor=\\\"feature-title\\\" className=\\\"text-xs flex-1\\\" style={{ color: 'var(--text-secondary)' }}>Title</label>\\n        </div>\\n        <input\\n          id=\\\"feature-title\\\"\\n          ref={combinedTitleRef}\\n          type=\\\"text\\\"\\n          placeholder=\\\"What is this feature?\\\"\\n          value={title}\\n          onChange={(e) => setTitle(e.target.value)}\\n          disabled={submitting}\\n          className=\\\"w-full rounded-md border px-3 py-2 text-sm disabled:opacity-60\\\"\\n          style={{\\n            background: 'var(--surface-raised)',\\n            borderColor: error ? 'var(--status-stuck-soft-border)' : 'var(--border-default)',\\n            color: 'var(--text-primary)'\\n          }}\\n          aria-invalid={!!error}\\n          aria-describedby={error ? 'feature-title-error' : undefined}\\n        />\\n        {error ? (\\n          <div id=\\\"feature-title-error\\\" className=\\\"text-xs\\\" style={{ color: 'var(--status-stuck-fg)' }}>{error}</div>\\n        ) : null}\\n\\n        <div className=\\\"flex flex-col gap-1\\\">\\n          <label htmlFor=\\\"feature-description\\\" className=\\\"text-xs\\\" style={{ color: 'var(--text-secondary)' }}>Description</label>\\n          <FileMentionsTextarea\\n            id=\\\"feature-description\\\"\\n            rows={4}\\n            placeholder=\\\"Optional details or acceptance criteria\\\"\\n            value={description}\\n            onChange={setDescription}\\n            disabled={submitting}\\n            className=\\\"w-full rounded-md border px-3 py-2 text-sm disabled:opacity-60 resize-y max-h-64\\\"\\n            style={{ background: 'var(--surface-raised)', borderColor: 'var(--border-default)', color: 'var(--text-primary)' }}\\n            ariaLabel=\\\"Feature description\\\"\\n            onFileMentionSelected={handleFileMentionSelected}\\n          />\\n        </div>\\n\\n        <div className=\\\"flex flex-col gap-1\\\">\\n          <label htmlFor=\\\"feature-rejection\\\" className=\\\"text-xs\\\" style={{ color: 'var(--text-secondary)' }}>Rejection Reason</label>\\n          <FileMentionsTextarea\\n            id=\\\"feature-rejection\\\"\\n            rows={3}\\n            placeholder=\\\"Optional reason for rejection (leave blank to remove)\\\"\\n            value={rejection}\\n            onChange={setRejection}\\n            disabled={submitting}\\n            className=\\\"w-full rounded-md border px-3 py-2 text-sm disabled:opacity-60 resize-y max-h-64\\\"\\n            style={{ background: 'var(--surface-raised)', borderColor: 'var(--border-default)', color: 'var(--text-primary)' }}\\n            ariaLabel=\\\"Feature rejection reason\\\"\\n            onFileMentionSelected={handleFileMentionSelected}\\n          />\\n        </div>\\n\\n        <div className=\\\"flex flex-col gap-1\\\">\\n          <label className=\\\"text-xs\\\" style={{ color: 'var(--text-secondary)' }}>Context Files</label>\\n          <div className=\\\"flex flex-wrap items-start gap-2 border rounded-md min-h-[3rem] p-2\\\" style={{ borderColor: 'var(--border-default)', background: 'var(--surface-raised)' }}>\\n            {context.map((p, idx) => (\\n              <ContextFileChip key={p} path={p} onRemove={() => removeContextAt(idx)} warn={!mentionedPaths.has(p)} />\\n            ))}\\n            <button type=\\\"button\\\" onClick={() => setShowFileSelector(true)} className=\\\"chip chip--ok\\\" title=\\\"Add context files\\\">\\n              <IconPlus className=\\\"w-3 h-3\\\" />\\n              <span>Add</span>\\n            </button>\\n          </div>\\n          <div className=\\\"text-xs text-text-muted\\\">Select any files across the project that provide useful context for this feature. Tip: type @ in description to quickly reference files.</div>\\n        </div>\\n\\n        <div className=\\\"flex flex-col gap-1\\\">\\n          <label htmlFor=\\\"feature-blockers\\\" className=\\\"text-xs\\\" style={{ color: 'var(--text-secondary)' }}>Blockers</label>\\n          <div\\n            id=\\\"feature-blockers\\\"\\n            className=\\\"chips-list border rounded-md min-h-[3rem] p-2\\\"\\n            style={{\\n              borderColor: 'var(--border-default)',\\n              background: 'var(--surface-raised)'\\n            }}\\n          >\\n            {blockers.map((dep, idx) => {\\n              return (\\n                <DependencyBullet key={dep} dependency={dep} onRemove={() => removeBlockerAt(idx)} />\\n              )\\n            })}\\n            <button\\n              type=\\\"button\\\"\\n              onClick={() => setShowSelector(true)}\\n              className=\\\"chip chip--ok\\\"\\n              title=\\\"Add blocker\\\"\\n            >\\n              <IconPlus className=\\\"w-3 h-3\\\" />\\n              <span>Add</span>\\n            </button>\\n          </div>\\n        </div>\\n      </div>\\n\\n      <div className=\\\"flex justify-between gap-2 pt-2\\\">\\n        {onDelete && !isCreate ? (\\n          <button\\n            type=\\\"button\\\"\\n            onClick={onDelete}\\n            disabled={submitting}\\n            className=\\\"btn\\\"\\n            style={{\\n              background: 'var(--status-stuck-bg)',\\n              color: 'var(--status-stuck-fg)'\\n            }}\\n          >\\n            <IconDelete className=\\\"w-4 h-4\\\" />\\n            Delete\\n          </button>\\n        ) : null}\\n        <div className=\\\"flex justify-end gap-2 flex-1\\\">\\n          <button\\n            type=\\\"button\\\"\\n            className=\\\"btn-secondary\\\"\\n            onClick={() => onCancel()}\\n            disabled={submitting}\\n          >\\n            Cancel\\n          </button>\\n          <button\\n            type=\\\"submit\\\"\\n            className=\\\"btn\\\"\\n            disabled={!canSubmit}\\n            aria-keyshortcuts=\\\"Control+Enter Meta+Enter\\\"\\n            title=\\\"Cmd/Ctrl+Enter to submit\\\"\\n          >\\n            {isCreate ? 'Create Feature' : 'Save Changes'}\\n          </button>\\n        </div>\\n      </div>\\n\\n      {showSelector && (\\n        <Modal title=\\\"Select Blocker\\\" onClose={() => setShowSelector(false)} isOpen={true} size=\\\"md\\\">\\n          <DependencySelector\\n            onConfirm={(deps) => {\\n              const newDeps = deps.filter((d) => !blockers.includes(d))\\n              setBlockers([...blockers, ...newDeps])\\n              setShowSelector(false)\\n            }}\\n            currentTaskId={taskId}\\n            currentFeatureId={featureId}\\n            existingDeps={blockers}\\n          />\\n        </Modal>\\n      )}\\n\\n      {showFileSelector && (\\n        <Modal title=\\\"Select Context Files\\\" onClose={() => setShowFileSelector(false)} isOpen={true} size=\\\"lg\\\">\\n          <FileSelector\\n            selected={context}\\n            onCancel={() => setShowFileSelector(false)}\\n            onConfirm={(paths) => {\\n              const unique = Array.from(new Set([...(context || []), ...paths]))\\n              setContext(unique)\\n              setShowFileSelector(false)\\n            }}\\n            allowMultiple\\n          />\\n        </Modal>\\n      )}\\n    </form>\\n  )\\n}\\n\"}\n\nBegin now."
  },
  {
    "role": "assistant",
    "content": "{\n  \"thoughts\": \"I will extend the existing FileMentionsTextarea to support both file (@) and reference (#) lookups and expose callbacks for selection. Then I will wire these callbacks in FeatureForm to add to context (files) and blockers (references) and implement syncing so removing mentions from the text removes the corresponding entries. ChatView already supports both autocompletes, so no change there. I'll update FeatureForm to use the new reference callback and implement synchronization logic for context and blockers on text changes.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"read_files\",\n      \"arguments\": {\n        \"paths\": [\n          \"src/renderer/components/ui/FileMentionsTextarea.tsx\",\n          \"src/renderer/hooks/useReferencesAutocomplete.ts\",\n          \"src/renderer/hooks/useFilesAutocomplete.ts\",\n          \"src/renderer/components/tasks/FeatureForm.tsx\",\n          \"src/renderer/screens/ChatView.tsx\"\n        ]\n      }\n    },\n    {\n      \"tool_name\": \"write_file\",\n      \"arguments\": {\n        \"filename\": \"src/renderer/components/ui/FileMentionsTextarea.tsx\",\n        \"content\": \"import React, { useMemo, useRef } from 'react'\\nimport useFiles from '../../hooks/useFiles'\\nimport { useFilesAutocomplete } from '../../hooks/useFilesAutocomplete'\\nimport { useReferencesAutocomplete } from '../../hooks/useReferencesAutocomplete'\\nimport FileDisplay from './FileDisplay'\\nimport { inferFileType } from '../../hooks/useFiles'\\n\\nexport type FileMentionsTextareaProps = {\\n  id?: string\\n  value: string\\n  onChange: (val: string) => void\\n  placeholder?: string\\n  rows?: number\\n  disabled?: boolean\\n  className?: string\\n  style?: React.CSSProperties\\n  ariaLabel?: string\\n  onFileMentionSelected?: (path: string) => void\\n  onReferenceSelected?: (ref: string) => void\\n}\\n\\nexport default function FileMentionsTextarea({\\n  id,\\n  value,\\n  onChange,\\n  placeholder,\\n  rows = 3,\\n  disabled,\\n  className,\\n  style,\\n  ariaLabel,\\n  onFileMentionSelected,\\n  onReferenceSelected,\\n}: FileMentionsTextareaProps) {\\n  const { files, filesByPath } = useFiles()\\n  const textareaRef = useRef<HTMLTextAreaElement>(null)\\n  const mirrorRef = useRef<HTMLDivElement>(null)\\n\\n  const filesList = useMemo(() => files.map((f) => f.path), [files])\\n\\n  const {\\n    isOpen: isFilesOpen,\\n    matches: fileMatches,\\n    position: filesPosition,\\n    onSelect: onFileSelectInternal,\\n  } = useFilesAutocomplete({\\n    filesList,\\n    input: value,\\n    setInput: onChange,\\n    textareaRef,\\n    mirrorRef,\\n  })\\n\\n  const {\\n    isOpen: isRefsOpen,\\n    matches: refMatches,\\n    position: refsPosition,\\n    onSelect: onRefSelectInternal,\\n  } = useReferencesAutocomplete({\\n    input: value,\\n    setInput: onChange,\\n    textareaRef,\\n    mirrorRef,\\n  })\\n\\n  const handleFileSelect = (path: string) => {\\n    onFileSelectInternal(path)\\n    if (onFileMentionSelected) onFileMentionSelected(path)\\n  }\\n\\n  const handleRefSelect = (ref: string) => {\\n    onRefSelectInternal(ref)\\n    if (onReferenceSelected) onReferenceSelected(ref)\\n  }\\n\\n  return (\\n    <div className=\\\"relative\\\">\\n      <div\\n        ref={mirrorRef}\\n        aria-hidden=\\\"true\\\"\\n        className=\\\"absolute top-[-9999px] left-0 overflow-hidden whitespace-pre-wrap break-words pointer-events-none\\\"\\n      />\\n      <textarea\\n        id={id}\\n        ref={textareaRef}\\n        value={value}\\n        onChange={(e) => onChange(e.target.value)}\\n        placeholder={placeholder}\\n        rows={rows}\\n        disabled={disabled}\\n        className={className}\\n        style={style}\\n        aria-label={ariaLabel}\\n      />\\n\\n      {isFilesOpen && filesPosition && (\\n        <div\\n          className=\\\"fixed z-[var(--z-dropdown,1000)] min-w-[260px] max-h-[220px] overflow-auto rounded-md border border-[var(--border-default)] bg-[var(--surface-overlay)] shadow-[var(--shadow-3)] p-1\\\"\\n          style={{ left: `${filesPosition.left}px`, top: `${filesPosition.top}px`, transform: 'translateY(-100%)' }}\\n          role=\\\"listbox\\\"\\n          aria-label=\\\"Files suggestions\\\"\\n        >\\n          {fileMatches.map((path, idx) => {\\n            const meta = filesByPath[path]\\n            const name = meta?.name || (path.split('/').pop() || path)\\n            const type = meta?.type || inferFileType(path)\\n            const size = meta?.size ?? undefined\\n            const mtime = meta?.mtime ?? undefined\\n            return (\\n              <div key={idx} role=\\\"option\\\" className=\\\"px-1 py-0.5\\\">\\n                <FileDisplay\\n                  file={{ name, path, type, size, mtime }}\\n                  density=\\\"compact\\\"\\n                  interactive\\n                  showPreviewOnHover\\n                  onClick={() => handleFileSelect(path)}\\n                />\\n              </div>\\n            )\\n          })}\\n        </div>\\n      )}\\n\\n      {isRefsOpen && refsPosition && (\\n        <div\\n          className=\\\"fixed z-[var(--z-dropdown,1000)] min-w-[260px] max-h-[220px] overflow-auto rounded-md border border-[var(--border-default)] bg-[var(--surface-overlay)] shadow-[var(--shadow-3)]\\\"\\n          style={{ left: `${refsPosition.left}px`, top: `${refsPosition.top}px`, transform: 'translateY(-100%)' }}\\n          role=\\\"listbox\\\"\\n          aria-label=\\\"References suggestions\\\"\\n        >\\n          {refMatches.map((item, idx) => (\\n            <div\\n              key={idx}\\n              className=\\\"px-3 py-2 cursor-pointer hover:bg-[color-mix(in_srgb,var(--accent-primary)_8%,transparent)] text-[var(--text-primary)]\\\"\\n              role=\\\"option\\\"\\n              onClick={() => handleRefSelect(item.ref)}\\n            >\\n              #{item.display} - {item.title} ({item.type})\\n            </div>\\n          ))}\\n        </div>\\n      )}\\n    </div>\\n  )\\n}\\n\"\n      }\n    },\n    {\n      \"tool_name\": \"write_file\",\n      \"arguments\": {\n        \"filename\": \"src/renderer/components/tasks/FeatureForm.tsx\",\n        \"content\": \"import React, { useEffect, useMemo, useRef, useState } from 'react'\\nimport type { Status } from 'packages/factory-ts/src/types'\\nimport StatusControl from './StatusControl'\\nimport { DependencySelector } from './DependencySelector'\\nimport DependencyBullet from './DependencyBullet'\\nimport { FileSelector } from '../ui/FileSelector'\\nimport ContextFileChip from './ContextFileChip'\\nimport { Modal } from '../ui/Modal'\\nimport { IconDelete, IconPlus } from '../ui/Icons'\\nimport FileMentionsTextarea from '../ui/FileMentionsTextarea'\\n\\nexport type FeatureFormValues = {\\n  title: string\\n  description?: string\\n  rejection?: string\\n  status: Status\\n  blockers?: string[]\\n  context: string[]\\n}\\n\\ntype Props = {\\n  initialValues?: Partial<FeatureFormValues>\\n  onSubmit: (values: FeatureFormValues) => void | Promise<void>\\n  onCancel: () => void\\n  onDelete?: () => void\\n  submitting?: boolean\\n  titleRef?: React.RefObject<HTMLInputElement>\\n  taskId: string\\n  featureId?: string\\n}\\n\\nexport default function FeatureForm({\\n  initialValues,\\n  onSubmit,\\n  onCancel,\\n  onDelete,\\n  submitting = false,\\n  titleRef,\\n  taskId,\\n  featureId = undefined,\\n}: Props) {\\n  const [title, setTitle] = useState<string>(initialValues?.title ?? '')\\n  const [description, setDescription] = useState<string>(initialValues?.description ?? '')\\n  const [rejection, setRejection] = useState<string>(initialValues?.rejection ?? '')\\n  const [status, setStatus] = useState<Status>(initialValues?.status ?? '-')\\n  const [blockers, setBlockers] = useState<string[]>(initialValues?.blockers ?? [])\\n  const [context, setContext] = useState<string[]>(initialValues?.context ?? [])\\n  const [error, setError] = useState<string | null>(null)\\n  const [showSelector, setShowSelector] = useState(false)\\n  const [showFileSelector, setShowFileSelector] = useState(false)\\n\\n  const localTitleRef = useRef<HTMLInputElement>(null)\\n  const combinedTitleRef = titleRef ?? localTitleRef\\n  const isCreate = !(featureId !== null && featureId !== undefined)\\n\\n  useEffect(() => {\\n    if (combinedTitleRef?.current) {\\n      combinedTitleRef.current.focus()\\n      combinedTitleRef.current.select?.()\\n    }\\n  }, [combinedTitleRef])\\n\\n  const canSubmit = useMemo(() => title.trim().length > 0 && !submitting, [title, submitting])\\n\\n  function validate(): boolean {\\n    let valid = true\\n    if (!title.trim()) {\\n      setError('Title is required')\\n      valid = false\\n    } else {\\n      setError(null)\\n    }\\n\\n    return valid\\n  }\\n\\n  async function handleSubmit(e?: React.FormEvent) {\\n    e?.preventDefault()\\n    if (!validate()) return\\n    const payload: FeatureFormValues = {\\n      title: title.trim(),\\n      description: description?.trim() || '',\\n      rejection: rejection?.trim() || undefined,\\n      status,\\n      blockers,\\n      context,\\n    }\\n    await onSubmit(payload)\\n  }\\n\\n  function onKeyDown(e: React.KeyboardEvent) {\\n    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'enter') {\\n      e.preventDefault()\\n      if (canSubmit) handleSubmit()\\n    }\\n  }\\n\\n  function removeBlockerAt(idx: number) {\\n    setBlockers((deps) => deps.filter((_, i) => i !== idx))\\n  }\\n\\n  function removeContextAt(idx: number) {\\n    setContext((ctx) => ctx.filter((_, i) => i !== idx))\\n  }\\n\\n  // Compute mentioned items in current text; we treat a reference as any #word pattern (ids like 1 or 1.2)\\n  const combinedTextForMentions = `${title}\\\\n${description}\\\\n${rejection}`\\n\\n  const mentionedPaths = useMemo(() => {\\n    const res = new Set<string>()\\n    for (const p of context) {\\n      if (combinedTextForMentions.includes(`@${p}`)) res.add(p)\\n    }\\n    return res\\n  }, [combinedTextForMentions, context])\\n\\n  // Extract references mentioned in text (#ref) and sync with blockers list\\n  const mentionedRefs = useMemo(() => {\\n    const refs = new Set<string>()\\n    // Simple regex to capture #<alnum or dots and dashes>\\n    const re = /#([A-Za-z0-9_.-]+)/g\\n    let m: RegExpExecArray | null\\n    while ((m = re.exec(combinedTextForMentions)) !== null) {\\n      if (m[1]) refs.add(m[1])\\n    }\\n    return refs\\n  }, [combinedTextForMentions])\\n\\n  // Keep blockers in sync with mentioned refs: add missing, remove unmentioned\\n  useEffect(() => {\\n    setBlockers((prev) => {\\n      const next = new Set(prev)\\n      // add\\n      mentionedRefs.forEach((r) => next.add(r))\\n      // remove any that are not mentioned anymore\\n      for (const r of Array.from(next)) {\\n        if (!mentionedRefs.has(r)) next.delete(r)\\n      }\\n      return Array.from(next)\\n    })\\n  }, [mentionedRefs])\\n\\n  // Keep context in sync with @ mentions: add on select via callback; also remove if no longer mentioned anywhere\\n  useEffect(() => {\\n    setContext((prev) => prev.filter((p) => combinedTextForMentions.includes(`@${p}`)))\\n  }, [combinedTextForMentions])\\n\\n  const handleFileMentionSelected = (path: string) => {\\n    setContext((prev) => (prev.includes(path) ? prev : [...prev, path]))\\n  }\\n\\n  const handleReferenceSelected = (ref: string) => {\\n    setBlockers((prev) => (prev.includes(ref) ? prev : [...prev, ref]))\\n  }\\n\\n  return (\\n    <form onSubmit={handleSubmit} onKeyDown={onKeyDown} className=\\\"space-y-4\\\" aria-label={isCreate ? 'Create Feature' : 'Edit Feature'}>\\n      <div className=\\\"grid grid-cols-1 gap-3\\\">\\n        <StatusControl\\n          status={status}\\n          onChange={setStatus}\\n        />\\n        <div className=\\\"flex items-center gap-3\\\">\\n          <label htmlFor=\\\"feature-title\\\" className=\\\"text-xs flex-1\\\" style={{ color: 'var(--text-secondary)' }}>Title</label>\\n        </div>\\n        <input\\n          id=\\\"feature-title\\\"\\n          ref={combinedTitleRef}\\n          type=\\\"text\\\"\\n          placeholder=\\\"What is this feature?\\\"\\n          value={title}\\n          onChange={(e) => setTitle(e.target.value)}\\n          disabled={submitting}\\n          className=\\\"w-full rounded-md border px-3 py-2 text-sm disabled:opacity-60\\\"\\n          style={{\\n            background: 'var(--surface-raised)',\\n            borderColor: error ? 'var(--status-stuck-soft-border)' : 'var(--border-default)',\\n            color: 'var(--text-primary)'\\n          }}\\n          aria-invalid={!!error}\\n          aria-describedby={error ? 'feature-title-error' : undefined}\\n        />\\n        {error ? (\\n          <div id=\\\"feature-title-error\\\" className=\\\"text-xs\\\" style={{ color: 'var(--status-stuck-fg)' }}>{error}</div>\\n        ) : null}\\n\\n        <div className=\\\"flex flex-col gap-1\\\">\\n          <label htmlFor=\\\"feature-description\\\" className=\\\"text-xs\\\" style={{ color: 'var(--text-secondary)' }}>Description</label>\\n          <FileMentionsTextarea\\n            id=\\\"feature-description\\\"\\n            rows={4}\\n            placeholder=\\\"Optional details or acceptance criteria. Tip: @ to reference files, # to reference tasks/features\\\"\\n            value={description}\\n            onChange={setDescription}\\n            disabled={submitting}\\n            className=\\\"w-full rounded-md border px-3 py-2 text-sm disabled:opacity-60 resize-y max-h-64\\\"\\n            style={{ background: 'var(--surface-raised)', borderColor: 'var(--border-default)', color: 'var(--text-primary)' }}\\n            ariaLabel=\\\"Feature description\\\"\\n            onFileMentionSelected={handleFileMentionSelected}\\n            onReferenceSelected={handleReferenceSelected}\\n          />\\n        </div>\\n\\n        <div className=\\\"flex flex-col gap-1\\\">\\n          <label htmlFor=\\\"feature-rejection\\\" className=\\\"text-xs\\\" style={{ color: 'var(--text-secondary)' }}>Rejection Reason</label>\\n          <FileMentionsTextarea\\n            id=\\\"feature-rejection\\\"\\n            rows={3}\\n            placeholder=\\\"Optional reason for rejection (leave blank to remove). Tip: @ files, # tasks/features\\\"\\n            value={rejection}\\n            onChange={setRejection}\\n            disabled={submitting}\\n            className=\\\"w-full rounded-md border px-3 py-2 text-sm disabled:opacity-60 resize-y max-h-64\\\"\\n            style={{ background: 'var(--surface-raised)', borderColor: 'var(--border-default)', color: 'var(--text-primary)' }}\\n            ariaLabel=\\\"Feature rejection reason\\\"\\n            onFileMentionSelected={handleFileMentionSelected}\\n            onReferenceSelected={handleReferenceSelected}\\n          />\\n        </div>\\n\\n        <div className=\\\"flex flex-col gap-1\\\">\\n          <label className=\\\"text-xs\\\" style={{ color: 'var(--text-secondary)' }}>Context Files</label>\\n          <div className=\\\"flex flex-wrap items-start gap-2 border rounded-md min-h-[3rem] p-2\\\" style={{ borderColor: 'var(--border-default)', background: 'var(--surface-raised)' }}>\\n            {context.map((p, idx) => (\\n              <ContextFileChip key={p} path={p} onRemove={() => removeContextAt(idx)} warn={!mentionedPaths.has(p)} />\\n            ))}\\n            <button type=\\\"button\\\" onClick={() => setShowFileSelector(true)} className=\\\"chip chip--ok\\\" title=\\\"Add context files\\\">\\n              <IconPlus className=\\\"w-3 h-3\\\" />\\n              <span>Add</span>\\n            </button>\\n          </div>\\n          <div className=\\\"text-xs text-text-muted\\\">Select any files across the project that provide useful context for this feature. Tip: type @ in description to quickly reference files.</div>\\n        </div>\\n\\n        <div className=\\\"flex flex-col gap-1\\\">\\n          <label htmlFor=\\\"feature-blockers\\\" className=\\\"text-xs\\\" style={{ color: 'var(--text-secondary)' }}>Blockers</label>\\n          <div\\n            id=\\\"feature-blockers\\\"\\n            className=\\\"chips-list border rounded-md min-h-[3rem] p-2\\\"\\n            style={{\\n              borderColor: 'var(--border-default)',\\n              background: 'var(--surface-raised)'\\n            }}\\n          >\\n            {blockers.map((dep, idx) => {\\n              return (\\n                <DependencyBullet key={`${dep}-${idx}`} dependency={dep} onRemove={() => removeBlockerAt(idx)} />\\n              )\\n            })}\\n            <button\\n              type=\\\"button\\\"\\n              onClick={() => setShowSelector(true)}\\n              className=\\\"chip chip--ok\\\"\\n              title=\\\"Add blocker\\\"\\n            >\\n              <IconPlus className=\\\"w-3 h-3\\\" />\\n              <span>Add</span>\\n            </button>\\n          </div>\\n          <div className=\\\"text-xs text-text-muted\\\">Tip: Type # to quickly reference a task or feature; it will be added as a blocker automatically.</div>\\n        </div>\\n      </div>\\n\\n      <div className=\\\"flex justify-between gap-2 pt-2\\\">\\n        {onDelete && !isCreate ? (\\n          <button\\n            type=\\\"button\\\"\\n            onClick={onDelete}\\n            disabled={submitting}\\n            className=\\\"btn\\\"\\n            style={{\\n              background: 'var(--status-stuck-bg)',\\n              color: 'var(--status-stuck-fg)'\\n            }}\\n          >\\n            <IconDelete className=\\\"w-4 h-4\\\" />\\n            Delete\\n          </button>\\n        ) : null}\\n        <div className=\\\"flex justify-end gap-2 flex-1\\\">\\n          <button\\n            type=\\\"button\\\"\\n            className=\\\"btn-secondary\\\"\\n            onClick={() => onCancel()}\\n            disabled={submitting}\\n          >\\n            Cancel\\n          </button>\\n          <button\\n            type=\\\"submit\\\"\\n            className=\\\"btn\\\"\\n            disabled={!canSubmit}\\n            aria-keyshortcuts=\\\"Control+Enter Meta+Enter\\\"\\n            title=\\\"Cmd/Ctrl+Enter to submit\\\"\\n          >\\n            {isCreate ? 'Create Feature' : 'Save Changes'}\\n          </button>\\n        </div>\\n      </div>\\n\\n      {showSelector && (\\n        <Modal title=\\\"Select Blocker\\\" onClose={() => setShowSelector(false)} isOpen={true} size=\\\"md\\\">\\n          <DependencySelector\\n            onConfirm={(deps) => {\\n              const newDeps = deps.filter((d) => !blockers.includes(d))\\n              setBlockers([...blockers, ...newDeps])\\n              setShowSelector(false)\\n            }}\\n            currentTaskId={taskId}\\n            currentFeatureId={featureId}\\n            existingDeps={blockers}\\n          />\\n        </Modal>\\n      )}\\n\\n      {showFileSelector && (\\n        <Modal title=\\\"Select Context Files\\\" onClose={() => setShowFileSelector(false)} isOpen={true} size=\\\"lg\\\">\\n          <FileSelector\\n            selected={context}\\n            onCancel={() => setShowFileSelector(false)}\\n            onConfirm={(paths) => {\\n              const unique = Array.from(new Set([...(context || []), ...paths]))\\n              setContext(unique)\\n              setShowFileSelector(false)\\n            }}\\n            allowMultiple\\n          />\\n        </Modal>\\n      )}\\n    </form>\\n  )\\n}\\n\"\n      }\n    },\n    {\n      \"tool_name\": \"finish_feature\",\n      \"arguments\": {}\n    }\n  ]\n}"
  }
]