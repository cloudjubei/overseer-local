{
  "__task__": {
    "featureId": "__task__",
    "startDate": "2025-09-08T11:36:49.415Z",
    "messages": [
      {
        "role": "user",
        "content": "# Speccer Agent Task Execution\n\nYou are the Speccer Agent. Your single responsibility is to analyze a user-provided task description and break it down into a series of atomic, implementable features. Your goal is to produce a complete and logical plan for the Developer agents to follow. You should try to tailor the feature titles and descriptions to be the best for LLMs to follow.\n\n## Workflow\n\n1.  **Analyze**: Carefully read the task's title and description to fully understand the goal. Consider the project's existing structure and conventions.\n2.  **Consult the File Structure**: Use the provided `docs/FILE_ORGANISATION.md` to understand the project context.\n3.  **Investigate**: Use the `list_files` and `search_files` tools for all file operations to understand the project further.\n4.  **Create Features**: Formulate a list of consecutive, atomic features required to accomplish the task. Each feature should be a small, logical, and testable unit of work. Use the `create_feature` tool for each one you identify.\n3.  **Finish**: Once the features are created, you **MUST** call the `finish_spec` tool to complete your assignment.\n4.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_task` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n## Notes\n\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\n\n#CURRENT TASK (ID: 89257920-d018-41bf-892a-583569d11d53)\n##TITLE:\nCleaning up the tools\n##DESCRIPTION:\nCurrently there are only fileTools and taskUtils - but all tools should be split by the context they serve.\nThere are test related functions inside taskUtils - those should be placed in a new file.\nThe whole project requires a README.md that will be updated with precise and concise information about each set of tools.\n\n\n\n\n\n\n\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- create_feature(title: str, description: str) - Define and add a new, atomic feature to the task. Include a concise title and a clear description.\n- finish_spec() - Signal that the feature specification is complete for the current task.\n- block_task() - Stop work on the task and report why you are blocked at the task level.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n[object Object]\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\nAs responses to the tool calls you will send, you will also receive JSON objects in the form:\n```json\n{\n\"name\":\"tool_name\",\n\"result\":\"...\"\n}\n```\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"Path not found or is not a regular file/directory.\"}\n\nBegin now.",
        "featureId": "__task__",
        "agentType": "speccer",
        "turn": 0,
        "source": "initial",
        "createdAt": "2025-09-08T11:37:36.051Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"I will investigate the repository to understand the current tools structure (fileTools, taskUtils) and any existing docs. Since docs/FILE_ORGANISATION.md is missing, I will explore the root and relevant directories. Then I will create atomic features to: audit and categorize current tool functions, extract test-related functions from taskUtils into a new testTools module, split remaining utilities into context-based modules, update imports/usages, create or update README.md for the tools and top-level project, and update/create FILE_ORGANISATION.md to reflect new structure.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"list_files\",\n      \"args\": {\n        \"path\": \".\"\n      }\n    }\n  ]\n}",
        "featureId": "__task__",
        "agentType": "speccer",
        "turn": 0,
        "askedAt": "2025-09-08T11:36:49.417Z",
        "createdAt": "2025-09-08T11:37:36.051Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"list_files\",\"result\":[\".env\",\".eslintrc.cjs\",\".git\",\".gitignore\",\".prettierrc\",\"blueprint\",\"docs\",\"package-lock.json\",\"package.json\",\"src\",\"tasks\",\"tsconfig.json\",\"tsup.config.ts\",\"types\",\"vitest.config.ts\"]}]",
        "featureId": "__task__",
        "agentType": "speccer",
        "turn": 0,
        "source": "tools",
        "createdAt": "2025-09-08T11:37:36.051Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"Next, I need to locate the existing tool files (fileTools, taskUtils) and any docs. I will inspect src and tasks directories to find where these utilities live.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"list_files\",\n      \"args\": {\n        \"path\": \"src\"\n      }\n    },\n    {\n      \"tool_name\": \"list_files\",\n      \"args\": {\n        \"path\": \"tasks\"\n      }\n    }\n  ]\n}",
        "featureId": "__task__",
        "agentType": "speccer",
        "turn": 1,
        "askedAt": "2025-09-08T11:36:54.072Z",
        "createdAt": "2025-09-08T11:37:36.051Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"list_files\",\"result\":[\"chatTools.ts\",\"completion.ts\",\"fileTools.ts\",\"gitManager.ts\",\"index.ts\",\"logger.ts\",\"orchestrator.ts\",\"pricing.ts\",\"taskUtils.ts\",\"types.ts\",\"utils.ts\"]},{\"name\":\"list_files\",\"result\":[\"054f8bb3-1d18-49af-98c3-60b732cbcdcb\",\"0f49487c-1bd3-458f-9d7d-8d4936788435\",\"39581aeb-c49a-4047-b55f-9aca48ccdc91\",\"89257920-d018-41bf-892a-583569d11d53\",\"a04bff77-3c82-43e6-b4bc-3dc669be08dd\",\"e334cc68-fb9b-45cf-9440-bb13b39f832d\"]}]",
        "featureId": "__task__",
        "agentType": "speccer",
        "turn": 1,
        "source": "tools",
        "createdAt": "2025-09-08T11:37:36.051Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"I will read taskUtils.ts and related tool files to identify test-related functions and plan the refactor.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"read_files\",\n      \"args\": {\n        \"paths\": [\n          \"src/taskUtils.ts\",\n          \"src/fileTools.ts\",\n          \"src/utils.ts\",\n          \"src/index.ts\"\n        ]\n      }\n    }\n  ]\n}",
        "featureId": "__task__",
        "agentType": "speccer",
        "turn": 2,
        "askedAt": "2025-09-08T11:36:58.030Z",
        "createdAt": "2025-09-08T11:37:36.051Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"read_files\",\"result\":\"{\\\"src/taskUtils.ts\\\":\\\"import fs from 'node:fs';\\\\nimport fsp from 'node:fs/promises';\\\\nimport path from 'node:path';\\\\n\\\\nimport type { Status, Feature, Task } from './types.js';\\\\nimport type { GitManager } from './gitManager.js';\\\\n\\\\n// Stable framework root (monorepo/app root) captured at module load.\\\\n// This should never be mutated by per-run operations.\\\\nconst FRAMEWORK_ROOT = path.resolve(process.cwd());\\\\n\\\\n// Mutable project root used for file tools operating within a specific workspace copy.\\\\nlet PROJECT_ROOT = FRAMEWORK_ROOT;\\\\nconst TASKS_DIR_NAME = 'tasks';\\\\n\\\\nfunction setProjectRoot(p: string) { PROJECT_ROOT = path.resolve(p || FRAMEWORK_ROOT); }\\\\nfunction getProjectRoot() { return PROJECT_ROOT; }\\\\n\\\\nfunction tasksDir() { return path.join(PROJECT_ROOT, TASKS_DIR_NAME); }\\\\nfunction taskDir(taskId: string) { return path.join(tasksDir(), taskId); }\\\\nfunction taskPath(taskId: string) { return path.join(taskDir(taskId), 'task.json'); }\\\\nfunction testPath(taskId: string, featureId: string) { return path.join(taskDir(taskId), 'tests', `test_${taskId}_${featureId}.py`); }\\\\n\\\\nconst PROJECTS_DIR_NAME = 'projects';\\\\n// Project configs must always be read from the stable framework root, not the mutable project root.\\\\nfunction projectsDirStable() { return path.join(FRAMEWORK_ROOT, PROJECTS_DIR_NAME); }\\\\nfunction projectPathStable(projectId: string) { return path.join(projectsDirStable(), `${projectId}.json`); }\\\\n\\\\nasync function ensureDir(p: string) { await fsp.mkdir(p, { recursive: true }); }\\\\n\\\\nasync function getProjectDir(projectId: string): Promise<string> {\\\\n  // Read the project config from the stable framework root so multiple runs do not depend on temporary workspace state.\\\\n  const p = projectPathStable(projectId);\\\\n  const raw = await fsp.readFile(p, 'utf8');\\\\n  const project = JSON.parse(raw);\\\\n  // project.path is assumed to be relative to the projects dir or the repo root; resolve from FRAMEWORK_ROOT\\\\n  return path.join(FRAMEWORK_ROOT, PROJECTS_DIR_NAME, project.path)\\\\n}\\\\n\\\\nasync function getTask(taskId: string): Promise<Task> {\\\\n  const p = taskPath(taskId);\\\\n  const raw = await fsp.readFile(p, 'utf8');\\\\n  return JSON.parse(raw);\\\\n}\\\\n\\\\nasync function saveTask(task: Task): Promise<void> {\\\\n  const p = taskPath(task.id);\\\\n  await ensureDir(path.dirname(p));\\\\n  await fsp.writeFile(p, JSON.stringify(task, null, 2), 'utf8');\\\\n}\\\\n\\\\nasync function updateTaskStatus(taskId: string, status: Status): Promise<Task> {\\\\n  const t = await getTask(taskId);\\\\n  t.status = status;\\\\n  await saveTask(t);\\\\n  return t;\\\\n}\\\\n\\\\n// File utilities (sandboxed under project root)\\\\nfunction isWithinRoot(abs: string) {\\\\n  const root = getProjectRoot();\\\\n  const normRoot = path.resolve(root) + path.sep;\\\\n  const normAbs = path.resolve(abs) + path.sep;\\\\n  return normAbs.startsWith(normRoot) || path.resolve(abs) === path.resolve(root);\\\\n}\\\\n\\\\nasync function readFiles(pathsRel: string[]): Promise<string> {\\\\n  const result: Record<string, any> = {};\\\\n  for (const rel of pathsRel) {\\\\n    try {\\\\n      const abs = path.resolve(getProjectRoot(), rel);\\\\n      if (!isWithinRoot(abs)) { result[rel] = 'SECURITY ERROR: Cannot access path outside project directory.\\\\\\\\n'; continue; }\\\\n      const st = await fsp.stat(abs).catch(() => null);\\\\n      if (!st) { result[rel] = 'Path not found or is not a regular file/directory.'; continue; }\\\\n      if (st.isDirectory()) {\\\\n        const entries = await fsp.readdir(abs);\\\\n        result[rel] = entries;\\\\n      } else if (st.isFile()) {\\\\n        result[rel] = await fsp.readFile(abs, 'utf8');\\\\n      } else {\\\\n        result[rel] = 'Path not found or is not a regular file/directory.';\\\\n      }\\\\n    } catch (e) {\\\\n      result[rel] = String(e);\\\\n    }\\\\n  }\\\\n  return JSON.stringify(result, null, 0);\\\\n}\\\\nasync function updateFeatureStatus(taskId: string, featureId: string, status: Status) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  if (feature) {\\\\n    feature.status = status;\\\\n    await saveTask(t);\\\\n    return feature;\\\\n  }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function blockFeature(taskId: string, featureId: string, reason: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  if (feature) {\\\\n    feature.status = '?';\\\\n    feature.rejection = `Blocked: ${reason}`;\\\\n    await saveTask(t);\\\\n  }\\\\n  const title = feature?.title ?? '';\\\\n  let msg: string;\\\\n  if (agentType === 'developer') msg = `BLOCKED feat: Complete feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'planner') msg = `BLOCKED plan: Add plan for feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'tester') msg = `BLOCKED test: Add tests for feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'contexter') msg = `BLOCKED context: Set context for feature ${featureId} - ${title}`;\\\\n  else throw new Error(`Unknown agent_type '${agentType}' called block_feature.`);\\\\n\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n\\\\n  console.log(`Feature ${featureId} blocked. Reason: ${reason}`);\\\\n  return feature;\\\\n}\\\\n\\\\nasync function blockTask(taskId: string, reason: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  t.status = '?';\\\\n  t.rejection = `Blocked: ${reason}`;\\\\n  await saveTask(t);\\\\n  const msg = `BLOCKED task: ${t.id} - ${t.title}`;\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  console.log(`Task ${taskId} blocked. Reason: ${reason}`);\\\\n  return t;\\\\n}\\\\n\\\\nasync function checkAndUpdateTaskCompletion(taskId: string) {\\\\n  const t = await getTask(taskId);\\\\n  const allDone = (t.features || []).every(f => f.status === '+');\\\\n  if (allDone) {\\\\n    console.log(`All features for task ${taskId} are complete. Updating task status to '+'.`);\\\\n    await updateTaskStatus(taskId, '+');\\\\n  }\\\\n}\\\\n\\\\nasync function finishFeature(taskId: string, featureId: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  const title = feature?.title ?? '';\\\\n  let msg: string;\\\\n  if (agentType === 'developer') {\\\\n    msg = `feat: Complete feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '+');\\\\n    await checkAndUpdateTaskCompletion(taskId);\\\\n  } else if (agentType === 'planner') {\\\\n    msg = `plan: Add plan for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else if (agentType === 'tester') {\\\\n    msg = `test: Add tests for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else if (agentType === 'contexter') {\\\\n    msg = `context: Set context for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else {\\\\n    throw new Error(`Unknown agent_type '${agentType}' called finish_feature.`);\\\\n  }\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  return `Feature ${featureId} finished by ${agentType} and changes committed.`;\\\\n}\\\\n\\\\nasync function finishSpec(taskId: string, agentType: string, git: GitManager) {\\\\n  if (agentType !== 'speccer') throw new Error(`Unknown agent_type '${agentType}' called finish_spec.`);\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  const msg = `spec: Added spec for task: ${taskId}`;\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  return `Task ${taskId} finished spec by ${agentType} and changes committed.`;\\\\n}\\\\n\\\\n// Tester tools\\\\nasync function getTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  try { return await fsp.readFile(p, 'utf8'); } catch { return `Test file not found at ${p}`; }\\\\n}\\\\n\\\\nasync function updateAcceptanceCriteria(taskId: string, featureId: string, criteria: string[]) {\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.acceptance = criteria; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function updateTest(taskId: string, featureId: string, test: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  await ensureDir(path.dirname(p));\\\\n  await fsp.writeFile(p, test, 'utf8');\\\\n  return `Test file updated at ${p}`;\\\\n}\\\\n\\\\nasync function deleteTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  try { await fsp.unlink(p); return `Test file ${p} deleted.`; } catch { return `Test file ${p} not found.`; }\\\\n}\\\\n\\\\nasync function runTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  if (!fs.existsSync(p)) return 'FAIL: Test file not found.';\\\\n  const { spawn } = await import('node:child_process');\\\\n  return await new Promise<string>((resolve) => {\\\\n    const proc = spawn('python3', [p], { stdio: ['ignore', 'pipe', 'pipe'] });\\\\n    let stdout = '';\\\\n    let stderr = '';\\\\n    const timer = setTimeout(() => { try { proc.kill('SIGKILL'); } catch {} }, 30000);\\\\n    proc.stdout.on('data', (d: any) => { stdout += d.toString(); });\\\\n    proc.stderr.on('data', (d: any) => { stderr += d.toString(); });\\\\n    proc.on('close', (code: number) => {\\\\n      clearTimeout(timer);\\\\n      if (code === 0) resolve(`PASS: Test executed successfully.\\\\\\\\nOutput:\\\\\\\\n${stdout}`);\\\\n      else resolve(`FAIL: Test failed with exit code ${code}.\\\\\\\\nStderr:\\\\\\\\n${stderr}\\\\\\\\nStdout:\\\\\\\\n${stdout}`);\\\\n    });\\\\n    proc.on('error', (e: any) => {\\\\n      clearTimeout(timer);\\\\n      resolve(`FAIL: An unexpected error occurred while running the test: ${e}`);\\\\n    });\\\\n  });\\\\n}\\\\n\\\\n// Orchestrator helpers\\\\nfunction findNextAvailableFeature(task: Task, excludeIds: Set<string> = new Set(), ignoreDependencies = false): Feature | undefined {\\\\n  const features = (task.features || []).slice();\\\\n  if (features.length === 0) return undefined;\\\\n\\\\n  // Create an index mapping using featureIdToDisplayIndex; fallback to array order\\\\n  const displayIndex: Record<string, number> = {};\\\\n  const map = (task as any).featureIdToDisplayIndex as Record<string, number> | undefined;\\\\n  for (let i = 0; i < features.length; i++) {\\\\n    const f = features[i];\\\\n    const idx = map?.[f.id];\\\\n    displayIndex[f.id] = typeof idx === 'number' ? idx : (i + 1); // 1-based fallback\\\\n  }\\\\n\\\\n  // Sort features by display index ascending\\\\n  features.sort((a, b) => {\\\\n    const ai = displayIndex[a.id] ?? Number.MAX_SAFE_INTEGER;\\\\n    const bi = displayIndex[b.id] ?? Number.MAX_SAFE_INTEGER;\\\\n    if (ai !== bi) return ai - bi;\\\\n    // Stable fallback using original array order if indexes equal/missing\\\\n    return 0;\\\\n  });\\\\n\\\\n  const completed = new Set(features.filter(f => f.status === '+').map(f => f.id));\\\\n  for (const f of features) {\\\\n    if (excludeIds.has(f.id)) continue;\\\\n    if (f.status === '-') {\\\\n      const deps = f.blockers || [];\\\\n      if (ignoreDependencies || deps.every(d => completed.has(d))) return f;\\\\n    }\\\\n  }\\\\n  return undefined;\\\\n}\\\\n\\\\nfunction uuidv4() {\\\\n  // Simple UUID v4 generator for local use\\\\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\\\\n    const r = Math.random() * 16 | 0;\\\\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\\\\n    return v.toString(16);\\\\n  });\\\\n}\\\\n\\\\nasync function createFeature(taskId: string, title: string, description: string): Promise<Feature> {\\\\n  const t = await getTask(taskId);\\\\n  const id = uuidv4();\\\\n  const newFeature: Feature = {\\\\n    id,\\\\n    status: '-',\\\\n    title,\\\\n    description,\\\\n    plan: '',\\\\n    context: [],\\\\n    acceptance: [],\\\\n  };\\\\n  t.features = t.features || [];\\\\n  t.features.push(newFeature);\\\\n  t.featureIdToDisplayIndex = t.featureIdToDisplayIndex || {};\\\\n  t.featureIdToDisplayIndex[id] = t.features.length;\\\\n  await saveTask(t);\\\\n  console.log(`New feature '${id}' created in task ${taskId}.`);\\\\n  return newFeature;\\\\n}\\\\n\\\\nasync function updateFeaturePlan(taskId: string, featureId: string, plan: any) {\\\\n  const planStr = Array.isArray(plan) ? plan.map(String).join('\\\\\\\\n') : (typeof plan === 'string' ? plan : String(plan));\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.plan = planStr; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function updateFeatureContext(taskId: string, featureId: string, context: string[]) {\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.context = context; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nexport const taskUtils = {\\\\n  // project\\\\n  setProjectRoot,\\\\n  // task io\\\\n  getTask,\\\\n  saveTask,\\\\n  updateTaskStatus,\\\\n  // feature status\\\\n  updateFeatureStatus,\\\\n  blockFeature,\\\\n  blockTask,\\\\n  finishFeature,\\\\n  finishSpec,\\\\n  // tester tools\\\\n  getTest,\\\\n  updateAcceptanceCriteria,\\\\n  updateTest,\\\\n  deleteTest,\\\\n  runTest,\\\\n  // orchestrator helpers\\\\n  getProjectDir,\\\\n  findNextAvailableFeature,\\\\n  createFeature,\\\\n  updateFeaturePlan,\\\\n  updateFeatureContext,\\\\n};\\\\n\\\\nexport type TaskUtils = typeof taskUtils;\\\\n\\\\n// New: create per-run, project-root scoped task utils (thread-safe)\\\\nexport function createTaskUtils(projectRoot: string) {\\\\n  // Instance-local project root\\\\n  let ROOT = path.resolve(projectRoot || FRAMEWORK_ROOT);\\\\n  const tasksDirLocal = () => path.join(ROOT, TASKS_DIR_NAME);\\\\n  const taskDirLocal = (taskId: string) => path.join(tasksDirLocal(), taskId);\\\\n  const taskPathLocal = (taskId: string) => path.join(taskDirLocal(taskId), 'task.json');\\\\n  const testPathLocal = (taskId: string, featureId: string) => path.join(taskDirLocal(taskId), 'tests', `test_${taskId}_${featureId}.py`);\\\\n\\\\n  async function getTaskLocal(taskId: string): Promise<Task> {\\\\n    const p = taskPathLocal(taskId);\\\\n    const raw = await fsp.readFile(p, 'utf8');\\\\n    return JSON.parse(raw);\\\\n  }\\\\n  async function saveTaskLocal(task: Task): Promise<void> {\\\\n    const p = taskPathLocal(task.id);\\\\n    await ensureDir(path.dirname(p));\\\\n    await fsp.writeFile(p, JSON.stringify(task, null, 2), 'utf8');\\\\n  }\\\\n  async function updateTaskStatusLocal(taskId: string, status: Status): Promise<Task> {\\\\n    const t = await getTaskLocal(taskId);\\\\n    t.status = status;\\\\n    await saveTaskLocal(t);\\\\n    return t;\\\\n  }\\\\n  async function updateFeatureStatusLocal(taskId: string, featureId: string, status: Status) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const feature = t.features.find(f => f.id === featureId);\\\\n    if (feature) {\\\\n      feature.status = status;\\\\n      await saveTaskLocal(t);\\\\n      return feature;\\\\n    }\\\\n    return undefined;\\\\n  }\\\\n  async function blockFeatureLocal(taskId: string, featureId: string, reason: string, agentType: string, git: GitManager) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const feature = t.features.find(f => f.id === featureId);\\\\n    if (feature) {\\\\n      feature.status = '?';\\\\n      feature.rejection = `Blocked: ${reason}`;\\\\n      await saveTaskLocal(t);\\\\n    }\\\\n    const title = feature?.title ?? '';\\\\n    let msg: string;\\\\n    if (agentType === 'developer') msg = `BLOCKED feat: Complete feature ${featureId} - ${title}`;\\\\n    else if (agentType === 'planner') msg = `BLOCKED plan: Add plan for feature ${featureId} - ${title}`;\\\\n    else if (agentType === 'tester') msg = `BLOCKED test: Add tests for feature ${featureId} - ${title}`;\\\\n    else if (agentType === 'contexter') msg = `BLOCKED context: Set context for feature ${featureId} - ${title}`;\\\\n    else throw new Error(`Unknown agent_type '${agentType}' called block_feature.`);\\\\n\\\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n\\\\n    console.log(`Feature ${featureId} blocked. Reason: ${reason}`);\\\\n    return feature;\\\\n  }\\\\n  async function blockTaskLocal(taskId: string, reason: string, agentType: string, git: GitManager) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    t.status = '?';\\\\n    t.rejection = `Blocked: ${reason}`;\\\\n    await saveTaskLocal(t);\\\\n    const msg = `BLOCKED task: ${t.id} - ${t.title}`;\\\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n    console.log(`Task ${taskId} blocked. Reason: ${reason}`);\\\\n    return t;\\\\n  }\\\\n  async function checkAndUpdateTaskCompletionLocal(taskId: string) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const allDone = (t.features || []).every(f => f.status === '+');\\\\n    if (allDone) {\\\\n      console.log(`All features for task ${taskId} are complete. Updating task status to '+'.`);\\\\n      await updateTaskStatusLocal(taskId, '+');\\\\n    }\\\\n  }\\\\n  async function finishFeatureLocal(taskId: string, featureId: string, agentType: string, git: GitManager) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const feature = t.features.find(f => f.id === featureId);\\\\n    const title = feature?.title ?? '';\\\\n    let msg: string;\\\\n    if (agentType === 'developer') {\\\\n      msg = `feat: Complete feature ${featureId} - ${title}`;\\\\n      await updateFeatureStatusLocal(taskId, featureId, '+');\\\\n      await checkAndUpdateTaskCompletionLocal(taskId);\\\\n    } else if (agentType === 'planner') {\\\\n      msg = `plan: Add plan for feature ${featureId} - ${title}`;\\\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\\\n    } else if (agentType === 'tester') {\\\\n      msg = `test: Add tests for feature ${featureId} - ${title}`;\\\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\\\n    } else if (agentType === 'contexter') {\\\\n      msg = `context: Set context for feature ${featureId} - ${title}`;\\\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\\\n    } else {\\\\n      throw new Error(`Unknown agent_type '${agentType}' called finish_feature.`);\\\\n    }\\\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n    return `Feature ${featureId} finished by ${agentType} and changes committed.`;\\\\n  }\\\\n  async function finishSpecLocal(taskId: string, agentType: string, git: GitManager) {\\\\n    if (agentType !== 'speccer') throw new Error(`Unknown agent_type '${agentType}' called finish_spec.`);\\\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    const msg = `spec: Added spec for task: ${taskId}`;\\\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n    return `Task ${taskId} finished spec by ${agentType} and changes committed.`;\\\\n  }\\\\n  async function getTestLocal(taskId: string, featureId: string) {\\\\n    const p = testPathLocal(taskId, featureId);\\\\n    try { return await fsp.readFile(p, 'utf8'); } catch { return `Test file not found at ${p}`; }\\\\n  }\\\\n  async function updateTestLocal(taskId: string, featureId: string, test: string) {\\\\n    const p = testPathLocal(taskId, featureId);\\\\n    await ensureDir(path.dirname(p));\\\\n    await fsp.writeFile(p, test, 'utf8');\\\\n    return `Test file updated at ${p}`;\\\\n  }\\\\n  async function deleteTestLocal(taskId: string, featureId: string) {\\\\n    const p = testPathLocal(taskId, featureId);\\\\n    try { await fsp.unlink(p); return `Test file ${p} deleted.`; } catch { return `Test file ${p} not found.`; }\\\\n  }\\\\n  async function runTestLocal(taskId: string, featureId: string) {\\\\n    const p = testPathLocal(taskId, featureId);\\\\n    if (!fs.existsSync(p)) return 'FAIL: Test file not found.';\\\\n    const { spawn } = await import('node:child_process');\\\\n    return await new Promise<string>((resolve) => {\\\\n      const proc = spawn('python3', [p], { stdio: ['ignore', 'pipe', 'pipe'] });\\\\n      let stdout = '';\\\\n      let stderr = '';\\\\n      const timer = setTimeout(() => { try { proc.kill('SIGKILL'); } catch {} }, 30000);\\\\n      proc.stdout.on('data', (d: any) => { stdout += d.toString(); });\\\\n      proc.stderr.on('data', (d: any) => { stderr += d.toString(); });\\\\n      proc.on('close', (code: number) => {\\\\n        clearTimeout(timer);\\\\n        if (code === 0) resolve(`PASS: Test executed successfully.\\\\\\\\nOutput:\\\\\\\\n${stdout}`);\\\\n        else resolve(`FAIL: Test failed with exit code ${code}.\\\\\\\\nStderr:\\\\\\\\n${stderr}\\\\\\\\nStdout:\\\\\\\\n${stdout}`);\\\\n      });\\\\n      proc.on('error', (e: any) => {\\\\n        clearTimeout(timer);\\\\n        resolve(`FAIL: An unexpected error occurred while running the test: ${e}`);\\\\n      });\\\\n    });\\\\n  }\\\\n  async function createFeatureLocal(taskId: string, title: string, description: string): Promise<Feature> {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const id = (function uuidv4() {return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {const r = Math.random() * 16 | 0;const v = c === 'x' ? r : (r & 0x3 | 0x8);return v.toString(16);}); })();\\\\n    const newFeature: Feature = { id, status: '-', title, description, plan: '', context: [], acceptance: [], };\\\\n    t.features = t.features || [];\\\\n    t.features.push(newFeature);\\\\n    t.featureIdToDisplayIndex = t.featureIdToDisplayIndex || {};\\\\n    t.featureIdToDisplayIndex[id] = t.features.length;\\\\n    await saveTaskLocal(t);\\\\n    console.log(`New feature '${id}' created in task ${taskId}.`);\\\\n    return newFeature;\\\\n  }\\\\n  async function updateFeaturePlanLocal(taskId: string, featureId: string, plan: any) {\\\\n    const planStr = Array.isArray(plan) ? plan.map(String).join('\\\\\\\\n') : (typeof plan === 'string' ? plan : String(plan));\\\\n    const t = await getTaskLocal(taskId);\\\\n    const f = t.features.find(x => x.id === featureId);\\\\n    if (f) { f.plan = planStr; await saveTaskLocal(t); return f; }\\\\n    return undefined;\\\\n  }\\\\n  async function updateFeatureContextLocal(taskId: string, featureId: string, context: string[]) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const f = t.features.find(x => x.id === featureId);\\\\n    if (f) { f.context = context; await saveTaskLocal(t); return f; }\\\\n    return undefined;\\\\n  }\\\\n\\\\n  return {\\\\n    // instance project root mutator (instance-scoped)\\\\n    setProjectRoot: (p: string) => { ROOT = path.resolve(p || ROOT); },\\\\n    // task io\\\\n    getTask: getTaskLocal,\\\\n    saveTask: saveTaskLocal,\\\\n    updateTaskStatus: updateTaskStatusLocal,\\\\n    // feature status\\\\n    updateFeatureStatus: updateFeatureStatusLocal,\\\\n    blockFeature: blockFeatureLocal,\\\\n    blockTask: blockTaskLocal,\\\\n    finishFeature: finishFeatureLocal,\\\\n    finishSpec: finishSpecLocal,\\\\n    // tester tools\\\\n    getTest: getTestLocal,\\\\n    updateAcceptanceCriteria,\\\\n    updateTest: updateTestLocal,\\\\n    deleteTest: deleteTestLocal,\\\\n    runTest: runTestLocal,\\\\n    // orchestrator helpers\\\\n    getProjectDir, // always from FRAMEWORK_ROOT (shared, safe)\\\\n    findNextAvailableFeature,\\\\n    createFeature: createFeatureLocal,\\\\n    updateFeaturePlan: updateFeaturePlanLocal,\\\\n    updateFeatureContext: updateFeatureContextLocal,\\\\n  } as TaskUtils;\\\\n}\\\\n\\\",\\\"src/fileTools.ts\\\":\\\"import fs from 'node:fs';\\\\nimport fsp from 'node:fs/promises';\\\\nimport path from 'node:path';\\\\n\\\\nlet PROJECT_ROOT = path.resolve(process.cwd());\\\\n\\\\nfunction setProjectRoot(p: string) { PROJECT_ROOT = path.resolve(p); }\\\\nfunction getProjectRoot() { return PROJECT_ROOT; }\\\\n\\\\nasync function ensureDir(p: string) { await fsp.mkdir(p, { recursive: true }); }\\\\n\\\\nfunction isWithinRootFactory(rootGetter: () => string) {\\\\n  return function isWithinRoot(abs: string) {\\\\n    const root = rootGetter();\\\\n    const normRoot = path.resolve(root) + path.sep;\\\\n    const normAbs = path.resolve(abs) + path.sep;\\\\n    return normAbs.startsWith(normRoot) || path.resolve(abs) === path.resolve(root);\\\\n  }\\\\n}\\\\n\\\\nasync function readFilesImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, pathsRel: string[]): Promise<string> {\\\\n  const result: Record<string, any> = {};\\\\n  for (const rel of pathsRel) {\\\\n    try {\\\\n      const abs = path.resolve(rootGetter(), rel);\\\\n      if (!isWithinRoot(abs)) { result[rel] = 'SECURITY ERROR: Cannot access path outside project directory.\\\\\\\\n'; continue; }\\\\n      const st = await fsp.stat(abs).catch(() => null);\\\\n      if (!st) { result[rel] = 'Path not found or is not a regular file/directory.'; continue; }\\\\n      if (st.isDirectory()) {\\\\n        const entries = await fsp.readdir(abs);\\\\n        result[rel] = entries;\\\\n      } else if (st.isFile()) {\\\\n        result[rel] = await fsp.readFile(abs, 'utf8');\\\\n      } else {\\\\n        result[rel] = 'Path not found or is not a regular file/directory.';\\\\n      }\\\\n    } catch (e) {\\\\n      result[rel] = String(e);\\\\n    }\\\\n  }\\\\n  return JSON.stringify(result, null, 0);\\\\n}\\\\n\\\\nasync function listFilesImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, relPath: string): Promise<string[]> {\\\\n  try {\\\\n    const abs = path.resolve(rootGetter(), relPath);\\\\n    if (!isWithinRoot(abs)) return [];\\\\n    const st = await fsp.stat(abs).catch(() => null);\\\\n    if (!st || !st.isDirectory()) return [];\\\\n    const entries = await fsp.readdir(abs);\\\\n    return entries;\\\\n  } catch {\\\\n    return [];\\\\n  }\\\\n}\\\\n\\\\nasync function writeFileImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, relPath: string, content: string) {\\\\n  const abs = path.resolve(rootGetter(), relPath);\\\\n  if (!isWithinRoot(abs)) throw new Error(`Security violation: Attempt to write outside of project root: ${relPath}`);\\\\n  await ensureDir(path.dirname(abs));\\\\n  await fsp.writeFile(abs, content, 'utf8');\\\\n  return `File securely written to: ${relPath}`;\\\\n}\\\\n\\\\nasync function renameFileImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, srcRel: string, dstRel: string) {\\\\n  const src = path.resolve(rootGetter(), srcRel);\\\\n  const dst = path.resolve(rootGetter(), dstRel);\\\\n  if (!isWithinRoot(src)) throw new Error(`Security violation: Attempt to read outside of project root: ${srcRel}`);\\\\n  if (!isWithinRoot(dst)) throw new Error(`Security violation: Attempt to write outside of project root: ${dstRel}`);\\\\n  await ensureDir(path.dirname(dst));\\\\n  await fsp.rename(src, dst);\\\\n  return `File ${srcRel} securely renamed to: ${dstRel}`;\\\\n}\\\\n\\\\nasync function deleteFileImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, relPath: string) {\\\\n  const abs = path.resolve(rootGetter(), relPath);\\\\n  if (!isWithinRoot(abs)) throw new Error(`Security violation: Attempt to delete outside of project root: ${relPath}`);\\\\n  const st = await fsp.stat(abs).catch(() => null);\\\\n  if (!st) return `File not found: ${relPath}`;\\\\n  if (st.isDirectory()) {\\\\n    await fsp.rmdir(abs);\\\\n  } else {\\\\n    await fsp.unlink(abs).catch(() => {});\\\\n  }\\\\n  return `File securely deleted: ${relPath}`;\\\\n}\\\\n\\\\nasync function searchFilesImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, query: string, relPath = '.'): Promise<string[]> {\\\\n  if (!query) return [];\\\\n  const root = rootGetter();\\\\n  const start = path.resolve(root, relPath);\\\\n  if (!isWithinRoot(start)) return [];\\\\n\\\\n  const ignore = new Set(['.git', 'node_modules', '.venv', 'venv', 'dist', 'build', 'out', '.next', '.cache']);\\\\n  const maxBytes = 2 * 1024 * 1024;\\\\n  const queries = query.toLowerCase().split(\\\\\\\" \\\\\\\");\\\\n  const matches: string[] = [];\\\\n  const seen = new Set<string>();\\\\n\\\\n  const walk = async (dir: string) => {\\\\n    let entries: fs.Dirent[];\\\\n    try {\\\\n      entries = await fsp.readdir(dir, { withFileTypes: true });\\\\n    } catch { return; }\\\\n    for (const ent of entries) {\\\\n      const full = path.join(dir, ent.name);\\\\n      const rel = path.relative(root, full);\\\\n      if (!isWithinRoot(full)) continue;\\\\n      if (ent.isDirectory()) {\\\\n        if (ignore.has(ent.name)) continue;\\\\n        await walk(full);\\\\n      } else if (ent.isFile()) {\\\\n        let added = false;\\\\n        for(const q of queries){\\\\n          if (ent.name.toLowerCase().includes(q)) {\\\\n            if (!seen.has(rel)) { matches.push(rel); seen.add(rel); }\\\\n            added = true;\\\\n            break\\\\n          }\\\\n          if (!added) {\\\\n            try {\\\\n              const st = await fsp.stat(full);\\\\n              if (st.size <= maxBytes) {\\\\n                const data = await fsp.readFile(full);\\\\n                const text = data.toString('utf8');\\\\n                if (text.toLowerCase().includes(q)) {\\\\n                  if (!seen.has(rel)) { matches.push(rel); seen.add(rel); }\\\\n                }\\\\n              }\\\\n            } catch {}\\\\n          }\\\\n        }\\\\n        if (matches.length >= 500) return; // cap results\\\\n      }\\\\n    }\\\\n  };\\\\n\\\\n  await walk(start);\\\\n  return matches;\\\\n}\\\\n\\\\n// Default, process-global tools (backwards-compatible)\\\\nconst defaultIsWithinRoot = isWithinRootFactory(getProjectRoot);\\\\nasync function readFiles(pathsRel: string[]): Promise<string> { return readFilesImpl(getProjectRoot, defaultIsWithinRoot, pathsRel); }\\\\nasync function listFiles(relPath: string): Promise<string[]> { return listFilesImpl(getProjectRoot, defaultIsWithinRoot, relPath); }\\\\nasync function writeFile(relPath: string, content: string) { return writeFileImpl(getProjectRoot, defaultIsWithinRoot, relPath, content); }\\\\nasync function renameFile(srcRel: string, dstRel: string) { return renameFileImpl(getProjectRoot, defaultIsWithinRoot, srcRel, dstRel); }\\\\nasync function deleteFile(relPath: string) { return deleteFileImpl(getProjectRoot, defaultIsWithinRoot, relPath); }\\\\nasync function searchFiles(query: string, relPath = '.') { return searchFilesImpl(getProjectRoot, defaultIsWithinRoot, query, relPath); }\\\\n\\\\nexport const fileTools = {\\\\n  setProjectRoot,\\\\n  \\\\n  readFiles,\\\\n  listFiles,\\\\n  writeFile,\\\\n  renameFile,\\\\n  deleteFile,\\\\n  searchFiles, \\\\n};\\\\n\\\\nexport type FileTools = typeof fileTools;\\\\n\\\\n// New: create per-run, project-root scoped tools (thread-safe)\\\\nexport function createFileTools(projectRoot: string) {\\\\n  let ROOT = path.resolve(projectRoot || process.cwd());\\\\n  const getRoot = () => ROOT;\\\\n  const isWithinRoot = isWithinRootFactory(getRoot);\\\\n  return {\\\\n    setProjectRoot: (p: string) => { ROOT = path.resolve(p || ROOT); },\\\\n    readFiles: (pathsRel: string[]) => readFilesImpl(getRoot, isWithinRoot, pathsRel),\\\\n    listFiles: (relPath: string) => listFilesImpl(getRoot, isWithinRoot, relPath),\\\\n    writeFile: (relPath: string, content: string) => writeFileImpl(getRoot, isWithinRoot, relPath, content),\\\\n    renameFile: (srcRel: string, dstRel: string) => renameFileImpl(getRoot, isWithinRoot, srcRel, dstRel),\\\\n    deleteFile: (relPath: string) => deleteFileImpl(getRoot, isWithinRoot, relPath),\\\\n    searchFiles: (query: string, relPath = '.') => searchFilesImpl(getRoot, isWithinRoot, query, relPath),\\\\n  } as FileTools;\\\\n}\\\\n\\\",\\\"src/utils.ts\\\":\\\"import AGENT_CONTEXTER from '../docs/AGENT_CONTEXTER.md'\\\\nimport AGENT_DEVELOPER from '../docs/AGENT_DEVELOPER.md'\\\\nimport AGENT_PLANNER from '../docs/AGENT_PLANNER.md'\\\\nimport AGENT_SPECCER from '../docs/AGENT_SPECCER.md'\\\\nimport AGENT_TESTER from '../docs/AGENT_TESTER.md'\\\\nimport { AgentType } from './types'\\\\n\\\\nexport function getAgentFile(type: AgentType)\\\\n{\\\\n  switch(type){\\\\n    case 'contexter':\\\\n      return base64ToUtf8(AGENT_CONTEXTER)\\\\n    case 'developer':\\\\n      return base64ToUtf8(AGENT_DEVELOPER)\\\\n    case 'planner':\\\\n      return base64ToUtf8(AGENT_PLANNER)\\\\n    case 'speccer':\\\\n      return base64ToUtf8(AGENT_SPECCER)\\\\n    case 'tester':\\\\n      return base64ToUtf8(AGENT_TESTER)\\\\n    default:\\\\n      throw new Error(`getAgentFile agent ${type} not found`)\\\\n  }\\\\n}\\\\n\\\\nexport function base64ToUtf8(base64: string)\\\\n{\\\\n    if (base64.startsWith('data:')) {\\\\n      const base64Data = base64.split(',')[1];\\\\n      return atob(base64Data)\\\\n    }\\\\n    return atob(base64)\\\\n    // const binaryString = atob(base64);\\\\n    // const len = binaryString.length;\\\\n    // const bytes = new Uint8Array(len);\\\\n    // for (let i = 0; i < len; i++) {\\\\n    //     bytes[i] = binaryString.charCodeAt(i);\\\\n    // }\\\\n    // return new TextDecoder('utf-8').decode(bytes);\\\\n}\\\",\\\"src/index.ts\\\":\\\"import path from 'node:path';\\\\nimport fs from 'node:fs';\\\\nimport { EventEmitter } from 'node:events';\\\\nimport { createTaskUtils } from './taskUtils.js';\\\\nimport { createFileTools } from './fileTools.js';\\\\nimport GitManager from './gitManager.js';\\\\nimport { runIsolatedOrchestrator } from './orchestrator.js';\\\\nimport { createCompletionClient, type CompletionClient } from './completion.js';\\\\nimport { setFactoryDebug, setLoggerConfig, getLoggerConfig, logger } from './logger.js';\\\\nimport { createPricingManager, PricingManager, estimateCostUSD } from './pricing.js';\\\\nexport { buildChatTools } from './chatTools.js';\\\\nimport { LLMConfig, RunEvent, AgentRun } from './types.js';\\\\nexport type { AgentType, LLMConfig, RunEvent, AgentRun, ToolResult, AgentResponse, ToolCall, Status, ProjectSpec, Task, Feature } from './types.js';\\\\n\\\\n\\\\nexport type Unsubscribe = () => void;\\\\n\\\\nexport interface RunHandle {\\\\n  id: string;\\\\n  onEvent(cb: (e: RunEvent) => void): Unsubscribe;\\\\n  cancel(reason?: string): void;\\\\n}\\\\n\\\\nexport type RunMeta = {\\\\n  runId: string;\\\\n  projectId?: string;\\\\n  taskId?: string;\\\\n  featureId?: string;\\\\n  state: 'running' | 'completed' | 'cancelled' | 'error';\\\\n  message?: string;\\\\n  progress?: number;\\\\n  costUSD?: number;\\\\n  promptTokens?: number;\\\\n  completionTokens?: number;\\\\n  provider?: string;\\\\n  model?: string;\\\\n  startedAt?: string;\\\\n  updatedAt?: string;\\\\n};\\\\n\\\\nexport interface HistoryStore {\\\\n  addOrUpdateRun(meta: RunMeta): void;\\\\n  updateRunMeta(runId: string, patch: Partial<RunMeta>): void;\\\\n  writeMessages(runId: string, messages: any[]): void;\\\\n  listRuns(): RunMeta[];\\\\n  getRun(runId: string): RunMeta | undefined;\\\\n  getRunMessages(runId: string): any[];\\\\n  deleteRun?(runId: string): void;\\\\n}\\\\n\\\\nfunction ensureDir(p: string) {\\\\n  try { fs.mkdirSync(p, { recursive: true }); } catch {}\\\\n}\\\\n\\\\nexport function createHistoryStore(opts: { dbPath: string }): HistoryStore {\\\\n  // Use a file-backed store under <dirname(dbPath)>/history\\\\n  const baseDir = path.join(path.dirname(opts.dbPath || ''), 'history');\\\\n  const runsDir = path.join(baseDir, 'runs');\\\\n  const indexFile = path.join(baseDir, 'runs.json');\\\\n  ensureDir(runsDir);\\\\n\\\\n  function readIndex(): RunMeta[] {\\\\n    try {\\\\n      const raw = fs.readFileSync(indexFile, 'utf8');\\\\n      const arr = JSON.parse(raw);\\\\n      if (Array.isArray(arr)) return arr as RunMeta[];\\\\n      return [];\\\\n    } catch {\\\\n      return [];\\\\n    }\\\\n  }\\\\n  function writeIndex(list: RunMeta[]) {\\\\n    try { fs.writeFileSync(indexFile, JSON.stringify(list, null, 2), 'utf8'); } catch {}\\\\n  }\\\\n\\\\n  function addOrUpdateRun(meta: RunMeta) {\\\\n    const list = readIndex();\\\\n    const idx = list.findIndex(r => r.runId === meta.runId);\\\\n    const merged = { ...(idx >= 0 ? list[idx] : {}), ...meta } as RunMeta;\\\\n    if (idx >= 0) list[idx] = merged; else list.push(merged);\\\\n    // Keep sorted by updatedAt desc if present\\\\n    list.sort((a, b) => (b.updatedAt || '').localeCompare(a.updatedAt || ''));\\\\n    writeIndex(list);\\\\n  }\\\\n\\\\n  function updateRunMeta(runId: string, patch: Partial<RunMeta>) {\\\\n    const list = readIndex();\\\\n    const idx = list.findIndex(r => r.runId === runId);\\\\n    if (idx >= 0) {\\\\n      list[idx] = { ...list[idx], ...patch, runId } as RunMeta;\\\\n      list.sort((a, b) => (b.updatedAt || '').localeCompare(a.updatedAt || ''));\\\\n      writeIndex(list);\\\\n    } else {\\\\n      addOrUpdateRun({ runId, state: 'running', ...patch } as RunMeta);\\\\n    }\\\\n  }\\\\n\\\\n  function messagesFile(runId: string) { return path.join(runsDir, `${runId}.messages.json`); }\\\\n\\\\n  function writeMessages(runId: string, messages: any[]) {\\\\n    try { fs.writeFileSync(messagesFile(runId), JSON.stringify(messages ?? [], null, 2), 'utf8'); } catch {}\\\\n  }\\\\n\\\\n  function getRunMessages(runId: string): any[] {\\\\n    try {\\\\n      const raw = fs.readFileSync(messagesFile(runId), 'utf8');\\\\n      const arr = JSON.parse(raw);\\\\n      return Array.isArray(arr) ? arr : [];\\\\n    } catch {\\\\n      return [];\\\\n    }\\\\n  }\\\\n\\\\n  function listRuns(): RunMeta[] { return readIndex(); }\\\\n  function getRun(runId: string): RunMeta | undefined { return readIndex().find(r => r.runId === runId); }\\\\n\\\\n  function deleteRun(runId: string): void {\\\\n    // Remove from index\\\\n    const list = readIndex();\\\\n    const filtered = list.filter(r => r.runId !== runId);\\\\n    writeIndex(filtered);\\\\n    // Remove messages file\\\\n    try { fs.unlinkSync(messagesFile(runId)); } catch {}\\\\n  }\\\\n\\\\n  return { addOrUpdateRun, updateRunMeta, writeMessages, listRuns, getRun, getRunMessages, deleteRun } satisfies HistoryStore;\\\\n}\\\\n\\\\nfunction makeId(prefix: string) { return `${prefix}_${Math.random().toString(36).slice(2, 10)}_${Date.now().toString(36)}`; }\\\\n\\\\nfunction buildCompletion(llmConfig: LLMConfig): CompletionClient {\\\\n  // Delegate to completion.ts factory; tolerate missing fields\\\\n  return createCompletionClient(llmConfig);\\\\n}\\\\n\\\\nfunction attachLLMLogging(comp: CompletionClient, emit: (e: RunEvent) => void, opts?: { provider?: string; pricing?: PricingManager }): CompletionClient {\\\\n  // Accumulate usage across the run\\\\n  let totalPrompt = 0;\\\\n  let totalCompletion = 0;\\\\n  let totalUSD = 0;\\\\n\\\\n  // Wrap the completion client to emit llm events including request messages and timing\\\\n  const wrapped: CompletionClient = async (req) => {\\\\n    const startedAt = Date.now();\\\\n    try {\\\\n      emit({ type: 'llm/request', payload: { model: req.model, messages: req.messages } });\\\\n    } catch {}\\\\n    try {\\\\n      const res = await comp(req);\\\\n      const durationMs = Date.now() - startedAt;\\\\n      emit({ type: 'llm/response', payload: { model: req.model, message: res.message, durationMs } });\\\\n      // Usage (if provided by client)\\\\n      const u = res.usage || {};\\\\n      const pDelta = Number(u.promptTokens || 0);\\\\n      const cDelta = Number(u.completionTokens || 0);\\\\n      totalPrompt += pDelta;\\\\n      totalCompletion += cDelta;\\\\n\\\\n      // Compute/accumulate cost incrementally\\\\n      let lastCostUSD: number | undefined = undefined;\\\\n      // Prefer provider-reported cost if available\\\\n      if (u.costUSD != null && isFinite(Number(u.costUSD))) {\\\\n        lastCostUSD = Number(u.costUSD);\\\\n      } else if (opts?.pricing) {\\\\n        const price = opts.pricing.getPrice(u.provider || opts.provider, u.model || req.model);\\\\n        lastCostUSD = estimateCostUSD(pDelta, cDelta, price);\\\\n      }\\\\n      if (lastCostUSD != null) totalUSD += lastCostUSD;\\\\n\\\\n      try {\\\\n        emit({\\\\n          type: 'run/usage',\\\\n          payload: {\\\\n            provider: u.provider || opts?.provider,\\\\n            model: u.model || req.model,\\\\n            promptTokens: totalPrompt,\\\\n            completionTokens: totalCompletion,\\\\n            totalTokens: (totalPrompt + totalCompletion) || u.totalTokens,\\\\n            // Emit 0 when no price is available yet, rather than undefined\\\\n            costUSD: totalUSD,\\\\n            lastDurationMs: durationMs,\\\\n          }\\\\n        } satisfies RunEvent);\\\\n      } catch {}\\\\n      return res;\\\\n    } catch (err) {\\\\n      const durationMs = Date.now() - startedAt;\\\\n      emit({ type: 'llm/error', payload: { error: String((err as Error)?.message || err), durationMs } });\\\\n      throw err;\\\\n    }\\\\n  };\\\\n  return wrapped;\\\\n}\\\\n\\\\nexport function createOrchestrator(opts: { projectRoot?: string; history?: HistoryStore; pricing?: PricingManager }) {\\\\n  const projectRoot = path.resolve(opts.projectRoot || process.cwd());\\\\n\\\\n  // A run registry\\\\n  const runs = new Map<string, { ee: EventEmitter; cancelled: boolean; cancel: (r?: string) => void }>();\\\\n\\\\n  // Pricing manager (load/set defaults from disk on app start)\\\\n  const pricing = opts.pricing || createPricingManager({ projectRoot });\\\\n\\\\n  function newRunHandle(prefix: string): { id: string; ee: EventEmitter; handle: RunHandle; signalCancelled: () => boolean } {\\\\n    const id = makeId(prefix);\\\\n    const ee = new EventEmitter();\\\\n    let cancelled = false;\\\\n    const handle: RunHandle = {\\\\n      id,\\\\n      onEvent: (cb) => {\\\\n        const fn = (e: RunEvent) => cb(e);\\\\n        ee.on('event', fn);\\\\n        return () => { try { ee.off('event', fn); } catch {} };\\\\n      },\\\\n      cancel: (reason?: string) => {\\\\n        if (!cancelled) {\\\\n          cancelled = true;\\\\n          ee.emit('event', { type: 'run/cancelled', payload: { reason } } satisfies RunEvent);\\\\n        }\\\\n      }\\\\n    };\\\\n    runs.set(id, { ee, cancelled, cancel: handle.cancel });\\\\n    return { id, ee, handle, signalCancelled: () => cancelled };\\\\n  }\\\\n\\\\n  function getAgentFromArgs(args: { agentType?: string, agent?: any; metadata?: any }, fallback: any = 'developer') {\\\\n    return args.agentType || args.agent || args.metadata?.agent || fallback;\\\\n  }\\\\n\\\\n  function startRun(args: AgentRun): RunHandle {\\\\n    const { id, ee, handle } = newRunHandle('task');\\\\n    (async () => {\\\\n      ee.emit('event', { type: 'run/start', payload: { scope: 'task', id, taskId: args.taskId, llm: { model: args.llmConfig?.model, provider: args.llmConfig?.provider } } } satisfies RunEvent);\\\\n      try {\\\\n        // Use instance-scoped tools per run to avoid cross-run global state conflicts\\\\n        const taskTools = createTaskUtils(projectRoot);\\\\n        const fileTools = createFileTools(projectRoot);\\\\n\\\\n        const completion = attachLLMLogging(buildCompletion(args.llmConfig), (e) => ee.emit('event', e), { provider: args.llmConfig?.provider, pricing });\\\\n        const agentType = getAgentFromArgs(args, 'developer');\\\\n\\\\n        const projectId = args.projectId\\\\n        const taskId = args.taskId;\\\\n        const featureId = args.featureId;\\\\n        await runIsolatedOrchestrator({ model: args.llmConfig.model, agentType, projectId, taskId, featureId, gitFactory: (p) => new GitManager(p), taskTools, fileTools, completion, emit: (e) => ee.emit('event', e) });\\\\n\\\\n        ee.emit('event', { type: 'run/completed', payload: { ok: true } } satisfies RunEvent);\\\\n      } catch (err) {\\\\n        ee.emit('event', { type: 'run/error', payload: { error: String((err as Error)?.stack || err) } } satisfies RunEvent);\\\\n      } finally {\\\\n        ee.emit('event', { type: 'run/complete' } satisfies RunEvent);\\\\n      }\\\\n    })();\\\\n    return handle;\\\\n  }\\\\n\\\\n  return {\\\\n    startRun,\\\\n    pricing, // expose for external IPC if needed\\\\n  };\\\\n}\\\\n\\\\nexport { setFactoryDebug, setLoggerConfig, getLoggerConfig, logger, createPricingManager };\\\\n\\\"}\"}]",
        "featureId": "__task__",
        "agentType": "speccer",
        "turn": 2,
        "source": "tools",
        "createdAt": "2025-09-08T11:37:36.051Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"We inspected the repository and found taskUtils.ts contains mixed concerns: task IO, feature ops, git-commit workflow helpers, project config, orchestrator helpers, and tester tools. The requirement is to split tools by context and move test-related functions into a new module. We will create atomic features to: audit and propose a target module split, implement a new testTools module and refactor usages, split remaining taskUtils into context-specific modules (taskTools, featureTools, projectTools, workflowTools), update the factory to compose these, update imports/re-exports, add/update README.md and docs/FILE_ORGANISATION.md, and provide transitional compatibility if needed.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"create_feature\",\n      \"args\": {\n        \"title\": \"Audit taskUtils and define target module boundaries\",\n        \"description\": \"Review src/taskUtils.ts to categorize functions into clear contexts: (1) task IO and status (getTask, saveTask, updateTaskStatus), (2) feature ops (updateFeatureStatus, createFeature, updateFeaturePlan, updateFeatureContext, findNextAvailableFeature), (3) workflow and git integration (finishFeature, finishSpec, blockFeature, blockTask, checkAndUpdateTaskCompletion), (4) project config (getProjectDir), (5) testing utilities (getTest, updateAcceptanceCriteria, updateTest, deleteTest, runTest). Produce a brief plan (saved as docs/TOOLS_REFACTOR_PLAN.md) describing the new modules to create (testTools.ts, taskTools.ts, featureTools.ts, workflowTools.ts, projectTools.ts) and the public APIs each should expose, including per-run factory functions mirroring createTaskUtils behavior.\"\n      }\n    },\n    {\n      \"tool_name\": \"create_feature\",\n      \"args\": {\n        \"title\": \"Extract test utilities into src/testTools.ts\",\n        \"description\": \"Create a new module src/testTools.ts that encapsulates all test-related functionality currently in taskUtils: getTest, updateAcceptanceCriteria, updateTest, deleteTest, runTest. Provide both default singleton export (testTools) and a factory createTestTools(projectRoot) similar to fileTools and createTaskUtils patterns. Ensure paths are computed relative to tasks/<taskId>/tests and include ensureDir, timeout handling, and security. Export types as needed. Include local (per-run) variants. Unit-adapt function signatures to match existing calls.\"\n      }\n    },\n    {\n      \"tool_name\": \"create_feature\",\n      \"args\": {\n        \"title\": \"Refactor createTaskUtils to delegate test methods to testTools\",\n        \"description\": \"Modify src/taskUtils.ts to remove inlined test functions and instead import and re-export them via the new testTools module. In the process-wide taskUtils export, drop tester tools from its own implementation and wire through to testTools. In createTaskUtils(projectRoot), instantiate createTestTools(projectRoot) and return its methods (getTest, updateAcceptanceCriteria, updateTest, deleteTest, runTest) on the returned TaskUtils object to preserve API compatibility.\"\n      }\n    },\n    {\n      \"tool_name\": \"create_feature\",\n      \"args\": {\n        \"title\": \"Split taskUtils into context-specific modules (phase 1: interface composition)\",\n        \"description\": \"Introduce new modules without changing behavior: src/taskTools.ts (task IO and status), src/featureTools.ts (feature CRUD and planning/context updates, findNextAvailableFeature, UUID generator), src/workflowTools.ts (blockFeature, blockTask, finishFeature, finishSpec, checkAndUpdateTaskCompletion, with GitManager dependency), src/projectTools.ts (getProjectDir and project path helpers). Move code by extracting functions into these files and export factories createTaskTools, createFeatureTools, createWorkflowTools, createProjectTools with per-run variants where applicable. In src/taskUtils.ts, recompose the same TaskUtils API by importing these new modules and combining their methods into the existing taskUtils and createTaskUtils exports (delegation layer), keeping the public surface unchanged for now.\"\n      }\n    },\n    {\n      \"tool_name\": \"create_feature\",\n      \"args\": {\n        \"title\": \"Update orchestrator and imports to use composed tools\",\n        \"description\": \"Verify src/index.ts and src/orchestrator.ts (and any other usages) import only createTaskUtils and createFileTools. Ensure after refactor the composed taskUtils still satisfies the expected interface. If possible, update runIsolatedOrchestrator to accept separate toolbags (taskTools, featureTools, testTools) in future-friendly manner, but preserve backward compatibility by keeping createTaskUtils returning the union. Add minimal type updates if needed.\"\n      }\n    },\n    {\n      \"tool_name\": \"create_feature\",\n      \"args\": {\n        \"title\": \"Remove dead or duplicate utilities from taskUtils\",\n        \"description\": \"Identify and remove unused or duplicate functions within taskUtils, specifically the internal readFiles function that duplicates fileTools functionality and is not exported, along with root access helpers that are no longer needed after modularization. Ensure no references remain and tests (if any) pass.\"\n      }\n    },\n    {\n      \"tool_name\": \"create_feature\",\n      \"args\": {\n        \"title\": \"Project documentation: README and file organization\",\n        \"description\": \"Create or update top-level README.md to concisely describe each toolset: fileTools, taskTools, featureTools, workflowTools, projectTools, testTools, and how to use the create* factory variants for per-run isolation. Add a brief section on how to extend tools. Add/update docs/FILE_ORGANISATION.md to reflect the new modules and directory layout. Include examples of typical usage snippets. Keep content precise and aligned with current code.\"\n      }\n    },\n    {\n      \"tool_name\": \"create_feature\",\n      \"args\": {\n        \"title\": \"Migration notes and changelog\",\n        \"description\": \"Add docs/MIGRATION.md summarizing the refactor, noting that the public TaskUtils API is preserved but test-related functions are now provided by testTools internally. Document any renamed exports or deprecations and guidance for direct imports if external code was importing from taskUtils subpaths.\"\n      }\n    },\n    {\n      \"tool_name\": \"finish_spec\",\n      \"args\": {}\n    }\n  ]\n}",
        "featureId": "__task__",
        "agentType": "speccer",
        "turn": 3,
        "askedAt": "2025-09-08T11:37:02.749Z",
        "createdAt": "2025-09-08T11:37:36.051Z"
      }
    ],
    "endDate": "2025-09-08T11:37:36.051Z"
  }
}