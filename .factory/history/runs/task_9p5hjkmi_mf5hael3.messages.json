[
  {
    "role": "user",
    "content": "# Developer Agent Task Execution\n\nYou are the Developer Agent. You will be assigned a single feature to implement. Your goal is to complete it by following these steps precisely.\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\nYou can write files using the `write_file` tool. You can rename or moves files using the `rename_file` tool. You can delete files using the `delete_file` tool. \nWhen you're done implementing then call `finish_feature`.\n\n## Workflow\n\n1.  **Implement**: Write or modify files to meet the feature's acceptance criteria. Use the `write_file`, `rename_file` and `delete_file` tools for all file operations.\n2.  **Complete the Feature**: When the feature is complete, you **MUST** call the `finish_feature` tool. This is your final step for a successful implementation.\n3.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_feature` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n\n#CURRENT TASK (ID: f67e8921-b197-40c9-9154-e95db8f27deb)\n##TITLE:\nFactory-ts improvements\n##DESCRIPTION:\nVarious improvements to add to the project and the factory-ts package\n\n\n#ASSIGNED FEATURE: The Agent ChatConversation.tsx view inside AgentsView.tsx doesn't display Features or turns correctly (ID: 82b9481c-7129-4bea-8029-0e41a56531fe)\n##DESCRIPTION: Each task run comprises of the agent entering a conversation about a task's feature. This might take multiple turns - where a turn is a single message being sent by the LLM and the single response to it. The first initial message is Turn 0. The final message by the agent should be without a response ( it will be the final turn). It seems the orchestrator (inside factory-ts) captures these incorrectly.\nFix this behaviour so it matches the above description.\n\n##REJECTION REASON:\nStill incorrect. Inside orchestrator.ts there's a function runOrchestrator that is the main logic behind running features for a task. The sequence of Feature runs should be stored for a given task run - right now it seems that it's just the last feature that is recorded.\n\n\n\n\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths.\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- write_file(filename: str, content: str) - Create or overwrite a file with the given content. Always use this to write code or docs.\n- rename_file(filename: str, new_filename: str) - Rename or move a file from one path to another.\n- delete_file(filename: str) - Delete a file. Use with caution and only when necessary.\n- run_test() -> str - Run the test for the current feature and return the output. Use to verify implementation.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n{\n  \"thoughts\": \"A string explaining your reasoning, analysis, and plan for this step. For example: 'I need to create the main application file and then add the basic boilerplate.'\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"name_of_the_tool_to_call\",\n      \"arguments\": {\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\"\n      }\n    }\n  ]\n}\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"# File Organisation\\n\\nPurpose\\n- Provide a high-level map of the repository so contributors and agents can quickly find the right area.\\n- This is not a change log and not a per-file inventory.\\n\\nEditing Rules (read before updating)\\n- Only document major directories and subsystems. Do not list individual files.\\n- Keep bullets short (one sentence) and avoid \\\"New:\\\" or historical notes.\\n- When adding/removing a major directory or moving a subsystem, update a single bullet here.\\n- Prefer linking or pointing to deeper docs (README/OVERVIEW) rather than describing internals here.\\n- Never document build related artifacts.\\n\\nTop-Level Layout\\n- docs/: Project-wide documentation and specs; single source of truth for protocols and workflows.\\n- src/: Application source (Electron app: main, preload, renderer, and tooling).\\n  - renderer/: React UI (components, screens, hooks, services, navigation, preview runtime).\\n    - components/agents/: Agent-specific UI (status chips, run bullets, model selectors, project/cost/token chips).\\n    - services/: Renderer-side services (e.g., pricingService for LLM price lookup via IPC).\\n  - tools/: Developer and agent tooling (preview analyzer, factory integration, helpers).\\n  - main.js: Electron main process entry.\\n  - preload.js: Safe IPC surface exposed to the renderer.\\n- packages/: Local monorepo packages.\\n  - factory-ts/: Agent orchestration library (orchestrator, pricing, history, completion, git integration).\\n- scripts/: Project automation scripts and CLIs.\\n- Root config files: package.json, tsconfig.json, tailwind/postcss configs, vite configs, forge config, .env.\\n\\nWhere to Learn More\\n- Agents and roles: packages/factory-ts/docs (AGENT_*.md).\\n- Factory TS overview and APIs: packages/factory-ts (see README/OVERVIEW files in that package).\\n- Preview system: see src/renderer/preview and related docs in docs/ (preview usage and analyzer).\\n- IPC and factory integration: src/tools/factory (renderer bridge and main process handlers).\\n\\nConventions (brief)\\n- Keep cross-cutting documentation in docs/; place domain-specific or area-specific READMEs next to the code they describe.\\n- Use descriptive directory names and keep responsibilities separated by area (renderer vs main vs tools vs packages).\\n\\nEnvironment & Credentials\\n- .env at the repo root is used for local development (e.g., credentials consumed by tooling and factory-ts).\\n\\nNotes\\n- If you are unsure whether something belongs here, it probably belongs in a local README under its directory, with this file providing only a one-line pointer to that area.\\n\",\"src/renderer/components/agents/ChatConversation.tsx\":\"import React, { useEffect, useMemo, useRef, useState } from 'react';\\nimport type { AgentRun, AgentRunMessage } from '../../services/agentsService';\\nimport RichText from '../ui/RichText';\\n\\n// Parse assistant JSON response to extract thoughts and tool calls safely\\nfunction parseAssistant(content: string): { thoughts?: string; tool_calls?: { tool_name?: string; tool?: string; name?: string; arguments?: any; parameters?: any }[] } | null {\\n  try {\\n    const obj = JSON.parse(content);\\n    if (obj && typeof obj === 'object') return obj;\\n    return null;\\n  } catch {\\n    return null;\\n  }\\n}\\n\\nfunction classNames(...xs: (string | false | null | undefined)[]) {\\n  return xs.filter(Boolean).join(' ');\\n}\\n\\nfunction JsonPreview({ value, maxChars = 200 }: { value: any; maxChars?: number }) {\\n  const str = typeof value === 'string' ? value : JSON.stringify(value, null, 2);\\n  if (str.length <= maxChars) return (<pre className=\\\"text-xs whitespace-pre-wrap break-words\\\">{str}</pre>);\\n  const [open, setOpen] = useState(false);\\n  return (\\n    <div>\\n      <pre className=\\\"text-xs whitespace-pre-wrap break-words\\\">{open ? str : str.slice(0, maxChars) + '\\\\u2026'}</pre>\\n      <button className=\\\"btn-link text-xs mt-1\\\" onClick={() => setOpen(v => !v)}>{open ? 'Show less' : 'Show more'}</button>\\n    </div>\\n  );\\n}\\n\\nfunction Collapsible({ title, children, defaultOpen = false }: { title: React.ReactNode; children: React.ReactNode; defaultOpen?: boolean }) {\\n  const [open, setOpen] = useState(defaultOpen);\\n  return (\\n    <div className=\\\"border rounded-md border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900\\\">\\n      <button className=\\\"w-full flex items-center justify-between px-3 py-2 text-left hover:bg-neutral-50 dark:hover:bg-neutral-800/50\\\" onClick={() => setOpen(v => !v)}>\\n        <span className=\\\"text-xs font-medium truncate pr-2\\\">{title}</span>\\n        <span className=\\\"text-xs text-neutral-500\\\">{open ? '\\\\u2212' : '+'}</span>\\n      </button>\\n      {open ? (\\n        <div className=\\\"px-3 py-2 border-t border-neutral-200 dark:border-neutral-800\\\">{children}</div>\\n      ) : null}\\n    </div>\\n  );\\n}\\n\\nfunction ToolCallRow({ call, resultText, index }: { call: any; resultText?: string; index: number }) {\\n  const name = call.tool_name || call.tool || call.name || 'tool';\\n  const args = call.arguments ?? call.parameters ?? {};\\n  const isHeavy = name === 'read_files' || name === 'write_file';\\n\\n  return (\\n    <div className=\\\"rounded-md border border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/40\\\">\\n      <div className=\\\"px-3 py-2 flex items-start justify-between gap-3\\\">\\n        <div className=\\\"min-w-0\\\">\\n          <div className=\\\"text-xs font-semibold\\\">{index + 1}. {name}</div>\\n          <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400\\\">Arguments</div>\\n        </div>\\n      </div>\\n      <div className=\\\"px-3 pb-2\\\">\\n        {isHeavy ? (\\n          <Collapsible title={<span>View arguments</span>}>\\n            <JsonPreview value={args} maxChars={500} />\\n          </Collapsible>\\n        ) : (\\n          <div className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 max-h-60 overflow-auto\\\">\\n            <JsonPreview value={args} maxChars={400} />\\n          </div>\\n        )}\\n      </div>\\n      {resultText != null && (\\n        <div className=\\\"px-3 pb-3\\\">\\n          <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400 mb-1\\\">Result</div>\\n          {isHeavy ? (\\n            <Collapsible title={<span>View result</span>}>\\n              <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={resultText} /></div>\\n            </Collapsible>\\n          ) : (\\n            <div className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 text-xs whitespace-pre-wrap break-words max-h-60 overflow-auto\\\">\\n              <RichText text={resultText} />\\n            </div>\\n          )}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\\nfunction parseToolResultsMessage(msg?: AgentRunMessage): string[] {\\n  if (!msg) return [];\\n  const s = msg.content || '';\\n  const lines = s.split(/\\\\r?\\\\n/);\\n  const out: string[] = [];\\n  for (const ln of lines) {\\n    if (!ln) continue;\\n    if (ln.startsWith('---')) continue; // header line\\n    if (ln.startsWith('Tool ')) {\\n      const i = ln.indexOf(' returned: ');\\n      if (i > 0) out.push(ln.substring(i + ' returned: '.length + 'Tool '.length + (ln.startsWith('Tool ') ? 0 : 0))); // Keep right side after 'returned: '\\n      else out.push(ln);\\n    } else {\\n      out.push(ln);\\n    }\\n  }\\n  return out;\\n}\\n\\n// Build conversation turns sequentially to ensure full history renders even if 'turn' is missing\\nfunction useTurnBundles(messages: AgentRunMessage[] | undefined) {\\n  return useMemo(() => {\\n    const systemMsgs: AgentRunMessage[] = [];\\n\\n    type Turn = { index: number; user?: AgentRunMessage; assistant?: AgentRunMessage; tools?: AgentRunMessage };\\n    const turns: Turn[] = [];\\n    let current: Turn | null = null;\\n\\n    const isToolMsg = (m: AgentRunMessage) => {\\n      const content = m.content || '';\\n      // Tool messages may be persisted with role 'tool' or with role 'user' but content prefixed\\n      const hinted = (m as any).source === 'tools';\\n      return m.role === 'tool' || hinted || content.startsWith('--- TOOL RESULTS ---');\\n    };\\n\\n    for (const m of messages || []) {\\n      const role = m.role || '';\\n\\n      // Collect first system prompt and any system messages separately\\n      if (role === 'system') {\\n        systemMsgs.push(m);\\n        continue;\\n      }\\n\\n      // Tool results should attach to the current turn, not start a new user turn\\n      if (isToolMsg(m)) {\\n        if (!current) current = { index: turns.length };\\n        current.tools = m;\\n        // When tools are attached, we close the turn and start a new one next time\\n        turns.push(current);\\n        current = null;\\n        continue;\\n      }\\n\\n      if (role === 'user') {\\n        // Regular user messages begin a new turn (e.g., for task runs without features)\\n        if (current && (current.user || current.assistant || current.tools)) {\\n          turns.push(current);\\n          current = null;\\n        }\\n        current = { index: turns.length, user: m };\\n        continue;\\n      }\\n\\n      if (role === 'assistant') {\\n        if (!current) current = { index: turns.length };\\n        current.assistant = m;\\n        // Do not push yet; we might receive tool results next\\n        continue;\\n      }\\n\\n      // Fallback: if message type doesn't match, keep it as a system info\\n      systemMsgs.push(m);\\n    }\\n\\n    // If there's a dangling turn (e.g., final assistant message requesting finish), push it\\n    if (current && (current.user || current.assistant || current.tools)) {\\n      turns.push(current);\\n    }\\n\\n    return { systemMsgs, turns } as { systemMsgs: AgentRunMessage[]; turns: { index: number; user?: AgentRunMessage; assistant?: AgentRunMessage; tools?: AgentRunMessage }[] };\\n  }, [messages]);\\n}\\n\\nfunction isLargeText(text?: string) {\\n  if (!text) return false;\\n  const len = text.length;\\n  const lines = text.split(/\\\\r?\\\\n/).length;\\n  return len > 800 || lines > 16;\\n}\\n\\nfunction ScrollableTextBox({ text, className }: { text: string; className?: string }) {\\n  return (\\n    <div className={className}>\\n      <div className=\\\"rounded border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-950 p-2 max-h-64 overflow-auto text-xs whitespace-pre-wrap break-words\\\">\\n        <RichText text={text} />\\n      </div>\\n    </div>\\n  );\\n}\\n\\nexport default function ChatConversation({ run }: { run: AgentRun }) {\\n  const lastTurnRef = useRef<HTMLLIElement | null>(null);\\n  const { systemMsgs, turns } = useTurnBundles(run.messages);\\n\\n  // Scroll to last turn on initial open and whenever turn count changes\\n  useEffect(() => {\\n    if (lastTurnRef.current) {\\n      lastTurnRef.current.scrollIntoView({ behavior: 'smooth', block: 'nearest' });\\n    }\\n  }, [turns.length]);\\n\\n  const systemPrompt = useMemo(() => {\\n    // Prefer first system role message; fallback to the bootstrap message containing #CURRENT TASK\\n    const m = systemMsgs[0];\\n    return m?.content;\\n  }, [systemMsgs, run.messages]);\\n\\n  const lastIndex = turns.length - 1;\\n\\n  return (\\n    <div className=\\\"h=[60vh] max-h-[70vh] overflow-auto bg-neutral-50 dark:bg-neutral-900 rounded-md border border-neutral-200 dark:border-neutral-800 p-3 space-y-3\\\">\\n      {systemPrompt ? (\\n        <Collapsible title={<span>System prompt</span>} defaultOpen={false}>\\n          {isLargeText(systemPrompt) ? (\\n            <ScrollableTextBox text={systemPrompt} />\\n          ) : (\\n            <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={systemPrompt} /></div>\\n          )}\\n        </Collapsible>\\n      ) : null}\\n\\n      {turns.length === 0 ? (\\n        <div className=\\\"text-sm text-neutral-500\\\">No conversation yet.</div>\\n      ) : (\\n        <ul className=\\\"space-y-3\\\">\\n          {turns.map(({ index, user, assistant, tools }) => {\\n            const parsed = assistant ? parseAssistant(assistant.content || '') : null;\\n            const toolCalls = parsed?.tool_calls || [];\\n            const results = parseToolResultsMessage(tools);\\n\\n            // Build a short title for the turn header\\n            const titleParts: string[] = [];\\n            titleParts.push(`Turn ${index + 1}`);\\n            if ((assistant as any)?.durationMs) titleParts.push(`${(assistant as any).durationMs}ms`);\\n            const title = titleParts.join(' \\\\u00b7 ');\\n\\n            const isLast = index === lastIndex;\\n\\n            return (\\n              <li key={index} ref={isLast ? lastTurnRef : undefined}>\\n                <Collapsible title={<span className=\\\"flex items-center gap-2\\\">{title}</span>} defaultOpen={isLast}>\\n                  <div className=\\\"space-y-2\\\">\\n                    {user ? (\\n                      <div className=\\\"max-w-[80%] rounded-2xl px-3 py-2 bg-neutral-100 text-neutral-900 dark:bg-neutral-800 dark:text-neutral-50 shadow-sm\\\">\\n                        <div className=\\\"text-[11px] font-medium mb-1\\\">User</div>\\n                        {isLargeText(user.content) ? (\\n                          <ScrollableTextBox text={user.content || ''} />\\n                        ) : (\\n                          <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={user.content} /></div>\\n                        )}\\n                      </div>\\n                    ) : null}\\n\\n                    {parsed?.thoughts ? (\\n                      <div className=\\\"max-w-[80%] rounded-2xl px-3 py-2 bg-blue-100 text-blue-900 dark:bg-blue-900/30 dark:text-blue-100 shadow-sm\\\">\\n                        {isLargeText(parsed.thoughts) ? (\\n                          <ScrollableTextBox text={parsed.thoughts || ''} />\\n                        ) : (\\n                          <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={parsed.thoughts} /></div>\\n                        )}\\n                      </div>\\n                    ) : assistant ? (\\n                      <div className=\\\"max-w-[80%] rounded-2xl px-3 py-2 bg-blue-50 text-blue-900 dark:bg-blue-900/20 dark:text-blue-100 shadow-sm\\\">\\n                        <div className=\\\"text-[11px] font-medium mb-1\\\">Assistant</div>\\n                        {isLargeText(assistant.content) ? (\\n                          <ScrollableTextBox text={assistant.content || ''} />\\n                        ) : (\\n                          <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={assistant.content} /></div>\\n                        )}\\n                      </div>\\n                    ) : null}\\n\\n                    {toolCalls.length > 0 ? (\\n                      <div className=\\\"space-y-2\\\">\\n                        {toolCalls.map((call, i) => (\\n                          <ToolCallRow key={i} call={call} index={i} resultText={results[i]} />\\n                        ))}\\n                      </div>\\n                    ) : null}\\n\\n                    {toolCalls.length === 0 && results.length > 0 ? (\\n                      <div className=\\\"rounded-md border border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/40 p-2\\\">\\n                        <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400 mb-1\\\">Tool results</div>\\n                        {results.map((r, i) => (\\n                          <div key={i} className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 mb-2 last:mb-0 text-xs whitespace-pre-wrap break-words max-h-60 overflow-auto\\\">\\n                            <RichText text={r} />\\n                          </div>\\n                        ))}\\n                      </div>\\n                    ) : null}\\n                  </div>\\n                </Collapsible>\\n              </li>\\n            );\\n          })}\\n        </ul>\\n      )}\\n    </div>\\n  );\\n}\\n\",\"src/renderer/screens/AgentsView.tsx\":\"import React, { useEffect, useMemo, useState } from 'react';\\nimport { useAgents } from '../hooks/useAgents';\\nimport { useActiveProject } from '../projects/ProjectContext';\\nimport type { AgentRun } from '../services/agentsService';\\nimport ChatConversation from '../components/agents/ChatConversation';\\nimport AgentRunRow from '../components/agents/AgentRunRow';\\nimport ModelChip from '../components/agents/ModelChip';\\n\\nfunction formatUSD(n?: number) {\\n  if (n == null) return '\\\\u2014';\\n  return `$${n.toFixed(4)}`;\\n}\\n\\nfunction formatTime(iso?: string) {\\n  if (!iso) return '';\\n  try {\\n    const d = new Date(iso);\\n    return d.toLocaleTimeString();\\n  } catch {\\n    return iso ?? '';\\n  }\\n}\\n\\nexport default function AgentsView() {\\n  const { runs, activeRuns, cancelRun } = useAgents();\\n  const { projectId } = useActiveProject();\\n  const [openRunId, setOpenRunId] = useState<string | null>(null);\\n\\n  const projectRuns = useMemo(() => runs.filter(r => r.projectId === projectId), [runs, projectId]);\\n  const activeProjectRuns = useMemo(() => activeRuns.filter(r => r.projectId === projectId), [activeRuns, projectId]);\\n\\n  useEffect(() => {\\n    const hash = (window.location.hash || '').replace(/^#/, '');\\n    const m = /^agents\\\\/run\\\\/(.+)$/.exec(hash);\\n    if (m && m[1]) {\\n      const id = m[1];\\n      setTimeout(() => {\\n        const el = document.getElementById(`run-${id}`);\\n        if (el) {\\n          el.scrollIntoView({ block: 'center', behavior: 'smooth' });\\n          el.classList.add('highlighted');\\n          setTimeout(() => el.classList.remove('highlighted'), 2000);\\n        }\\n      }, 0);\\n    }\\n  }, [projectRuns.length]);\\n\\n  const findRunById = (id: string | null): AgentRun | undefined => {\\n    if (!id) return undefined;\\n    return projectRuns.find(r => r.runId === id) || activeProjectRuns.find(r => r.runId === id);\\n  };\\n\\n  const selectedRun = findRunById(openRunId || '');\\n\\n  return (\\n    <div className=\\\"flex-1 overflow-auto\\\">\\n      <div className=\\\"px-4 py-3 border-b border-neutral-200 dark:border-neutral-800\\\">\\n        <div className=\\\"text-lg font-semibold\\\">Agents</div>\\n        <div className=\\\"text-sm text-neutral-600 dark:text-neutral-400\\\">Monitor running agents, usage and costs</div>\\n      </div>\\n\\n      <div className=\\\"p-4 space-y-6\\\">\\n        <section>\\n          <div className=\\\"flex items-center justify-between mb-2\\\">\\n            <h2 className=\\\"text-sm font-semibold text-neutral-800 dark:text-neutral-200\\\">Active ({activeProjectRuns.length})</h2>\\n          </div>\\n          {activeProjectRuns.length === 0 ? (\\n            <div className=\\\"text-sm text-neutral-500\\\">No active agents.</div>\\n          ) : (\\n            <div className=\\\"overflow-auto border rounded-md border-neutral-200 dark:border-neutral-800\\\">\\n              <table className=\\\"min-w-full text-sm\\\">\\n                <thead className=\\\"bg-neutral-50 dark:bg-neutral-800/50 text-neutral-600 dark:text-neutral-400\\\">\\n                  <tr>\\n                    <th className=\\\"text-left px-3 py-2\\\">Run</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Task</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Status</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Model</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Turn</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Cost</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Tokens</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Duration</th>\\n                    <th className=\\\"text-right px-3 py-2\\\">Actions</th>\\n                  </tr>\\n                </thead>\\n                <tbody>\\n                  {activeProjectRuns.map(r => (\\n                    <AgentRunRow key={r.runId ?? Math.random().toString(36)} run={r} onView={(id) => setOpenRunId(id)} onCancel={(id) => cancelRun(id)} showModel />\\n                  ))}\\n                </tbody>\\n              </table>\\n            </div>\\n          )}\\n        </section>\\n\\n        <section>\\n          <div className=\\\"flex items-center justify-between mb-2\\\">\\n            <h2 className=\\\"text-sm font-semibold text-neutral-800 dark:text-neutral-200\\\">History ({projectRuns.length})</h2>\\n          </div>\\n          {projectRuns.length === 0 ? (\\n            <div className=\\\"text-sm text-neutral-500\\\">No runs yet for this project.</div>\\n          ) : (\\n            <div className=\\\"overflow-auto border rounded-md border-neutral-200 dark:border-neutral-800\\\">\\n              <table className=\\\"min-w-full text-sm\\\">\\n                <thead className=\\\"bg-neutral-50 dark:bg-neutral-800/50 text-neutral-600 dark:text-neutral-400\\\">\\n                  <tr>\\n                    <th className=\\\"text-left px-3 py-2\\\">Run</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Task</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Status</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Model</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Turn</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Cost</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Tokens</th>\\n                    <th className=\\\"text-left px-3 py-2\\\">Duration</th>\\n                    <th className=\\\"text-right px-3 py-2\\\">Actions</th>\\n                  </tr>\\n                </thead>\\n                <tbody>\\n                  {projectRuns.map(r => (\\n                    <AgentRunRow key={r.runId ?? Math.random().toString(36)} run={r} onView={(id) => setOpenRunId(id)} onCancel={(id) => cancelRun(id)} showModel />\\n                  ))}\\n                </tbody>\\n              </table>\\n            </div>\\n          )}\\n        </section>\\n      </div>\\n\\n      {selectedRun ? (\\n        <div className=\\\"fixed inset-0 z-50 flex items-center justify-center\\\">\\n          <div className=\\\"absolute inset-0 bg-black/40\\\" onClick={() => setOpenRunId(null)} />\\n          <div className=\\\"relative bg-white dark:bg-neutral-950 rounded-lg shadow-xl w-[92vw] max-w-5xl max-h-[90vh] border border-neutral-200 dark:border-neutral-800\\\">\\n            <div className=\\\"px-4 py-3 border-b border-neutral-200 dark:border-neutral-800 flex items-center justify-between\\\">\\n              <div className=\\\"min-w-0\\\">\\n                <div className=\\\"font-semibold text-sm truncate\\\">Run #{selectedRun.runId.slice(0,8)} \\\\u00b7 {selectedRun.taskId ?? 'Task'}{selectedRun.featureId ? ` \\\\u00b7 Feature ${selectedRun.featureId}` : ''}</div>\\n                <div className=\\\"text-xs text-neutral-500 truncate flex items-center gap-2\\\">\\n                  <ModelChip provider={selectedRun.provider} model={selectedRun.model} />\\n                  <span>\\\\u00b7 {selectedRun.state} \\\\u00b7 Updated {formatTime(selectedRun.updatedAt)}</span>\\n                </div>\\n              </div>\\n              <button className=\\\"btn-secondary\\\" onClick={() => setOpenRunId(null)}>Close</button>\\n            </div>\\n            <div className=\\\"p-4\\\">\\n              <ChatConversation run={selectedRun} />\\n            </div>\\n          </div>\\n        </div>\\n      ) : null}\\n    </div>\\n  );\\n}\\n\",\"packages/factory-ts/src/orchestrator.ts\":\"import fs from 'node:fs';\\nimport path from 'node:path';\\nimport os from 'node:os';\\nimport { AgentResponse, CompletionClient, CompletionMessage, Feature, Task, ToolCall } from './types.js';\\nimport type { TaskUtils } from './taskUtils.js';\\nimport type { FileTools } from './fileTools.js';\\nimport type { GitManager } from './gitManager.js';\\nimport { logger, logLLMStep } from './logger.js';\\n\\nconst MAX_TURNS_PER_FEATURE = 100;\\n\\n// Prefer process.cwd(), but do not assume it points to a real filesystem root when packaged (asar)\\nconst FRAMEWORK_ROOT = path.resolve(process.cwd());\\nconst NEWLINE = '\\\\n';\\n\\nfunction loadAgentDocs(agent: string): string {\\n  // Mirror Python: docs live under packages/factory-ts/docs\\n  const p = path.join(FRAMEWORK_ROOT, 'packages', 'factory-ts', 'docs', `AGENT_${agent.toUpperCase()}.md`);\\n  return fs.readFileSync(p, 'utf8');\\n}\\n\\nfunction loadProtocolExample(): string {\\n  try {\\n    const p = path.join(FRAMEWORK_ROOT, 'packages', 'factory-ts', 'docs', 'agent_response_example.json');\\n    const data = JSON.parse(fs.readFileSync(p, 'utf8'));\\n    return JSON.stringify(data, null, 2);\\n  } catch (e) {\\n    return '{\\\\n  \\\"thoughts\\\": \\\"Your reasoning here...\\\",\\\\n  \\\"tool_calls\\\": [ ... ]\\\\n}';\\n  }\\n}\\n\\nconst PROTOCOL_INSTRUCTIONS = (() => {\\n  const example = loadProtocolExample();\\n  return [\\n    'You **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:',\\n    '```json',\\n    example,\\n    '```',\\n    'The thoughts field is for your reasoning, and tool_calls is a list of actions to execute.',\\n    'Your response will be parsed as JSON. Do not include any text outside of this JSON object.'\\n  ].join('\\\\n');\\n})();\\n\\n// Human-readable descriptions for tools to avoid duplicating them in agent docs\\nconst TOOL_DESCRIPTIONS: Record<string, string> = {\\n  // Base tools\\n  read_files: 'Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).',\\n  search_files: 'Search for files by name or textual content under the given path. Returns matching relative paths.',\\n  list_files: 'List files and directories at a relative path from the project root.',\\n  finish_feature: 'Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.',\\n  block_feature: 'Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).',\\n\\n  // Speccer\\n  create_feature: 'Define and add a new, atomic feature to the task. Include a concise title and a clear description.',\\n  finish_spec: 'Signal that the feature specification is complete for the current task.',\\n  block_task: 'Stop work on the task and report why you are blocked at the task level.',\\n\\n  // Developer\\n  write_file: 'Create or overwrite a file with the given content. Always use this to write code or docs.',\\n  rename_file: 'Rename or move a file from one path to another.',\\n  delete_file: 'Delete a file. Use with caution and only when necessary.',\\n  run_test: 'Run the test for the current feature and return the output. Use to verify implementation.',\\n\\n  // Planner\\n  update_feature_plan: 'Save a concise, step-by-step implementation plan for the assigned feature.',\\n\\n  // Tester\\n  update_acceptance_criteria: 'Save a clear, verifiable list of acceptance criteria for the assigned feature.',\\n  update_test: 'Save the Python test script that validates the acceptance criteria for this feature.',\\n\\n  // Contexter\\n  update_feature_context: 'Save the minimal set of file paths (relative to repo root) required to implement the feature.'\\n};\\n\\nfunction toolSigsForAgent(agent: string, taskTools: TaskUtils, fileTools: FileTools, git: GitManager): [Record<string, (args: any) => Promise<any> | any>, string[]] {\\n  const base: Record<string, [(args: any) => Promise<any> | any, string]> = {\\n    read_files: [ (args: { paths: string[] }) => fileTools.readFiles(args.paths), \\\"read_files(paths: list[str]) -> list[str]\\\" ],\\n    search_files: [ (args: { query: string; path?: string }) => fileTools.searchFiles(args.query, args.path ?? '.'), \\\"search_files(query: str, path: str = '.') -> list[str]\\\" ],\\n    block_feature: [ (args: { task_id: string; feature_id: string; reason: string }) => taskTools.blockFeature?.(args.task_id, args.feature_id, args.reason, agent, git), 'block_feature(reason: str)' ],\\n    finish_feature: [ (args: { task_id: string; feature_id: string }) => taskTools.finishFeature?.(args.task_id, args.feature_id, agent, git), 'finish_feature()' ],\\n    list_files: [ (args: { path: string }) => fileTools.listFiles(args.path), 'list_files(path: str)' ],\\n  };\\n\\n  const agentTools: Record<string, [(args: any) => Promise<any> | any, string]> = {};\\n\\n  if (agent === 'speccer') {\\n    agentTools.create_feature = [ (args: { task_id: string; title: string; description: string }) => taskTools.createFeature?.(args.task_id, args.title, args.description), 'create_feature(title: str, description: str)' ];\\n    agentTools.finish_spec = [ (args: { task_id: string }) => taskTools.finishSpec?.(args.task_id, agent, git), 'finish_spec()' ];\\n    agentTools.block_task = [ (args: { task_id: string; reason: string }) => taskTools.blockTask?.(args.task_id, args.reason, agent, git), 'block_task()' ];\\n  } else if (agent === 'developer') {\\n    agentTools.write_file = [ (args: { filename: string; content: string }) => fileTools.writeFile(args.filename, args.content), 'write_file(filename: str, content: str)' ];\\n    agentTools.rename_file = [ (args: { filename: string; new_filename: string }) => fileTools.renameFile(args.filename, args.new_filename), 'rename_file(filename: str, new_filename: str)' ];\\n    agentTools.delete_file = [ (args: { filename: string }) => fileTools.deleteFile(args.filename), 'delete_file(filename: str)' ];\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => taskTools.runTest?.(args.task_id, args.feature_id), 'run_test() -> str' ];\\n  } else if (agent === 'planner') {\\n    agentTools.update_feature_plan = [ (args: { task_id: string; feature_id: string; plan: any }) => taskTools.updateFeaturePlan?.(args.task_id, args.feature_id, args.plan), 'update_feature_plan(plan: str)' ];\\n  } else if (agent === 'tester') {\\n    agentTools.update_acceptance_criteria = [ (args: { task_id: string; feature_id: string; criteria: string[] }) => taskTools.updateAcceptanceCriteria?.(args.task_id, args.feature_id, args.criteria), 'update_acceptance_criteria(criteria: list[str])' ];\\n    agentTools.update_test = [ (args: { task_id: string; feature_id: string; test: string }) => taskTools.updateTest?.(args.task_id, args.feature_id, args.test), 'update_test(test: str)' ];\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => taskTools.runTest?.(args.task_id, args.feature_id), 'run_test() -> str' ];\\n  } else if (agent === 'contexter') {\\n    agentTools.update_feature_context = [ (args: { task_id: string; feature_id: string; context: string[] }) => taskTools.updateFeatureContext?.(args.task_id, args.feature_id, args.context), 'update_feature_context(context: list[str])' ];\\n  }\\n\\n  const merged = { ...base, ...agentTools };\\n  const funcs: Record<string, (args: any) => Promise<any> | any> = {};\\n  const sigs: string[] = [];\\n  for (const [name, [fn, sig]] of Object.entries(merged)) {\\n    if (fn) {\\n      funcs[name] = fn;\\n      const desc = TOOL_DESCRIPTIONS[name] ? ` - ${TOOL_DESCRIPTIONS[name]}` : '';\\n      sigs.push(`${sig}${desc}`);\\n    }\\n  }\\n  return [funcs, sigs];\\n}\\n\\nfunction constructSystemPrompt(agent: string, task: Task, feature: Feature | null, agentSystemPrompt: string, context: string, toolSignatures: string[]): string {\\n  const plan = feature && (agent === 'developer' || agent === 'tester' || agent === 'contexter' || agent === 'planner') ? feature.plan : undefined;\\n  const acceptance = feature && (agent === 'developer' || agent === 'tester') ? feature.acceptance : undefined\\n  const acceptanceStr = acceptance?.map((c, i) => `${i + 1}. ${c}`).join('\\\\n');\\n  const toolSignaturesStr = toolSignatures.map(sig => `- ${sig}`).join('\\\\n');\\n\\n  const featureBlock = feature ? `#ASSIGNED FEATURE: ${feature.title} (ID: ${feature.id})${NEWLINE}##DESCRIPTION: ${feature.description}${NEWLINE}` : '';\\n  const featureRejection = feature?.rejection ? `##REJECTION REASON:${NEWLINE}${feature.rejection}${NEWLINE}` : '';\\n  const taskRejection = task.rejection ? `##REJECTION REASON:${NEWLINE}${task.rejection}` : '';\\n\\n  return [\\n    agentSystemPrompt,\\n    `#CURRENT TASK (ID: ${task.id})`,\\n    '##TITLE:',\\n    task.title,\\n    '##DESCRIPTION:',\\n    task.description,\\n    taskRejection,\\n    '',\\n    featureBlock,\\n    featureRejection,\\n    plan ? '#THE PLAN' + plan : '',\\n    '',\\n    acceptanceStr ? '#ACCEPTANCE CRITERIA:' + acceptanceStr : '',\\n    '',\\n    '#TOOL SIGNATURES:',\\n    `${toolSignaturesStr}`,\\n    '',\\n    '#RESPONSE FORMAT INSTRUCTIONS:',\\n    PROTOCOL_INSTRUCTIONS,\\n    '',\\n    '#CONTEXT FILES PROVIDED:',\\n    context,\\n    '',\\n    'Begin now.'\\n  ].join('\\\\n');\\n}\\n\\nasync function runConversation(opts: {\\n  model: string;\\n  availableTools: Record<string, (args: any) => Promise<any> | any>;\\n  systemPrompt: string;\\n  task: Task;\\n  feature: Feature | null;\\n  agentType: string;\\n  taskTools: TaskUtils;\\n  git: GitManager;\\n  completion: CompletionClient;\\n  complete: (why: 'finish' | 'block' | 'max_turns', info?: any) => void;\\n  emit?: (e: { type: string; payload?: any }) => void; // event sink for logging/stats\\n}) {\\n  const { model, availableTools, systemPrompt, task, feature, agentType, taskTools, git, completion, complete, emit } = opts;\\n  const doEmit = (e: { type: string; payload?: any }) => { try { emit?.(e); } catch {} };\\n\\n  const messages: CompletionMessage[] = [{ role: 'user', content: systemPrompt }];\\n  doEmit({ type: 'llm/messages/init', payload: { messages: messages.slice(), turn: 0 } });\\n\\n  for (let i = 0; i < MAX_TURNS_PER_FEATURE; i++) {\\n    try {\\n      // Emit snapshot of request context before calling the LLM\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), turn: i } });\\n      const startedAt = Date.now();\\n      const res = await completion({ model, messages, response_format: { type: 'json_object' } });\\n      const durationMs = Date.now() - startedAt;\\n\\n      const assistant = { role: 'assistant' as const, content: res.message.content };\\n      messages.push(assistant);\\n      // Emit assistant message and timing\\n      doEmit({ type: 'llm/message', payload: { message: assistant, turn: i, durationMs } });\\n\\n      // Parse and log succinct info to console via logger\\n      let parsed: AgentResponse | undefined;\\n      try { parsed = JSON.parse(assistant.content) as AgentResponse; } catch (e) { parsed = undefined; }\\n      const toolCalls: ToolCall[] = parsed?.tool_calls ?? [];\\n      logLLMStep({ turn: i, thoughts: parsed?.thoughts, toolCalls, durationMs, tag: agentType });\\n\\n      if (!toolCalls.length) {\\n        // No tool calls; continue loop. Emit snapshot for completeness\\n        doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), turn: i, note: 'no_tool_calls' } });\\n        // progress hint\\n        doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i + 1} complete` } });\\n        continue;\\n      }\\n\\n      const toolOutputs: string[] = [];\\n\\n      for (const call of toolCalls) {\\n        const toolName = (call.tool_name || call.tool || call.name || 'unknown_tool');\\n        const args = (call.arguments || call.parameters || {}) as Record<string, any>;\\n\\n        if (availableTools[toolName]) {\\n          // Inject task_id and feature_id as Python orchestrator does via inspect signature\\n          if (!('task_id' in args)) args.task_id = task.id;\\n          if (feature && !('feature_id' in args)) args.feature_id = feature.id;\\n\\n          const result = await Promise.resolve(availableTools[toolName](args));\\n          toolOutputs.push(`Tool ${toolName} returned: ${result}`);\\n        } else {\\n          toolOutputs.push(`Error: Tool '${toolName}' not found.`);\\n        }\\n\\n        // Termination tools mirror Python\\n        if (['finish_feature', 'block_feature', 'finish_spec', 'block_task'].includes(toolName)) {\\n          // Final conversation snapshot before termination (assistant is final; no tool results turn)\\n          doEmit({ type: 'llm/messages/final', payload: { messages: messages.slice(), tool: toolName } });\\n          complete(toolName === 'block_feature' || toolName === 'block_task' ? 'block' : 'finish');\\n          return;\\n        }\\n      }\\n\\n      // Append tool results as a dedicated 'tool' role message to avoid confusing with user turns\\n      const toolResultMsg: CompletionMessage = { role: 'tool', content: '--- TOOL RESULTS ---\\\\n' + toolOutputs.join('\\\\n') } as any;\\n      // Add a source hint for legacy parsers\\n      (toolResultMsg as any).source = 'tools';\\n      messages.push(toolResultMsg);\\n      // Emit tool results message appended\\n      doEmit({ type: 'llm/message', payload: { message: toolResultMsg, turn: i, source: 'tools' } });\\n      // progress hint after tools\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i + 1} tool calls processed` } });\\n    } catch (e) {\\n      // On error: block task/feature, same as Python\\n      if (feature) {\\n        await taskTools.blockFeature?.(task.id, feature.id, `Agent loop failed: ${e}`, agentType, git);\\n      } else {\\n        await taskTools.blockTask?.(task.id, `Agent loop failed: ${e}`, agentType, git);\\n      }\\n      doEmit({ type: 'llm/messages/error', payload: { error: String(e), messages: messages.slice() } });\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: undefined, message: 'Error encountered' } });\\n      logger.error('Agent loop error:', e as any);\\n      complete('block', e);\\n      return;\\n    }\\n  }\\n\\n  // Max turns reached -> block\\n  if (feature) {\\n    await taskTools.blockFeature?.(task.id, feature.id, 'Agent loop exceeded max turns', agentType, git);\\n  } else {\\n    await taskTools.blockTask?.(task.id, 'Agent loop exceeded max turns', agentType, git);\\n  }\\n  doEmit({ type: 'llm/messages/final', payload: { messages: messages.slice(), reason: 'max_turns' } });\\n  doEmit({ type: 'run/progress/snapshot', payload: { progress: 1, message: 'Max turns reached' } });\\n  logger.warn('Max turns reached without completion.');\\n  complete('max_turns');\\n}\\n\\nasync function runAgentOnTask(model: string, agentType: string, task: Task, taskTools: TaskUtils, fileTools: FileTools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\n  logger.debug(`\\\\n--- Activating Agent ${agentType} for task: [${task.id}] ${task.title} ---`);\\n  const agentDocs = loadAgentDocs(agentType);\\n  const contextFiles = ['docs/FILE_ORGANISATION.md'];\\n  const [funcs, sigs] = toolSigsForAgent(agentType, taskTools, fileTools, git);\\n  const context = await Promise.resolve(fileTools.readFiles(contextFiles));\\n  const systemPrompt = constructSystemPrompt(agentType, task, null, agentDocs, context, sigs);\\n\\n  await runConversation({\\n    model,\\n    availableTools: funcs,\\n    systemPrompt,\\n    task,\\n    feature: null,\\n    agentType,\\n    taskTools,\\n    git,\\n    completion,\\n    complete: () => {},\\n    emit,\\n  });\\n}\\n\\nasync function runAgentOnFeature(model: string, agentType: string, task: Task, feature: Feature, taskTools: TaskUtils, fileTools: FileTools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\n  logger.debug(`\\\\n--- Activating Agent ${agentType} for Feature: [${feature.id}] ${feature.title} ---`);\\n\\n  if (agentType === 'developer') await taskTools.updateFeatureStatus?.(task.id, feature.id, '~');\\n\\n  const agentDocs = loadAgentDocs(agentType);\\n  const featureContextFiles = ['docs/FILE_ORGANISATION.md', ...(feature.context ?? [])];\\n  const [funcs, sigs] = toolSigsForAgent(agentType, taskTools, fileTools, git);\\n  const context = await Promise.resolve(fileTools.readFiles(featureContextFiles));\\n  const systemPrompt = constructSystemPrompt(agentType, task, feature, agentDocs, context, sigs);\\n\\n  if (agentType === 'developer') await taskTools.updateFeatureStatus?.(task.id, feature.id, '~');\\n\\n  await runConversation({\\n    model,\\n    availableTools: funcs,\\n    systemPrompt,\\n    task,\\n    feature,\\n    agentType,\\n    taskTools,\\n    git,\\n    completion,\\n    complete: () => {},\\n    emit,\\n  });\\n}\\n\\nasync function runOrchestrator(opts: {\\n  model: string;\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\n  taskId: string; \\n  featureId?: string; \\n  projectDir?: string;\\n  taskTools: TaskUtils;\\n  fileTools: FileTools;\\n  git: GitManager;\\n  completion: CompletionClient;\\n  emit?: (e: { type: string; payload?: any }) => void;\\n}) {\\n  const { model, agentType, taskId, projectDir, taskTools, fileTools, git, completion, emit } = opts;\\n\\n  if (projectDir) taskTools.setProjectRoot(projectDir);\\n  if (projectDir) fileTools.setProjectRoot(projectDir);\\n\\n  const currentTask: Task = await taskTools.getTask(taskId);\\n  if (!currentTask) {\\n    logger.warn('No available tasks to work on in the repository.');\\n    return;\\n  }\\n\\n  logger.debug(`Selected Task: [${currentTask.id}] ${currentTask.title}`);\\n\\n  const branch = `features/${currentTask.id}`;\\n  try {\\n    await git.checkoutBranch(branch, true);\\n  } catch (e) {\\n    logger.warn(`Could not create or checkout branch '${branch}': ${e}`);\\n    await git.checkoutBranch(branch, false);\\n  }\\n  try {\\n    await git.pull(branch);\\n  } catch (e) {\\n    logger.warn(`Could not pull branch '${branch}': ${e}`);\\n  }\\n\\n  const processed = new Set<string>();\\n\\n  if (agentType === 'speccer') {\\n    const freshTask = await taskTools.getTask(currentTask.id);\\n    await runAgentOnTask(model, agentType, freshTask, taskTools, fileTools, git, completion, emit);\\n    return;\\n  }\\n\\n  while (true) {\\n    const freshTask = await taskTools.getTask(currentTask.id);\\n    const next = taskTools.findNextAvailableFeature(freshTask, processed, agentType !== 'developer');\\n    if (!next) {\\n      logger.debug(`\\\\nNo more available features for task ${freshTask.id}.`);\\n      break;\\n    }\\n    await runAgentOnFeature(model, agentType, freshTask, next, taskTools, fileTools, git, completion, emit);\\n    processed.add(next.id);\\n  }\\n}\\n\\n// --- Isolated Runner (mimic Python run.py) ---\\n\\nfunction shouldIgnoreCopy(relPath: string): boolean {\\n  // Ignore common build, cache, and IDE artifacts for TypeScript/Node/Electron projects\\n  // Preserve .git (do NOT ignore)\\n  const parts = relPath.split(path.sep);\\n  const name = parts[parts.length - 1] || relPath;\\n\\n  // If path is within .git, do not ignore (preserve repo history/branches)\\n  if (parts.includes('.git')) return false;\\n\\n  const dirIgnore = new Set([\\n    // Package managers and caches\\n    'node_modules', '.pnpm', '.pnp', '.pnp.cjs', '.pnp.js', '.npm', '.yarn', '.yarn-cache', '.yarnrc',\\n    // Build/output directories\\n    'dist', 'build', 'out', 'release', 'storybook-static',\\n    // Framework-specific\\n    '.next', 'next', '.nuxt', '.svelte-kit',\\n    // Bundlers and dev servers caches\\n    '.vite', '.rollup.cache', '.parcel-cache', '.webpack',\\n    // Test/coverage\\n    'coverage', '.nyc_output',\\n    // Monorepo/turbo caches\\n    '.turbo',\\n    // Generic caches\\n    '.cache', '.eslintcache', '.rpt2_cache', '.tscache',\\n    // Editors/IDE\\n    '.idea', '.vscode',\\n    // Python (from original mirror)\\n    'venv', '__pycache__',\\n    // Logs and temp\\n    'logs', 'tmp', 'temp'\\n  ]);\\n\\n  // If any path segment matches an ignored dir name\\n  if (parts.some(p => dirIgnore.has(p))) return true;\\n\\n  // Ignore specific file patterns\\n  const lower = name.toLowerCase();\\n  if (lower === '.ds_Store'.toLowerCase() || lower === 'thumbs.db') return true;\\n  if (lower.endsWith('.log')) return true; // npm/yarn/pnpm debug logs\\n  if (lower.endsWith('.pyc')) return true; // Python bytecode files\\n  if (lower.endsWith('.tsbuildinfo')) return true; // TypeScript incremental build info\\n\\n  // Ignore Electron asar content markers when encountered as path segments\\n  if (parts.some(p => p.endsWith('.asar') || p.endsWith('.asar.unpacked'))) return true;\\n\\n  return false;\\n}\\n\\nasync function copyTree(src: string, dest: string) {\\n  // Recursively copy, respecting ignore patterns and skipping asar/virtual entries\\n  let stat: fs.Stats;\\n  try {\\n    stat = fs.statSync(src);\\n  } catch (e: any) {\\n    throw new Error(`Source path does not exist or is not accessible: ${src} (${e?.code || e})`);\\n    }\\n  if (!stat.isDirectory()) throw new Error(`Source ${src} is not a directory`);\\n  fs.mkdirSync(dest, { recursive: true });\\n\\n  const walk = (from: string, to: string) => {\\n    let entries: fs.Dirent[] = [];\\n    try {\\n      entries = fs.readdirSync(from, { withFileTypes: true });\\n    } catch (e: any) {\\n      // Skip unreadable directories (e.g., asar virtuals)\\n      logger.warn(`copyTree: Skipping unreadable directory ${from}: ${e?.code || e}`);\\n      return;\\n    }\\n    for (const entry of entries) {\\n      const rel = path.relative(src, path.join(from, entry.name));\\n      if (shouldIgnoreCopy(rel)) continue;\\n      const srcPath = path.join(from, entry.name);\\n      const dstPath = path.join(to, entry.name);\\n\\n      // Skip any path that traverses into an asar archive\\n      if (srcPath.includes('.asar')) continue;\\n\\n      try {\\n        if (entry.isDirectory()) {\\n          fs.mkdirSync(dstPath, { recursive: true });\\n          walk(srcPath, dstPath);\\n        } else if (entry.isSymbolicLink()) {\\n          // Resolve symlink target and copy contents (best-effort)\\n          try {\\n            const linkTarget = fs.readlinkSync(srcPath);\\n            const resolved = path.resolve(path.dirname(srcPath), linkTarget);\\n            const st = fs.statSync(resolved);\\n            if (st.isDirectory()) {\\n              fs.mkdirSync(dstPath, { recursive: true });\\n              walk(resolved, dstPath);\\n            } else {\\n              fs.copyFileSync(resolved, dstPath);\\n            }\\n          } catch {\\n            // Fallback: copy file bytes of the link itself (as file)\\n            try { fs.copyFileSync(srcPath, dstPath); } catch {}\\n          }\\n        } else if (entry.isFile()) {\\n          fs.copyFileSync(srcPath, dstPath);\\n        }\\n      } catch (e: any) {\\n        // Skip problematic entries (e.g., ENOENT due to virtualized packaging paths)\\n        if (e && (e.code === 'ENOENT' || e.code === 'EBUSY' || e.code === 'EPERM')) {\\n          logger.warn(`copyTree: Skipping ${srcPath}: ${e.code}`);\\n          continue;\\n        }\\n        throw e;\\n      }\\n    }\\n  };\\n\\n  walk(src, dest);\\n}\\n\\nexport async function runIsolatedOrchestrator(opts: {\\n  model: string;\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\n  projectId: string; \\n  taskId: string;\\n  featureId?: string; \\n  taskTools: TaskUtils,\\n  fileTools: FileTools,\\n  gitFactory: (projectRoot: string) => GitManager;  // git bound to projectRoot\\n  completion: CompletionClient;\\n  emit?: (e: { type: string; payload?: any }) => void;\\n}) {\\n  const { model, agentType, projectId, taskId, featureId, taskTools, fileTools, gitFactory, completion, emit } = opts;\\n\\n  const projectDir = await taskTools.getProjectDir(projectId);\\n\\n  // Create temp workspace\\n  const tmpBase = fs.mkdtempSync(path.join(os.tmpdir(), 'factory-ts-'));\\n  // Keep a subfolder to host the copied source\\n  const workspace = path.join(tmpBase, 'workspace');\\n\\n  logger.info(`Copying repository from '${projectDir}' to temporary workspace: '${workspace}'`);\\n  try {\\n    await copyTree(projectDir, workspace);\\n  } catch (e) {\\n    logger.error(`FATAL: Failed to copy repository to temporary directory from '${projectDir}' -> '${workspace}': ${e}`);\\n    // best-effort cleanup\\n    try { fs.rmSync(tmpBase, { recursive: true, force: true }); } catch {}\\n    return;\\n  }\\n\\n  // Ensure the isolated workspace does not create or track local history in VCS.\\n  // We do not delete histories; we simply ignore them in the temp workspace.\\n  try {\\n    const giPath = path.join(workspace, '.gitignore');\\n    const ignoreLine = '.factory/';\\n    let existing = '';\\n    try { existing = fs.readFileSync(giPath, 'utf8'); } catch {}\\n    if (!existing.split(/\\\\r?\\\\n/).some(line => line.trim() === ignoreLine)) {\\n      const prefix = existing && !existing.endsWith('\\\\n') ? '\\\\n' : '';\\n      fs.writeFileSync(giPath, existing + prefix + ignoreLine + '\\\\n', 'utf8');\\n      logger.info('Added .factory/ to isolated workspace .gitignore to avoid duplicate history runs.');\\n    }\\n  } catch (e) {\\n    logger.warn(`Failed to update isolated workspace .gitignore: ${e}`);\\n  }\\n\\n  const git = gitFactory(workspace);\\n\\n  try {\\n    await runOrchestrator({\\n      model,\\n      agentType,\\n      taskId,\\n      featureId,\\n      projectDir: workspace,\\n      taskTools,\\n      fileTools,\\n      git,\\n      completion,\\n      emit,\\n    });\\n  } catch (e) {\\n    logger.error(`An error occurred while running the agent orchestrator: ${e}`);\\n  } finally {\\n    // Cleanup temporary directory\\n    try {\\n      fs.rmSync(tmpBase, { recursive: true, force: true });\\n      logger.info('Agent run finished. Temporary directory cleaned up.');\\n    } catch (e) {\\n      logger.warn(`Failed to cleanup temporary directory '${tmpBase}': ${e}`);\\n    }\\n  }\\n}\\n\",\"src/tools/factory/mainOrchestrator.js\":\"import { ipcMain, webContents } from 'electron';\\nimport IPC_HANDLER_KEYS from '../../ipcHandlersKeys.js';\\nimport path from 'node:path';\\nimport fs from 'node:fs';\\n\\n// Load local package factory-ts from monorepo\\n// Use dynamic import to avoid issues with CJS/ESM resolution in Electron\\nlet factoryTs;\\nasync function loadFactory() {\\n  if (factoryTs) return factoryTs;\\n  const cwd = process.cwd();\\n  const distEsm = path.resolve(cwd, 'packages/factory-ts/dist/index.js');\\n  const distCjs = path.resolve(cwd, 'packages/factory-ts/dist/index.cjs');\\n  try {\\n    console.log('[factory] Loading factory-ts from', distEsm);\\n    factoryTs = await import(distEsm);\\n  } catch (errEsm) {\\n    console.warn('[factory] Failed to load ESM build, trying CJS', errEsm?.message || errEsm);\\n    try {\\n      factoryTs = await import(distCjs);\\n    } catch (errCjs) {\\n      console.error('[factory] Failed to load factory-ts from dist. Did you build it? npm run factory:build');\\n      console.error(errCjs?.stack || String(errCjs));\\n      throw errCjs;\\n    }\\n  }\\n  console.log('[factory] factory-ts loaded successfully');\\n  return factoryTs;\\n}\\n\\nconst RUN_SUBSCRIBERS = new Map(); // runId -> Set<webContentsId>\\nconst RUNS = new Map(); // runId -> RunHandle\\nconst RUN_META = new Map(); // runId -> metadata snapshot\\nconst RUN_TIMERS = new Map(); // runId -> heartbeat timer\\n// Track last known LLM messages per run to persist on cancellation\\nconst RUN_MESSAGES = new Map(); // runId -> last messages array\\n\\nlet PRICING = null;\\nlet HISTORY = null;\\n\\nfunction sendEventToWC(wcId, runId, event) {\\n  const wc = webContents.fromId(wcId);\\n  if (wc && !wc.isDestroyed()) {\\n    try {\\n      wc.send(IPC_HANDLER_KEYS.FACTORY_EVENT, { runId, event });\\n    } catch (err) {\\n      console.warn(`[factory] Failed to send event to wc ${wcId} for run ${runId}:`, err?.message || err);\\n    }\\n  }\\n}\\n\\nfunction broadcastEventToSubscribers(runId, event) {\\n  const subscribers = RUN_SUBSCRIBERS.get(runId);\\n  if (!subscribers || subscribers.size === 0) return;\\n  for (const wcId of subscribers) {\\n    sendEventToWC(wcId, runId, event);\\n  }\\n}\\n\\nfunction maskSecrets(obj) {\\n  try {\\n    const o = JSON.parse(JSON.stringify(obj));\\n    if (o && o.llmConfig && typeof o.llmConfig === 'object') {\\n      if ('apiKey' in o.llmConfig) o.llmConfig.apiKey = '***';\\n    }\\n    return o;\\n  } catch {\\n    return obj;\\n  }\\n}\\n\\nfunction nowIso() {\\n  return new Date().toISOString();\\n}\\n\\nfunction persistMeta(runId) {\\n  try {\\n    const meta = RUN_META.get(runId);\\n    if (!meta || !HISTORY) return;\\n    const h = HISTORY;\\n    if (typeof h.addOrUpdateRun === 'function') {\\n      h.addOrUpdateRun(meta);\\n    } else if (typeof h.updateRunMeta === 'function') {\\n      h.updateRunMeta(meta.runId, meta);\\n    } else if (typeof h.upsertRun === 'function') {\\n      h.upsertRun(meta);\\n    } else if (typeof h.addRun === 'function') {\\n      h.addRun(meta);\\n    } else {\\n      // No known persistence API; noop\\n    }\\n  } catch (e) {\\n    console.warn('[factory] persistMeta error', e?.message || e);\\n  }\\n}\\n\\nfunction persistMessages(runId, messages) {\\n  try {\\n    if (!HISTORY || !messages) return;\\n    const h = HISTORY;\\n    if (typeof h.writeMessages === 'function') {\\n      h.writeMessages(runId, messages);\\n    } else if (typeof h.saveMessages === 'function') {\\n      h.saveMessages(runId, messages);\\n    }\\n  } catch (e) {\\n    console.warn('[factory] persistMessages error', e?.message || e);\\n  }\\n}\\n\\nfunction updateMetaFromEvent(runId, e) {\\n  const meta = RUN_META.get(runId);\\n  if (!meta) return;\\n  meta.updatedAt = e?.ts || e?.time || nowIso();\\n  const type = e?.type;\\n  const payload = e?.payload || {};\\n  if (type === 'run/progress' || type === 'run/progress/snapshot') {\\n    if (typeof payload?.progress === 'number') meta.progress = payload.progress;\\n    else if (typeof payload?.percent === 'number') meta.progress = Math.max(0, Math.min(1, payload.percent / 100));\\n    if (payload?.message) meta.message = payload.message;\\n  } else if (type === 'run/usage') {\\n    if (payload?.costUSD != null) meta.costUSD = payload.costUSD;\\n    else if (payload?.costUsd != null) meta.costUSD = payload.costUsd;\\n    else if (payload?.usd != null) meta.costUSD = payload.usd;\\n    if (payload?.promptTokens != null) meta.promptTokens = payload.promptTokens;\\n    if (payload?.completionTokens != null) meta.completionTokens = payload.completionTokens;\\n    if (payload?.provider) meta.provider = payload.provider;\\n    if (payload?.model) meta.model = payload.model;\\n  } else if (type === 'run/start') {\\n    if (payload?.llm?.provider) meta.provider = payload.llm.provider;\\n    if (payload?.llm?.model) meta.model = payload.llm.model;\\n  } else if (type === 'run/error') {\\n    meta.state = 'error';\\n    meta.message = payload?.message || payload?.error || 'Error';\\n  } else if (type === 'run/cancelled') {\\n    meta.state = 'cancelled';\\n    meta.message = payload?.reason || 'Cancelled';\\n  } else if (type === 'run/completed' || type === 'run/complete') {\\n    meta.state = 'completed';\\n    meta.message = payload?.message || payload?.summary || 'Completed';\\n  }\\n  // Persist snapshot on each update\\n  persistMeta(runId);\\n}\\n\\nfunction loadWorkspaceDotenv(projectRoot) {\\n  try {\\n    const dotenv = require('dotenv');\\n    const envPath = path.join(projectRoot, '.env');\\n    if (fs.existsSync(envPath)) {\\n      dotenv.config({ path: envPath });\\n      console.log('[factory] Loaded workspace .env from', envPath);\\n    } else {\\n      console.log('[factory] No .env at', envPath);\\n    }\\n  } catch (e) {\\n    // If dotenv isn't available or fails, ignore silently to avoid crashing Electron main\\n    console.warn('[factory] dotenv not loaded in main process (optional):', e?.message || e);\\n  }\\n}\\n\\nexport async function registerFactoryIPC(mainWindow, projectRoot) {\\n  console.log('[factory] Registering IPC handlers. projectRoot=', projectRoot);\\n\\n  // Ensure workspace .env is loaded in main process so child processes and libs see credentials\\n  loadWorkspaceDotenv(projectRoot);\\n\\n  const { createOrchestrator, createHistoryStore, createPricingManager } = await loadFactory();\\n\\n  try {\\n    const dbPath = path.join(projectRoot, '.factory', 'history.sqlite');\\n    if (typeof createHistoryStore === 'function') {\\n      console.log('[factory] Initializing history store at', dbPath);\\n      HISTORY = createHistoryStore({ dbPath });\\n    } else {\\n      console.log('[factory] History store not available; proceeding without persistence');\\n    }\\n  } catch (err) {\\n    console.warn('[factory] Optional history init failed; continuing without it:', err?.message || err);\\n  }\\n\\n  // Initialize pricing manager and keep reference for IPC operations\\n  try {\\n    PRICING = createPricingManager({ projectRoot });\\n    console.log('[factory] Pricing manager initialized. Loaded', PRICING?.listPrices()?.prices?.length || 0, 'prices.');\\n  } catch (err) {\\n    console.warn('[factory] Failed to initialize pricing manager:', err?.message || err);\\n  }\\n\\n  console.log('[factory] Creating orchestrator');\\n  const orchestrator = createOrchestrator({ projectRoot, history: HISTORY, pricing: PRICING });\\n  console.log('[factory] Orchestrator ready');\\n\\n  function startHeartbeat(runId) {\\n    const prev = RUN_TIMERS.get(runId);\\n    if (prev) clearInterval(prev);\\n    const timer = setInterval(() => {\\n      const meta = RUN_META.get(runId);\\n      if (!meta) return;\\n      // Only heartbeat while running\\n      if (meta.state === 'running') {\\n        const evt = { type: 'run/heartbeat', payload: {}, ts: nowIso() };\\n        updateMetaFromEvent(runId, evt);\\n        broadcastEventToSubscribers(runId, evt);\\n      }\\n    }, 15000);\\n    RUN_TIMERS.set(runId, timer);\\n  }\\n\\n  function stopHeartbeat(runId) {\\n    const t = RUN_TIMERS.get(runId);\\n    if (t) {\\n      clearInterval(t);\\n      RUN_TIMERS.delete(runId);\\n    }\\n  }\\n\\n  function attachRun(runHandle, initMeta) {\\n    console.log('[factory] Attaching run', runHandle?.id);\\n    RUNS.set(runHandle.id, runHandle);\\n    RUN_META.set(runHandle.id, initMeta);\\n    // Persist initial meta\\n    persistMeta(runHandle.id);\\n    startHeartbeat(runHandle.id);\\n\\n    const unsubscribe = runHandle.onEvent((e) => {\\n      try {\\n        // Rich log for visibility; include payload for llm events\\n        const t = e?.type || 'unknown';\\n        if (String(t).startsWith('llm/')) {\\n          console.log('[factory] event', runHandle.id, t, e?.payload ? JSON.parse(JSON.stringify(e.payload)) : undefined);\\n        } else if (t === 'run/log' || t === 'run/progress' || t === 'run/progress/snapshot') {\\n          console.log('[factory] event', runHandle.id, t, e?.payload?.message || '');\\n        } else {\\n          console.log('[factory] event', runHandle.id, t);\\n        }\\n      } catch {}\\n\\n      // Capture and persist messages when provided (init, snapshots, or final)\\n      try {\\n        if ((e?.type === 'llm/messages/snapshot' || e?.type === 'llm/messages/final' || e?.type === 'llm/messages/init') && e?.payload?.messages) {\\n          RUN_MESSAGES.set(runHandle.id, e.payload.messages);\\n          persistMessages(runHandle.id, e.payload.messages);\\n        }\\n      } catch (err) {\\n        console.warn('[factory] Failed to persist messages for', runHandle.id, err?.message || err);\\n      }\\n\\n      updateMetaFromEvent(runHandle.id, e);\\n      broadcastEventToSubscribers(runHandle.id, e);\\n\\n      // If we receive a run/cancelled event, proactively flush last messages (if any)\\n      if (e?.type === 'run/cancelled') {\\n        const last = RUN_MESSAGES.get(runHandle.id);\\n        if (last) persistMessages(runHandle.id, last);\\n      }\\n    });\\n\\n    const cleanup = () => {\\n      console.log('[factory] Cleaning up run', runHandle.id);\\n      try { unsubscribe(); } catch {}\\n      stopHeartbeat(runHandle.id);\\n      RUNS.delete(runHandle.id);\\n      RUN_SUBSCRIBERS.delete(runHandle.id);\\n      RUN_MESSAGES.delete(runHandle.id);\\n      // keep RUN_META for a while? Persisted already\\n      RUN_META.delete(runHandle.id);\\n    };\\n\\n    runHandle.onEvent((e) => {\\n      if (e?.type === 'run/cancelled' || e?.type === 'run/completed' || e?.type === 'run/complete' || e?.type === 'run/error') {\\n        cleanup();\\n      }\\n    });\\n  }\\n\\n  // Helper to proactively mark and persist cancellation, even if the run handle doesn't emit an event\\n  function markCancelled(runId, reason) {\\n    const meta = RUN_META.get(runId);\\n    if (!meta) return;\\n    const evt = { type: 'run/cancelled', payload: { reason: reason || 'Cancelled' }, ts: nowIso() };\\n    updateMetaFromEvent(runId, evt);\\n    broadcastEventToSubscribers(runId, evt);\\n    // Persist last known messages if we have any\\n    const last = RUN_MESSAGES.get(runId);\\n    if (last) persistMessages(runId, last);\\n    stopHeartbeat(runId);\\n  }\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_START_TASK, (_evt, { projectId, taskId, llmConfig, budgetUSD, metadata }) => {\\n    console.log('[factory] START_TASK', maskSecrets({ projectId, taskId, llmConfig, budgetUSD, metadata }));\\n    try {\\n      const run = orchestrator.startRun({ projectId, taskId, llmConfig, budgetUSD, metadata });\\n      console.log('[factory] Run started (task)', run?.id);\\n      const initMeta = {\\n        runId: run.id,\\n        projectId,\\n        taskId,\\n        featureId: undefined,\\n        state: 'running',\\n        message: 'Starting agent... ',\\n        progress: undefined,\\n        costUSD: undefined,\\n        promptTokens: undefined,\\n        completionTokens: undefined,\\n        provider: llmConfig?.provider,\\n        model: llmConfig?.model,\\n        startedAt: nowIso(),\\n        updatedAt: nowIso(),\\n      };\\n      attachRun(run, initMeta);\\n      // Emit a synthetic start snapshot\\n      broadcastEventToSubscribers(run.id, { type: 'run/snapshot', payload: initMeta, ts: nowIso() });\\n      return { runId: run.id };\\n    } catch (err) {\\n      console.error('[factory] Failed to start task run', err?.stack || String(err));\\n      throw err;\\n    }\\n  });\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_START_FEATURE, (_evt, { projectId, taskId, featureId, llmConfig, budgetUSD, metadata }) => {\\n    console.log('[factory] START_FEATURE', maskSecrets({ projectId, taskId, featureId, llmConfig, budgetUSD, metadata }));\\n    try {\\n      const run = orchestrator.startRun({ projectId, taskId, featureId, llmConfig, budgetUSD, metadata });\\n      console.log('[factory] Run started (feature)', run?.id);\\n      const initMeta = {\\n        runId: run.id,\\n        projectId,\\n        taskId,\\n        featureId,\\n        state: 'running',\\n        message: 'Starting agent... ',\\n        progress: undefined,\\n        costUSD: undefined,\\n        promptTokens: undefined,\\n        completionTokens: undefined,\\n        provider: llmConfig?.provider,\\n        model: llmConfig?.model,\\n        startedAt: nowIso(),\\n        updatedAt: nowIso(),\\n      };\\n      attachRun(run, initMeta);\\n      // Emit a synthetic start snapshot\\n      broadcastEventToSubscribers(run.id, { type: 'run/snapshot', payload: initMeta, ts: nowIso() });\\n      return { runId: run.id };\\n    } catch (err) {\\n      console.error('[factory] Failed to start feature run', err?.stack || String(err));\\n      throw err;\\n    }\\n  });\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_CANCEL_RUN, (_evt, { runId, reason }) => {\\n    console.log('[factory] CANCEL_RUN', { runId, reason });\\n    const run = RUNS.get(runId);\\n    // Proactively mark as cancelled for UI/history even if run handle doesn't emit an event\\n    try { markCancelled(runId, reason); } catch {}\\n    if (run) {\\n      try { run.cancel(reason); } catch (err) { console.warn('[factory] Error cancelling run', runId, err?.message || err); }\\n    } else {\\n      console.warn('[factory] Cancel requested for unknown run', runId);\\n    }\\n    return { ok: true };\\n  });\\n\\n  ipcMain.on(IPC_HANDLER_KEYS.FACTORY_SUBSCRIBE, (evt, { runId }) => {\\n    const wcId = evt.sender.id;\\n    console.log('[factory] SUBSCRIBE', { runId, wcId });\\n    let set = RUN_SUBSCRIBERS.get(runId);\\n    if (!set) {\\n      set = new Set();\\n      RUN_SUBSCRIBERS.set(runId, set);\\n    }\\n    set.add(wcId);\\n    evt.sender.once('destroyed', () => {\\n      const s = RUN_SUBSCRIBERS.get(runId);\\n      if (s) {\\n        s.delete(wcId);\\n        console.log('[factory] Unsubscribed (wc destroyed)', { runId, wcId });\\n      }\\n    });\\n\\n    // Immediately send a snapshot to this subscriber to sync current state\\n    const meta = RUN_META.get(runId);\\n    if (meta) {\\n      sendEventToWC(wcId, runId, { type: 'run/snapshot', payload: meta, ts: nowIso() });\\n    }\\n  });\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_LIST_ACTIVE, () => {\\n    // Return currently running runs (best-effort snapshot)\\n    const list = [];\\n    for (const [runId, meta] of RUN_META.entries()) {\\n      if (meta?.state === 'running') {\\n        list.push({ ...meta, runId });\\n      }\\n    }\\n    return list;\\n  });\\n\\n  // History listing and messages API\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_HISTORY_LIST, () => {\\n    try {\\n      return HISTORY?.listRuns?.() || [];\\n    } catch (e) {\\n      console.warn('[factory] history:list error', e?.message || e);\\n      return [];\\n    }\\n  });\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_HISTORY_MESSAGES, (_evt, { runId }) => {\\n    try {\\n      return HISTORY?.getRunMessages?.(runId) || [];\\n    } catch (e) {\\n      console.warn('[factory] history:messages error', e?.message || e);\\n      return [];\\n    }\\n  });\\n\\n  // Pricing handlers\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_PRICING_GET, () => {\\n    try {\\n      const state = PRICING?.listPrices();\\n      return state || { updatedAt: nowIso(), prices: [] };\\n    } catch (e) {\\n      return { updatedAt: nowIso(), prices: [] };\\n    }\\n  });\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_PRICING_REFRESH, async (_evt, { provider, url }) => {\\n    try {\\n      const state = await PRICING?.refresh(provider, url);\\n      return state || { updatedAt: nowIso(), prices: [] };\\n    } catch (e) {\\n      return { updatedAt: nowIso(), prices: [] };\\n    }\\n  });\\n\\n  // Log window lifecycle for context\\n  if (mainWindow && mainWindow.webContents) {\\n    mainWindow.webContents.on('destroyed', () => console.log('[factory] Main window destroyed'));\\n  }\\n}\\n\"}\n\nBegin now."
  }
]