[
  {
    "role": "system",
    "content": "--- BEGIN FEATURE 274eb915-a7b3-4eed-b71d-e7888f1340fb: ChatConversation improvements ---"
  },
  {
    "role": "user",
    "content": "# Developer Agent Steps Execution\n\nYou are the Developer Agent. You will be assigned a single feature to implement. Your goal is to complete it by following these steps precisely.\n\n## Workflow\n\n1.  **Analyze the Feature**: Read the feature's title, description and rejection (if provided) to understand its goal.\n2.  **Consult the File Structure**: Use the provided `docs/FILE_ORGANISATION.md` to understand the project context.\n3.  **Implement**: Write or modify files to meet the feature's acceptance criteria. Use the `write_file`, `rename_file`, `delete_file`, `list_files` and `search_files` tools for all file operations.\n4.  **Complete the Feature**: When the feature is complete, you **MUST** call the `finish_feature` tool. This is your final step for a successful implementation.\n5.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_feature` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n## Notes\n\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\n#CURRENT TASK (ID: f67e8921-b197-40c9-9154-e95db8f27deb)\n##TITLE:\nFactory-ts improvements\n##DESCRIPTION:\nVarious improvements to add to the project and the factory-ts package\n\n\n#ASSIGNED FEATURE: ChatConversation improvements (ID: 274eb915-a7b3-4eed-b71d-e7888f1340fb)\n##DESCRIPTION: @src/renderer/components/agents/ChatConversation.tsx  should always display the first user message as Turn 0, then each subsequent turn is a LLM message + response (tool calls).\nThe tool calls are following a standard JSON schema 'ToolResult' defined in @packages/factory-ts/src/types.ts  - follow it to make a nice display for it the same as LLM tool calls inside its messages are displayed.this currently causes a Warning: Maximum update depth exceeded.\nIt shows the files to select, but they are shown as the display chips - these should just be normal paths to the files.\nInvestigate how ChatView.tsx handles this - it works ok there.\nThis feature is only accepted if the solution from there can be reused as a component.\nDo not alter the messages sent directly to the LLMs - they need to stay in the specified format.\n\nFor this feature to be completed the type 'AgentRun' inside @src/renderer/services/agentsService.ts needs to be updated. Instead of a simple message list, it should store a list of messages per feature the agent has worked on. \n\nRemember that the messages between agents only include a simple json of the form \"{role:str,content:str}\" - do not change this, but alter the logging infrastructure around it.\n\n\n\n\n\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- write_file(filename: str, content: str) - Create or overwrite a file with the given content. Always use this to write code or docs.\n- rename_file(filename: str, new_filename: str) - Rename or move a file from one path to another.\n- delete_file(filename: str) - Delete a file. Use with caution and only when necessary.\n- run_test() -> str - Run the test for the current feature and return the output. Use to verify implementation.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n{\n  \"thoughts\": \"A string explaining your reasoning, analysis, and plan for this step. For example: 'I need to create the main application file and then add the basic boilerplate.'\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"name_of_the_tool_to_call\",\n      \"arguments\": {\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\"\n      }\n    }\n  ]\n}\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\nAs responses to the tool calls you will send, you will also receive JSON objects in the form:\n```json\n{\n\"name\":\"tool_name\",\n\"result\":\"...\"\n}\n```\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"# File Organisation\\n\\nPurpose\\n- Provide a high-level map of the repository so contributors and agents can quickly find the right area.\\n- This is not a change log and not a per-file inventory.\\n\\nEditing Rules (read before updating)\\n- Only document major directories and subsystems. Do not list individual files.\\n- Keep bullets short (one sentence) and avoid \\\"New:\\\" or historical notes.\\n- When adding/removing a major directory or moving a subsystem, update a single bullet here.\\n- Prefer linking or pointing to deeper docs (README/OVERVIEW) rather than describing internals here.\\n- Never document build related artifacts.\\n\\nTop-Level Layout\\n- docs/: Project-wide documentation and specs; single source of truth for protocols and workflows.\\n- src/: Application source (Electron app: main, preload, renderer, and tooling).\\n  - renderer/: React UI (components, screens, hooks, services, navigation, preview runtime).\\n    - components/agents/: Agent-specific UI (status chips, run bullets, model selectors, project/cost/token chips).\\n    - services/: Renderer-side services (e.g., pricingService for LLM price lookup via IPC).\\n  - tools/: Developer and agent tooling (preview analyzer, factory integration, helpers).\\n  - main.js: Electron main process entry.\\n  - preload.js: Safe IPC surface exposed to the renderer.\\n- packages/: Local monorepo packages.\\n  - factory-ts/: Agent orchestration library (orchestrator, pricing, history, completion, git integration).\\n- scripts/: Project automation scripts and CLIs.\\n- Root config files: package.json, tsconfig.json, tailwind/postcss configs, vite configs, forge config, .env.\\n\\nWhere to Learn More\\n- Agents and roles: packages/factory-ts/docs (AGENT_*.md).\\n- Factory TS overview and APIs: packages/factory-ts (see README/OVERVIEW files in that package).\\n- Preview system: see src/renderer/preview and related docs in docs/ (preview usage and analyzer).\\n- IPC and factory integration: src/tools/factory (renderer bridge and main process handlers).\\n\\nConventions (brief)\\n- Keep cross-cutting documentation in docs/; place domain-specific or area-specific READMEs next to the code they describe.\\n- Use descriptive directory names and keep responsibilities separated by area (renderer vs main vs tools vs packages).\\n\\nEnvironment & Credentials\\n- .env at the repo root is used for local development (e.g., credentials consumed by tooling and factory-ts).\\n\\nNotes\\n- If you are unsure whether something belongs here, it probably belongs in a local README under its directory, with this file providing only a one-line pointer to that area.\\n\",\"src/renderer/components/agents/ChatConversation.tsx\":\"import React, { useEffect, useMemo, useRef, useState } from 'react';\\nimport type { AgentRun, AgentRunMessage } from '../../services/agentsService';\\nimport RichText from '../ui/RichText';\\n\\n// Parse assistant JSON response to extract thoughts and tool calls safely\\nfunction parseAssistant(content: string): { thoughts?: string; tool_calls?: { tool_name?: string; tool?: string; name?: string; arguments?: any; parameters?: any }[] } | null {\\n  try {\\n    const obj = JSON.parse(content);\\n    if (obj && typeof obj === 'object') return obj;\\n    return null;\\n  } catch {\\n    return null;\\n  }\\n}\\n\\nfunction classNames(...xs: (string | false | null | undefined)[]) {\\n  return xs.filter(Boolean).join(' ');\\n}\\n\\nfunction JsonPreview({ value, maxChars = 200 }: { value: any; maxChars?: number }) {\\n  const str = typeof value === 'string' ? value : JSON.stringify(value, null, 2);\\n  if (str.length <= maxChars) return (<pre className=\\\"text-xs whitespace-pre-wrap break-words\\\">{str}</pre>);\\n  const [open, setOpen] = useState(false);\\n  return (\\n    <div>\\n      <pre className=\\\"text-xs whitespace-pre-wrap break-words\\\">{open ? str : str.slice(0, maxChars) + '\\\\u2026'}</pre>\\n      <button className=\\\"btn-link text-xs mt-1\\\" onClick={() => setOpen(v => !v)}>{open ? 'Show less' : 'Show more'}</button>\\n    </div>\\n  );\\n}\\n\\nfunction Collapsible({ title, children, defaultOpen = false }: { title: React.ReactNode; children: React.ReactNode; defaultOpen?: boolean }) {\\n  const [open, setOpen] = useState(defaultOpen);\\n  return (\\n    <div className=\\\"border rounded-md border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900\\\">\\n      <button className=\\\"w-full flex items-center justify-between px-3 py-2 text-left hover:bg-neutral-50 dark:hover:bg-neutral-800/50\\\" onClick={() => setOpen(v => !v)}>\\n        <span className=\\\"text-xs font-medium truncate pr-2\\\">{title}</span>\\n        <span className=\\\"text-xs text-neutral-500\\\">{open ? '\\\\u2212' : '+'}</span>\\n      </button>\\n      {open ? (\\n        <div className=\\\"px-3 py-2 border-t border-neutral-200 dark:border-neutral-800\\\">{children}</div>\\n      ) : null}\\n    </div>\\n  );\\n}\\n\\nfunction ToolCallRow({ call, resultText, index }: { call: any; resultText?: string; index: number }) {\\n  const name = call.tool_name || call.tool || call.name || 'tool';\\n  const args = call.arguments ?? call.parameters ?? {};\\n  const isHeavy = name === 'read_files' || name === 'write_file';\\n\\n  return (\\n    <div className=\\\"rounded-md border border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/40\\\">\\n      <div className=\\\"px-3 py-2 flex items-start justify-between gap-3\\\">\\n        <div className=\\\"min-w-0\\\">\\n          <div className=\\\"text-xs font-semibold\\\">{index + 1}. {name}</div>\\n          <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400\\\">Arguments</div>\\n        </div>\\n      </div>\\n      <div className=\\\"px-3 pb-2\\\">\\n        {isHeavy ? (\\n          <Collapsible title={<span>View arguments</span>}>\\n            <JsonPreview value={args} maxChars={500} />\\n          </Collapsible>\\n        ) : (\\n          <div className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 max-h-60 overflow-auto\\\">\\n            <JsonPreview value={args} maxChars={400} />\\n          </div>\\n        )}\\n      </div>\\n      {resultText != null && (\\n        <div className=\\\"px-3 pb-3\\\">\\n          <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400 mb-1\\\">Result</div>\\n          {isHeavy ? (\\n            <Collapsible title={<span>View result</span>}>\\n              <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={resultText} /></div>\\n            </Collapsible>\\n          ) : (\\n            <div className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 text-xs whitespace-pre-wrap break-words max-h-60 overflow-auto\\\">\\n              <RichText text={resultText} />\\n            </div>\\n          )}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\\nfunction parseToolResultsMessage(msg?: AgentRunMessage): string[] {\\n  if (!msg) return [];\\n  const s = msg.content || '';\\n  const lines = s.split(/\\\\r?\\\\n/);\\n  const out: string[] = [];\\n  for (const ln of lines) {\\n    if (!ln) continue;\\n    if (ln.startsWith('---')) continue; // header line\\n    if (ln.startsWith('Tool ')) {\\n      const i = ln.indexOf(' returned: ');\\n      if (i > 0) out.push(ln.substring(i + ' returned: '.length + 'Tool '.length + (ln.startsWith('Tool ') ? 0 : 0)));\\n      else out.push(ln);\\n    } else {\\n      out.push(ln);\\n    }\\n  }\\n  return out;\\n}\\n\\n// Build conversation turns sequentially to ensure full history renders even if 'turn' is missing\\nfunction useTurnBundles(messages: AgentRunMessage[] | undefined) {\\n  return useMemo(() => {\\n    const systemMsgs: AgentRunMessage[] = [];\\n\\n    type Turn = { index: number; user?: AgentRunMessage; assistant?: AgentRunMessage; tools?: AgentRunMessage };\\n    const turns: Turn[] = [];\\n    let current: Turn | null = null;\\n\\n    const isToolMsg = (m: AgentRunMessage) => {\\n      const content = m.content || '';\\n      // Tool messages may be persisted with role 'tool' or with role 'user' but content prefixed\\n      const hinted = (m as any).source === 'tools';\\n      return m.role === 'tool' || hinted || content.startsWith('--- TOOL RESULTS ---');\\n    };\\n\\n    for (const m of messages || []) {\\n      const role = m.role || '';\\n\\n      if (role === 'system') {\\n        systemMsgs.push(m);\\n        continue;\\n      }\\n\\n      if (isToolMsg(m)) {\\n        if (!current) current = { index: turns.length };\\n        current.tools = m;\\n        turns.push(current);\\n        current = null;\\n        continue;\\n      }\\n\\n      if (role === 'user') {\\n        if (current && (current.user || current.assistant || current.tools)) {\\n          turns.push(current);\\n          current = null;\\n        }\\n        current = { index: turns.length, user: m };\\n        continue;\\n      }\\n\\n      if (role === 'assistant') {\\n        if (!current) current = { index: turns.length };\\n        current.assistant = m;\\n        continue;\\n      }\\n\\n      systemMsgs.push(m);\\n    }\\n\\n    if (current && (current.user || current.assistant || current.tools)) {\\n      turns.push(current);\\n    }\\n\\n    return { systemMsgs, turns } as { systemMsgs: AgentRunMessage[]; turns: { index: number; user?: AgentRunMessage; assistant?: AgentRunMessage; tools?: AgentRunMessage }[] };\\n  }, [messages]);\\n}\\n\\nfunction isLargeText(text?: string) {\\n  if (!text) return false;\\n  const len = text.length;\\n  const lines = text.split(/\\\\r?\\\\n/).length;\\n  return len > 800 || lines > 16;\\n}\\n\\nfunction ScrollableTextBox({ text, className }: { text: string; className?: string }) {\\n  return (\\n    <div className={className}>\\n      <div className=\\\"rounded border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-950 p-2 max-h-64 overflow-auto text-xs whitespace-pre-wrap break-words\\\">\\n        <RichText text={text} />\\n      </div>\\n    </div>\\n  );\\n}\\n\\nexport default function ChatConversation({ run }: { run: AgentRun }) {\\n  const lastTurnRef = useRef<HTMLLIElement | null>(null);\\n  const { systemMsgs, turns } = useTurnBundles(run.messages);\\n\\n  useEffect(() => {\\n    if (lastTurnRef.current) {\\n      lastTurnRef.current.scrollIntoView({ behavior: 'smooth', block: 'nearest' });\\n    }\\n  }, [turns.length]);\\n\\n  const systemPrompt = useMemo(() => {\\n    const m = systemMsgs[0];\\n    return m?.content;\\n  }, [systemMsgs, run.messages]);\\n\\n  const lastIndex = turns.length - 1;\\n\\n  return (\\n    <div className=\\\"h=[60vh] max-h-[70vh] overflow-auto bg-neutral-50 dark:bg-neutral-900 rounded-md border border-neutral-200 dark:border-neutral-800 p-3 space-y-3\\\">\\n      {systemPrompt ? (\\n        <Collapsible title={<span>System prompt</span>} defaultOpen={false}>\\n          {isLargeText(systemPrompt) ? (\\n            <ScrollableTextBox text={systemPrompt} />\\n          ) : (\\n            <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={systemPrompt} /></div>\\n          )}\\n        </Collapsible>\\n      ) : null}\\n\\n      {turns.length === 0 ? (\\n        <div className=\\\"text-sm text-neutral-500\\\">No conversation yet.</div>\\n      ) : (\\n        <ul className=\\\"space-y-3\\\">\\n          {turns.map(({ index, user, assistant, tools }) => {\\n            const parsed = assistant ? parseAssistant(assistant.content || '') : null;\\n            const toolCalls = parsed?.tool_calls || [];\\n            const results = parseToolResultsMessage(tools);\\n\\n            const titleParts: string[] = [];\\n            titleParts.push(`Turn ${index}`); // Turn 0 is the initial turn\\n            if ((assistant as any)?.durationMs) titleParts.push(`${(assistant as any).durationMs}ms`);\\n            const title = titleParts.join(' \\\\u00b7 ');\\n\\n            const isLast = index === lastIndex;\\n\\n            return (\\n              <li key={index} ref={isLast ? lastTurnRef : undefined}>\\n                <Collapsible title={<span className=\\\"flex items-center gap-2\\\">{title}</span>} defaultOpen={isLast}>\\n                  <div className=\\\"space-y-2\\\">\\n                    {user ? (\\n                      <div className=\\\"max-w-[80%] rounded-2xl px-3 py-2 bg-neutral-100 text-neutral-900 dark:bg-neutral-800 dark:text-neutral-50 shadow-sm\\\">\\n                        <div className=\\\"text-[11px] font-medium mb-1\\\">User</div>\\n                        {isLargeText(user.content) ? (\\n                          <ScrollableTextBox text={user.content || ''} />\\n                        ) : (\\n                          <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={user.content} /></div>\\n                        )}\\n                      </div>\\n                    ) : null}\\n\\n                    {parsed?.thoughts ? (\\n                      <div className=\\\"max-w-[80%] rounded-2xl px-3 py-2 bg-blue-100 text-blue-900 dark:bg-blue-900/30 dark:text-blue-100 shadow-sm\\\">\\n                        {isLargeText(parsed.thoughts) ? (\\n                          <ScrollableTextBox text={parsed.thoughts || ''} />\\n                        ) : (\\n                          <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={parsed.thoughts} /></div>\\n                        )}\\n                      </div>\\n                    ) : assistant ? (\\n                      <div className=\\\"max-w-[80%] rounded-2xl px-3 py-2 bg-blue-50 text-blue-900 dark:bg-blue-900/20 dark:text-blue-100 shadow-sm\\\">\\n                        <div className=\\\"text-[11px] font-medium mb-1\\\">Assistant</div>\\n                        {isLargeText(assistant.content) ? (\\n                          <ScrollableTextBox text={assistant.content || ''} />\\n                        ) : (\\n                          <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={assistant.content} /></div>\\n                        )}\\n                      </div>\\n                    ) : null}\\n\\n                    {toolCalls.length > 0 ? (\\n                      <div className=\\\"space-y-2\\\">\\n                        {toolCalls.map((call, i) => (\\n                          <ToolCallRow key={i} call={call} index={i} resultText={results[i]} />\\n                        ))}\\n                      </div>\\n                    ) : null}\\n\\n                    {toolCalls.length === 0 && results.length > 0 ? (\\n                      <div className=\\\"rounded-md border border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/40 p-2\\\">\\n                        <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400 mb-1\\\">Tool results</div>\\n                        {results.map((r, i) => (\\n                          <div key={i} className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 mb-2 last:mb-0 text-xs whitespace-pre-wrap break-words max-h-60 overflow-auto\\\">\\n                            <RichText text={r} />\\n                          </div>\\n                        ))}\\n                      </div>\\n                    ) : null}\\n                  </div>\\n                </Collapsible>\\n              </li>\\n            );\\n          })}\\n        </ul>\\n      )}\\n    </div>\\n  );\\n}\\n\",\"packages/factory-ts/src/types.ts\":\"export type Status = '+' | '-' | '~' | '?' | '=';\\nexport interface Feature {\\n  id: string;\\n  status: Status;\\n  title: string;\\n  description: string;\\n  context: string[];\\n  plan?: string;\\n  acceptance?: string[];\\n  blockers?: string[];\\n  rejection?: string;\\n}\\nexport interface Task {\\n  id: string;\\n  title: string;\\n  description: string;\\n  status: Status;\\n  features: Feature[];\\n  featureIdToDisplayIndex: Record<string, number>;\\n  blockers?: string[];\\n  rejection?: string;\\n}\\nexport interface ProjectRequirement {\\n  id: number;\\n  status: Status;\\n  description: string;\\n  tasks: string[];\\n}\\nexport interface ProjectSpec {\\n  id: string;\\n  title: string;\\n  description: string;\\n  path: string;\\n  repo_url: string;\\n  requirements: ProjectRequirement[];\\n  taskIdToDisplayIndex: Record<string, number>;\\n}\\nexport type CompletionMessageRole = 'system' | 'user' | 'assistant';\\nexport type CompletionMessage = { role: CompletionMessageRole; content: string };\\nexport type CompletionUsage = {\\n  promptTokens?: number;\\n  completionTokens?: number;\\n  totalTokens?: number;\\n  costUSD?: number;\\n  provider?: string;\\n  model?: string;\\n};\\nexport type CompletionResponse = { message: { role: 'assistant'; content: string }; usage?: CompletionUsage };\\nexport type CompletionClient = (req: { model: string; messages: CompletionMessage[]; response_format?: any }) => Promise<CompletionResponse>;\\nexport type ToolCall = { tool_name?: string; tool?: string; name?: string; arguments?: any; parameters?: any };\\nexport type ToolResult = { name: string; result: string };\\nexport type AgentResponse = { thoughts?: string; tool_calls?: ToolCall[] };\\n\\n\\nexport type LLMConfig = {\\n  model: string;\\n  provider?: string; // e.g., openai, azure, together, groq, openrouter, ollama, custom\\n  apiKey?: string;\\n  baseURL?: string;\\n  // extra provider fields (azure etc.) tolerated\\n  [key: string]: any;\\n};\\n\\nexport type AgentType = 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\nexport type AgentRun = {\\n  agent: AgentType;\\n  projectId: string;\\n  taskId: string;\\n  featureId?: string;\\n  llmConfig: LLMConfig;\\n  budgetUSD?: number;\\n  metadata?: Record<string, any>;\\n};\\nexport type RunEvent = { type: string; payload?: any };\",\"src/renderer/services/agentsService.ts\":\"import { EventSourceLike, attachToRun, startTaskRun, startFeatureRun } from '../../tools/factory/orchestratorBridge';\\nimport { LLMConfig } from './chatsService';\\nimport { LLMConfigManager } from '../utils/LLMConfigManager';\\nimport { AgentType } from 'packages/factory-ts/src/types';\\n\\nexport type AgentRunState = 'running' | 'completed' | 'cancelled' | 'error';\\n\\nexport type AgentRunMessage = {\\n  role: string;\\n  content: string;\\n  turn?: number;\\n  source?: string;\\n  ts?: string;\\n  durationMs?: number;\\n};\\n\\nexport type AgentRun = {\\n  runId: string;\\n  agentType: AgentType;\\n  projectId: string;\\n  taskId: string;\\n  featureId?: string;\\n  state: AgentRunState;\\n  message?: string;\\n  progress?: number; // 0..1 (if available)\\n  costUSD?: number;\\n  promptTokens?: number;\\n  completionTokens?: number;\\n  provider?: string;\\n  model?: string;\\n  startedAt: string; // ISO\\n  updatedAt: string; // ISO\\n  messages?: AgentRunMessage[]; // Running conversation\\n};\\n\\n// Internal structure to keep handle + eventSource\\ninterface RunRecord extends AgentRun {\\n  events: EventSourceLike;\\n  cancel: (reason?: string) => void;\\n}\\n\\ntype Subscriber = (runs: AgentRun[]) => void;\\n\\nfunction getEventTs(e: any): string {\\n  return e?.ts || e?.time || new Date().toISOString();\\n}\\n\\nfunction getCostUSD(payload: any | undefined): number | undefined {\\n  if (!payload) return undefined;\\n  return payload.costUSD ?? payload.costUsd ?? payload.usd ?? undefined;\\n}\\n\\nfunction redactConfig(config: LLMConfig | null | undefined) {\\n  if (!config) return null;\\n  const { apiKey, ...rest } = config as any;\\n  return { ...rest, apiKey: apiKey ? '***' : '' };\\n}\\n\\nconst NOOP_EVENTS: EventSourceLike = { addEventListener: (_t: string, _h: (e: any) => void) => {}, close: () => {} };\\n\\nclass AgentsServiceImpl {\\n  private runs = new Map<string, RunRecord>();\\n  private subscribers = new Set<Subscriber>();\\n  private llmManager = new LLMConfigManager();\\n  private bootstrapped = false;\\n\\n  private notify() {\\n    const list = Array.from(this.runs.values()).map(this.publicFromRecord);\\n    for (const cb of this.subscribers) cb(list);\\n  }\\n\\n  private publicFromRecord(rec: RunRecord): AgentRun {\\n    const { events: _ev, cancel: _c, ...pub } = rec as any;\\n    return pub as AgentRun;\\n  }\\n\\n  private async bootstrapFromActiveRuns() {\\n    if (this.bootstrapped) return;\\n    this.bootstrapped = true;\\n    try {\\n      const factory = (window as any).factory;\\n      if (!factory) return;\\n      // 1) Attach to active\\n      if (typeof factory.listActiveRuns === 'function') {\\n        const active = await factory.listActiveRuns();\\n        if (Array.isArray(active)) {\\n          for (const m of active) {\\n            if (!m?.runId) continue;\\n            if (this.runs.has(m.runId)) continue;\\n            const { handle, events } = attachToRun(m.runId);\\n            const run: RunRecord = {\\n              runId: handle.id,\\n              agentType: m.agentType,\\n              projectId: m.projectId,\\n              taskId: m.taskId,\\n              featureId: m.featureId ?? undefined,\\n              state: m.state ?? 'running',\\n              message: m.message ?? 'Running... ',\\n              progress: m.progress,\\n              costUSD: m.costUSD,\\n              promptTokens: m.promptTokens,\\n              completionTokens: m.completionTokens,\\n              provider: m.provider,\\n              model: m.model,\\n              startedAt: m.startedAt || new Date().toISOString(),\\n              updatedAt: m.updatedAt || new Date().toISOString(),\\n              messages: [],\\n              events,\\n              cancel: (reason?: string) => handle.cancel(reason),\\n            } as RunRecord;\\n            this.wireRunEvents(run);\\n            this.runs.set(run.runId, run);\\n\\n            // Load any existing messages persisted for this active run (so we don't only show new ones)\\n            try {\\n              if (typeof factory.getRunMessages === 'function') {\\n                const msgs = await factory.getRunMessages(run.runId);\\n                if (Array.isArray(msgs)) {\\n                  run.messages = msgs.map((mm: any) => ({\\n                    role: String(mm?.role ?? ''),\\n                    content: String(mm?.content ?? ''),\\n                    turn: mm?.turn,\\n                  }));\\n                }\\n              }\\n            } catch (err) {\\n              console.warn('[agentsService] Failed to load messages for active run', run.runId, (err as any)?.message || err);\\n            }\\n          }\\n        }\\n      }\\n\\n      // 2) Load history snapshot from disk\\n      if (typeof factory.listRunHistory === 'function') {\\n        const history = await factory.listRunHistory();\\n        if (Array.isArray(history)) {\\n          for (const m of history) {\\n            if (!m?.runId) continue;\\n            if (this.runs.has(m.runId)) continue;\\n            const rec: RunRecord = {\\n              runId: m.runId,\\n              agentType: m.agentType,\\n              projectId: m.projectId,\\n              taskId: m.taskId,\\n              featureId: m.featureId ?? undefined,\\n              state: m.state ?? 'completed',\\n              message: m.message ?? '',\\n              progress: m.progress,\\n              costUSD: m.costUSD,\\n              promptTokens: m.promptTokens,\\n              completionTokens: m.completionTokens,\\n              provider: m.provider,\\n              model: m.model,\\n              startedAt: m.startedAt || new Date().toISOString(),\\n              updatedAt: m.updatedAt || new Date().toISOString(),\\n              messages: [],\\n              events: NOOP_EVENTS,\\n              cancel: () => {},\\n            } as RunRecord;\\n            this.runs.set(rec.runId, rec);\\n            // Load messages lazily and notify\\n            try {\\n              if (typeof factory.getRunMessages === 'function') {\\n                const msgs = await factory.getRunMessages(rec.runId);\\n                if (Array.isArray(msgs)) {\\n                  rec.messages = msgs.map((mm: any) => ({ role: String(mm?.role ?? ''), content: String(mm?.content ?? ''), turn: mm?.turn }))\\n                }\\n              }\\n            } catch {}\\n          }\\n        }\\n      }\\n      this.notify();\\n    } catch (err) {\\n      console.warn('[agentsService] bootstrapFromActiveRuns failed', (err as any)?.message || err);\\n    }\\n  }\\n\\n  subscribe(cb: Subscriber): () => void {\\n    this.subscribers.add(cb);\\n    // Lazy bootstrap when first subscriber attaches\\n    this.bootstrapFromActiveRuns();\\n    cb(Array.from(this.runs.values()).map(this.publicFromRecord));\\n    return () => {\\n      this.subscribers.delete(cb);\\n    };\\n  }\\n\\n  list(): AgentRun[] {\\n    // Also attempt a bootstrap if not yet done (defensive)\\n    this.bootstrapFromActiveRuns();\\n    return Array.from(this.runs.values()).map(this.publicFromRecord);\\n  }\\n\\n  cancelRun(runId: string) {\\n    const rec = this.runs.get(runId);\\n    console.log('[agentsService] cancelRun', { runId, known: !!rec });\\n    if (!rec) return;\\n    try { rec.cancel('User requested'); } catch (err) { console.warn('[agentsService] cancel error', (err as any)?.message || err); }\\n    rec.state = 'cancelled';\\n    rec.updatedAt = new Date().toISOString();\\n    this.notify();\\n  }\\n\\n  private logEventVerbose(run: RunRecord, e: any) {\\n    try {\\n      const type = e?.type || 'unknown';\\n      const payload = e?.payload;\\n      if (String(type).startsWith('llm/')) {\\n        console.log('[agentsService] LLM event', run.runId, type, payload ? JSON.parse(JSON.stringify(payload)) : undefined);\\n      } else if (type === 'run/log' || type === 'run/progress' || type === 'run/progress/snapshot' || type === 'run/snapshot' || type === 'run/heartbeat') {\\n        console.log('[agentsService] event', run.runId, type, payload?.message || '');\\n      } else if (type) {\\n        console.log('[agentsService] event', run.runId, type);\\n      } else {\\n        console.log('[agentsService] event', run.runId, e);\\n      }\\n    } catch (err) {\\n      console.warn('[agentsService] logEventVerbose error', (err as any)?.message || err);\\n    }\\n  }\\n\\n  private ensureMessages(run: RunRecord) {\\n    if (!run.messages) run.messages = [];\\n  }\\n\\n  private appendMessage(run: RunRecord, msg: any, extra?: Partial<AgentRunMessage>) {\\n    this.ensureMessages(run);\\n    const m: AgentRunMessage = {\\n      role: String(msg?.role ?? ''),\\n      content: String(msg?.content ?? ''),\\n      ...(extra || {}),\\n    };\\n    run.messages!.push(m);\\n  }\\n\\n  private replaceMessages(run: RunRecord, arr: any[], turn?: number) {\\n    try {\\n      run.messages = Array.isArray(arr) ? arr.map((m: any) => ({ role: String(m?.role ?? ''), content: String(m?.content ?? ''), turn })) : [];\\n    } catch {\\n      run.messages = [];\\n    }\\n  }\\n\\n  private wireRunEvents(run: RunRecord) {\\n    const onAny = (e: any) => {\\n      this.logEventVerbose(run, e);\\n      run.updatedAt = getEventTs(e);\\n\\n      // Conversation handling\\n      if (e.type === 'llm/messages/init') {\\n        const msgs = e.payload?.messages ?? [];\\n        this.replaceMessages(run, msgs, undefined);\\n      } else if (e.type === 'llm/messages/snapshot') {\\n        const msgs = e.payload?.messages ?? [];\\n        this.replaceMessages(run, msgs, e.payload?.turn);\\n      } else if (e.type === 'llm/message') {\\n        const msg = e.payload?.message;\\n        const extra = { turn: e.payload?.turn, source: e.payload?.source, durationMs: e.payload?.durationMs, ts: getEventTs(e) } as Partial<AgentRunMessage>;\\n        if (msg) this.appendMessage(run, msg, extra);\\n      } else if (e.type === 'llm/messages/final') {\\n        const msgs = e.payload?.messages ?? [];\\n        this.replaceMessages(run, msgs, undefined);\\n      }\\n\\n      // Meta updates\\n      if (e.type === 'run/progress' || e.type === 'run/progress/snapshot') {\\n        run.message = e.payload?.message ?? run.message;\\n        if (typeof e.payload?.progress === 'number') {\\n          run.progress = e.payload.progress;\\n        } else if (typeof e.payload?.percent === 'number') {\\n          run.progress = Math.max(0, Math.min(1, e.payload.percent / 100));\\n        }\\n      } else if (e.type === 'run/usage') {\\n        run.costUSD = getCostUSD(e.payload) ?? run.costUSD;\\n        run.promptTokens = e.payload?.promptTokens ?? run.promptTokens;\\n        run.completionTokens = e.payload?.completionTokens ?? run.completionTokens;\\n        run.provider = e.payload?.provider ?? run.provider;\\n        run.model = e.payload?.model ?? run.model;\\n      } else if (e.type === 'run/start') {\\n        // initialize from start payload if present\\n        run.provider = e.payload?.llm?.provider ?? run.provider;\\n        run.model = e.payload?.llm?.model ?? run.model;\\n      } else if (e.type === 'run/snapshot') {\\n        // synchronize local state with snapshot from main\\n        const p = e.payload || {};\\n        run.message = p.message ?? run.message;\\n        if (typeof p.progress === 'number') run.progress = p.progress;\\n        if (p.costUSD != null) run.costUSD = p.costUSD;\\n        if (p.promptTokens != null) run.promptTokens = p.promptTokens;\\n        if (p.completionTokens != null) run.completionTokens = p.completionTokens;\\n        if (p.provider) run.provider = p.provider;\\n        if (p.model) run.model = p.model;\\n        if (p.state) run.state = p.state;\\n        if (p.startedAt) run.startedAt = p.startedAt;\\n      } else if (e.type === 'run/error') {\\n        run.state = 'error';\\n        run.message = e.payload?.message || e.payload?.error || 'Error';\\n      } else if (e.type === 'run/cancelled') {\\n        run.state = 'cancelled';\\n        run.message = e.payload?.reason || 'Cancelled';\\n      } else if (e.type === 'run/completed' || e.type === 'run/complete') {\\n        run.state = 'completed';\\n        run.message = e.payload?.message || e.payload?.summary || 'Completed';\\n      }\\n      this.notify();\\n      if (run.state !== 'running') {\\n        try { run.events.close(); } catch {}\\n      }\\n    };\\n    run.events.addEventListener('*', onAny);\\n  }\\n\\n  private getActiveLLMConfig(): LLMConfig | null {\\n    try {\\n      return this.llmManager.getActiveConfig() as unknown as LLMConfig;\\n    } catch {\\n      return null;\\n    }\\n  }\\n\\n  async startTaskAgent(agentType: AgentType, projectId: string, taskId: string): Promise<AgentRun> {\\n    const llmConfig = this.getActiveLLMConfig();\\n    console.log('[agentsService] startTaskAgent', { agentType, projectId, taskId, llmConfig: redactConfig(llmConfig) });\\n    const { handle, events } = await startTaskRun({ agentType, projectId, taskId, options: { llmConfig } });\\n    const run: RunRecord = {\\n      runId: handle.id,\\n      agentType,\\n      projectId,\\n      taskId,\\n      state: 'running',\\n      message: 'Starting agent... ',\\n      startedAt: new Date().toISOString(),\\n      updatedAt: new Date().toISOString(),\\n      provider: llmConfig?.provider,\\n      model: llmConfig?.model,\\n      messages: [],\\n      events,\\n      cancel: (reason?: string) => handle.cancel(reason),\\n    } as RunRecord;\\n\\n    this.wireRunEvents(run);\\n\\n    this.runs.set(run.runId, run);\\n    this.notify();\\n    return this.publicFromRecord(run);\\n  }\\n\\n  async startFeatureAgent(agentType: AgentType, projectId: string, taskId: string, featureId: string): Promise<AgentRun> {\\n    const llmConfig = this.getActiveLLMConfig();\\n    console.log('[agentsService] startFeatureAgent', { agentType, projectId, taskId, featureId, llmConfig: redactConfig(llmConfig) });\\n    const { handle, events } = await startFeatureRun({ agentType, projectId, taskId, featureId, options: { llmConfig } });\\n    const run: RunRecord = {\\n      runId: handle.id,\\n      agentType,\\n      projectId,\\n      taskId,\\n      featureId,\\n      state: 'running',\\n      message: 'Starting agent... ',\\n      startedAt: new Date().toISOString(),\\n      updatedAt: new Date().toISOString(),\\n      provider: llmConfig?.provider,\\n      model: llmConfig?.model,\\n      messages: [],\\n      events,\\n      cancel: (reason?: string) => handle.cancel(reason),\\n    } as RunRecord;\\n\\n    this.wireRunEvents(run);\\n\\n    this.runs.set(run.runId, run);\\n    this.notify();\\n    return this.publicFromRecord(run);\\n  }\\n}\\n\\nexport const agentsService = new AgentsServiceImpl();\\n\"}\n\nBegin now."
  }
]