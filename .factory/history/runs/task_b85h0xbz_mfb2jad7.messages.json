{
  "827ebb41-2edf-431f-b90f-54501e1c4069": {
    "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
    "startDate": "2025-09-08T11:58:53.232Z",
    "messages": [
      {
        "role": "user",
        "content": "# Developer Agent Steps Execution\n\nYou are the Developer Agent. You will be assigned a single feature to implement. Your goal is to complete it by following these steps precisely.\n\n## Workflow\n\n1.  **Analyze the Feature**: Read the feature's title, description and rejection (if provided) to understand its goal.\n2.  **Consult the File Structure**: Use the provided `docs/FILE_ORGANISATION.md` to understand the project context.\n3.  **Implement**: Write or modify files to meet the feature's acceptance criteria. Use the `write_file`, `rename_file`, `delete_file`, `list_files` and `search_files` tools for all file operations.\n4.  **Complete the Feature**: When the feature is complete, you **MUST** call the `finish_feature` tool. This is your final step for a successful implementation.\n5.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_feature` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n## Notes\n\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\n#CURRENT TASK (ID: 89257920-d018-41bf-892a-583569d11d53)\n##TITLE:\nCleaning up the tools\n##DESCRIPTION:\nCurrently there are only fileTools and taskUtils - but all tools should be split by the context they serve.\nThere are test related functions inside taskUtils - those should be placed in a new file.\nThe whole project requires a README.md that will be updated with precise and concise information about each set of tools.\n\n\n#ASSIGNED FEATURE: Extract test utilities into src/testTools.ts (ID: 827ebb41-2edf-431f-b90f-54501e1c4069)\n##DESCRIPTION: Create a new module src/testTools.ts that encapsulates all test-related functionality currently in taskUtils: getTest, updateAcceptanceCriteria, updateTest, deleteTest, runTest. Provide both default singleton export (testTools) and a factory createTestTools(projectRoot) similar to fileTools and createTaskUtils patterns. Ensure paths are computed relative to tasks/<taskId>/tests and include ensureDir, timeout handling, and security. Export types as needed. Include local (per-run) variants. Unit-adapt function signatures to match existing calls.\n\n\n\n\n\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- write_file(filename: str, content: str) - Create or overwrite a file with the given content. Always use this to write code or docs.\n- rename_file(filename: str, new_filename: str) - Rename or move a file from one path to another.\n- delete_file(filename: str) - Delete a file. Use with caution and only when necessary.\n- run_test() -> str - Run the test for the current feature and return the output. Use to verify implementation.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n[object Object]\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\nAs responses to the tool calls you will send, you will also receive JSON objects in the form:\n```json\n{\n\"name\":\"tool_name\",\n\"result\":\"...\"\n}\n```\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"Path not found or is not a regular file/directory.\"}\n\nBegin now.",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 0,
        "source": "initial",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"I need to inspect the repository to locate taskUtils and fileTools to extract test-related functions and match their patterns. The FILE_ORGANISATION.md is missing, so I will explore the file tree to find src/taskUtils.ts and related modules.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"list_files\",\n      \"args\": {\n        \"path\": \".\"\n      }\n    }\n  ]\n}",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 0,
        "askedAt": "2025-09-08T11:58:53.240Z",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"list_files\",\"result\":[\".env\",\".eslintrc.cjs\",\".git\",\".gitignore\",\".prettierrc\",\"blueprint\",\"docs\",\"package-lock.json\",\"package.json\",\"src\",\"tasks\",\"tsconfig.json\",\"tsup.config.ts\",\"types\",\"vitest.config.ts\"]}]",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 0,
        "source": "tools",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"Next, I need to inspect the src directory to find taskUtils and fileTools, and then open taskUtils to identify test-related functions to extract.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"list_files\",\n      \"args\": {\n        \"path\": \"src\"\n      }\n    }\n  ]\n}",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 1,
        "askedAt": "2025-09-08T11:58:57.723Z",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"list_files\",\"result\":[\"chatTools.ts\",\"completion.ts\",\"fileTools.ts\",\"gitManager.ts\",\"index.ts\",\"logger.ts\",\"orchestrator.ts\",\"pricing.ts\",\"taskUtils.ts\",\"types.ts\",\"utils.ts\"]}]",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 1,
        "source": "tools",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"Open taskUtils.ts to locate test-related functions and understand their signatures and any shared utilities.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"read_files\",\n      \"args\": {\n        \"paths\": [\n          \"src/taskUtils.ts\"\n        ]\n      }\n    }\n  ]\n}",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 2,
        "askedAt": "2025-09-08T11:59:00.474Z",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"read_files\",\"result\":\"{\\\"src/taskUtils.ts\\\":\\\"import fs from 'node:fs';\\\\nimport fsp from 'node:fs/promises';\\\\nimport path from 'node:path';\\\\n\\\\nimport type { Status, Feature, Task } from './types.js';\\\\nimport type { GitManager } from './gitManager.js';\\\\n\\\\n// Stable framework root (monorepo/app root) captured at module load.\\\\n// This should never be mutated by per-run operations.\\\\nconst FRAMEWORK_ROOT = path.resolve(process.cwd());\\\\n\\\\n// Mutable project root used for file tools operating within a specific workspace copy.\\\\nlet PROJECT_ROOT = FRAMEWORK_ROOT;\\\\nconst TASKS_DIR_NAME = 'tasks';\\\\n\\\\nfunction setProjectRoot(p: string) { PROJECT_ROOT = path.resolve(p || FRAMEWORK_ROOT); }\\\\nfunction getProjectRoot() { return PROJECT_ROOT; }\\\\n\\\\nfunction tasksDir() { return path.join(PROJECT_ROOT, TASKS_DIR_NAME); }\\\\nfunction taskDir(taskId: string) { return path.join(tasksDir(), taskId); }\\\\nfunction taskPath(taskId: string) { return path.join(taskDir(taskId), 'task.json'); }\\\\nfunction testPath(taskId: string, featureId: string) { return path.join(taskDir(taskId), 'tests', `test_${taskId}_${featureId}.py`); }\\\\n\\\\nconst PROJECTS_DIR_NAME = 'projects';\\\\n// Project configs must always be read from the stable framework root, not the mutable project root.\\\\nfunction projectsDirStable() { return path.join(FRAMEWORK_ROOT, PROJECTS_DIR_NAME); }\\\\nfunction projectPathStable(projectId: string) { return path.join(projectsDirStable(), `${projectId}.json`); }\\\\n\\\\nasync function ensureDir(p: string) { await fsp.mkdir(p, { recursive: true }); }\\\\n\\\\nasync function getProjectDir(projectId: string): Promise<string> {\\\\n  // Read the project config from the stable framework root so multiple runs do not depend on temporary workspace state.\\\\n  const p = projectPathStable(projectId);\\\\n  const raw = await fsp.readFile(p, 'utf8');\\\\n  const project = JSON.parse(raw);\\\\n  // project.path is assumed to be relative to the projects dir or the repo root; resolve from FRAMEWORK_ROOT\\\\n  return path.join(FRAMEWORK_ROOT, PROJECTS_DIR_NAME, project.path)\\\\n}\\\\n\\\\nasync function getTask(taskId: string): Promise<Task> {\\\\n  const p = taskPath(taskId);\\\\n  const raw = await fsp.readFile(p, 'utf8');\\\\n  return JSON.parse(raw);\\\\n}\\\\n\\\\nasync function saveTask(task: Task): Promise<void> {\\\\n  const p = taskPath(task.id);\\\\n  await ensureDir(path.dirname(p));\\\\n  await fsp.writeFile(p, JSON.stringify(task, null, 2), 'utf8');\\\\n}\\\\n\\\\nasync function updateTaskStatus(taskId: string, status: Status): Promise<Task> {\\\\n  const t = await getTask(taskId);\\\\n  t.status = status;\\\\n  await saveTask(t);\\\\n  return t;\\\\n}\\\\n\\\\n// File utilities (sandboxed under project root)\\\\nfunction isWithinRoot(abs: string) {\\\\n  const root = getProjectRoot();\\\\n  const normRoot = path.resolve(root) + path.sep;\\\\n  const normAbs = path.resolve(abs) + path.sep;\\\\n  return normAbs.startsWith(normRoot) || path.resolve(abs) === path.resolve(root);\\\\n}\\\\n\\\\nasync function readFiles(pathsRel: string[]): Promise<string> {\\\\n  const result: Record<string, any> = {};\\\\n  for (const rel of pathsRel) {\\\\n    try {\\\\n      const abs = path.resolve(getProjectRoot(), rel);\\\\n      if (!isWithinRoot(abs)) { result[rel] = 'SECURITY ERROR: Cannot access path outside project directory.\\\\\\\\n'; continue; }\\\\n      const st = await fsp.stat(abs).catch(() => null);\\\\n      if (!st) { result[rel] = 'Path not found or is not a regular file/directory.'; continue; }\\\\n      if (st.isDirectory()) {\\\\n        const entries = await fsp.readdir(abs);\\\\n        result[rel] = entries;\\\\n      } else if (st.isFile()) {\\\\n        result[rel] = await fsp.readFile(abs, 'utf8');\\\\n      } else {\\\\n        result[rel] = 'Path not found or is not a regular file/directory.';\\\\n      }\\\\n    } catch (e) {\\\\n      result[rel] = String(e);\\\\n    }\\\\n  }\\\\n  return JSON.stringify(result, null, 0);\\\\n}\\\\nasync function updateFeatureStatus(taskId: string, featureId: string, status: Status) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  if (feature) {\\\\n    feature.status = status;\\\\n    await saveTask(t);\\\\n    return feature;\\\\n  }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function blockFeature(taskId: string, featureId: string, reason: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  if (feature) {\\\\n    feature.status = '?';\\\\n    feature.rejection = `Blocked: ${reason}`;\\\\n    await saveTask(t);\\\\n  }\\\\n  const title = feature?.title ?? '';\\\\n  let msg: string;\\\\n  if (agentType === 'developer') msg = `BLOCKED feat: Complete feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'planner') msg = `BLOCKED plan: Add plan for feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'tester') msg = `BLOCKED test: Add tests for feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'contexter') msg = `BLOCKED context: Set context for feature ${featureId} - ${title}`;\\\\n  else throw new Error(`Unknown agent_type '${agentType}' called block_feature.`);\\\\n\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n\\\\n  console.log(`Feature ${featureId} blocked. Reason: ${reason}`);\\\\n  return feature;\\\\n}\\\\n\\\\nasync function blockTask(taskId: string, reason: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  t.status = '?';\\\\n  t.rejection = `Blocked: ${reason}`;\\\\n  await saveTask(t);\\\\n  const msg = `BLOCKED task: ${t.id} - ${t.title}`;\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  console.log(`Task ${taskId} blocked. Reason: ${reason}`);\\\\n  return t;\\\\n}\\\\n\\\\nasync function checkAndUpdateTaskCompletion(taskId: string) {\\\\n  const t = await getTask(taskId);\\\\n  const allDone = (t.features || []).every(f => f.status === '+');\\\\n  if (allDone) {\\\\n    console.log(`All features for task ${taskId} are complete. Updating task status to '+'.`);\\\\n    await updateTaskStatus(taskId, '+');\\\\n  }\\\\n}\\\\n\\\\nasync function finishFeature(taskId: string, featureId: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  const title = feature?.title ?? '';\\\\n  let msg: string;\\\\n  if (agentType === 'developer') {\\\\n    msg = `feat: Complete feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '+');\\\\n    await checkAndUpdateTaskCompletion(taskId);\\\\n  } else if (agentType === 'planner') {\\\\n    msg = `plan: Add plan for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else if (agentType === 'tester') {\\\\n    msg = `test: Add tests for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else if (agentType === 'contexter') {\\\\n    msg = `context: Set context for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else {\\\\n    throw new Error(`Unknown agent_type '${agentType}' called finish_feature.`);\\\\n  }\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  return `Feature ${featureId} finished by ${agentType} and changes committed.`;\\\\n}\\\\n\\\\nasync function finishSpec(taskId: string, agentType: string, git: GitManager) {\\\\n  if (agentType !== 'speccer') throw new Error(`Unknown agent_type '${agentType}' called finish_spec.`);\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  const msg = `spec: Added spec for task: ${taskId}`;\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  return `Task ${taskId} finished spec by ${agentType} and changes committed.`;\\\\n}\\\\n\\\\n// Tester tools\\\\nasync function getTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  try { return await fsp.readFile(p, 'utf8'); } catch { return `Test file not found at ${p}`; }\\\\n}\\\\n\\\\nasync function updateAcceptanceCriteria(taskId: string, featureId: string, criteria: string[]) {\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.acceptance = criteria; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function updateTest(taskId: string, featureId: string, test: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  await ensureDir(path.dirname(p));\\\\n  await fsp.writeFile(p, test, 'utf8');\\\\n  return `Test file updated at ${p}`;\\\\n}\\\\n\\\\nasync function deleteTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  try { await fsp.unlink(p); return `Test file ${p} deleted.`; } catch { return `Test file ${p} not found.`; }\\\\n}\\\\n\\\\nasync function runTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  if (!fs.existsSync(p)) return 'FAIL: Test file not found.';\\\\n  const { spawn } = await import('node:child_process');\\\\n  return await new Promise<string>((resolve) => {\\\\n    const proc = spawn('python3', [p], { stdio: ['ignore', 'pipe', 'pipe'] });\\\\n    let stdout = '';\\\\n    let stderr = '';\\\\n    const timer = setTimeout(() => { try { proc.kill('SIGKILL'); } catch {} }, 30000);\\\\n    proc.stdout.on('data', (d: any) => { stdout += d.toString(); });\\\\n    proc.stderr.on('data', (d: any) => { stderr += d.toString(); });\\\\n    proc.on('close', (code: number) => {\\\\n      clearTimeout(timer);\\\\n      if (code === 0) resolve(`PASS: Test executed successfully.\\\\\\\\nOutput:\\\\\\\\n${stdout}`);\\\\n      else resolve(`FAIL: Test failed with exit code ${code}.\\\\\\\\nStderr:\\\\\\\\n${stderr}\\\\\\\\nStdout:\\\\\\\\n${stdout}`);\\\\n    });\\\\n    proc.on('error', (e: any) => {\\\\n      clearTimeout(timer);\\\\n      resolve(`FAIL: An unexpected error occurred while running the test: ${e}`);\\\\n    });\\\\n  });\\\\n}\\\\n\\\\n// Orchestrator helpers\\\\nfunction findNextAvailableFeature(task: Task, excludeIds: Set<string> = new Set(), ignoreDependencies = false): Feature | undefined {\\\\n  const features = (task.features || []).slice();\\\\n  if (features.length === 0) return undefined;\\\\n\\\\n  // Create an index mapping using featureIdToDisplayIndex; fallback to array order\\\\n  const displayIndex: Record<string, number> = {};\\\\n  const map = (task as any).featureIdToDisplayIndex as Record<string, number> | undefined;\\\\n  for (let i = 0; i < features.length; i++) {\\\\n    const f = features[i];\\\\n    const idx = map?.[f.id];\\\\n    displayIndex[f.id] = typeof idx === 'number' ? idx : (i + 1); // 1-based fallback\\\\n  }\\\\n\\\\n  // Sort features by display index ascending\\\\n  features.sort((a, b) => {\\\\n    const ai = displayIndex[a.id] ?? Number.MAX_SAFE_INTEGER;\\\\n    const bi = displayIndex[b.id] ?? Number.MAX_SAFE_INTEGER;\\\\n    if (ai !== bi) return ai - bi;\\\\n    // Stable fallback using original array order if indexes equal/missing\\\\n    return 0;\\\\n  });\\\\n\\\\n  const completed = new Set(features.filter(f => f.status === '+').map(f => f.id));\\\\n  for (const f of features) {\\\\n    if (excludeIds.has(f.id)) continue;\\\\n    if (f.status === '-') {\\\\n      const deps = f.blockers || [];\\\\n      if (ignoreDependencies || deps.every(d => completed.has(d))) return f;\\\\n    }\\\\n  }\\\\n  return undefined;\\\\n}\\\\n\\\\nfunction uuidv4() {\\\\n  // Simple UUID v4 generator for local use\\\\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\\\\n    const r = Math.random() * 16 | 0;\\\\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\\\\n    return v.toString(16);\\\\n  });\\\\n}\\\\n\\\\nasync function createFeature(taskId: string, title: string, description: string): Promise<Feature> {\\\\n  const t = await getTask(taskId);\\\\n  const id = uuidv4();\\\\n  const newFeature: Feature = {\\\\n    id,\\\\n    status: '-',\\\\n    title,\\\\n    description,\\\\n    plan: '',\\\\n    context: [],\\\\n    acceptance: [],\\\\n  };\\\\n  t.features = t.features || [];\\\\n  t.features.push(newFeature);\\\\n  t.featureIdToDisplayIndex = t.featureIdToDisplayIndex || {};\\\\n  t.featureIdToDisplayIndex[id] = t.features.length;\\\\n  await saveTask(t);\\\\n  console.log(`New feature '${id}' created in task ${taskId}.`);\\\\n  return newFeature;\\\\n}\\\\n\\\\nasync function updateFeaturePlan(taskId: string, featureId: string, plan: any) {\\\\n  const planStr = Array.isArray(plan) ? plan.map(String).join('\\\\\\\\n') : (typeof plan === 'string' ? plan : String(plan));\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.plan = planStr; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function updateFeatureContext(taskId: string, featureId: string, context: string[]) {\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.context = context; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nexport const taskUtils = {\\\\n  // project\\\\n  setProjectRoot,\\\\n  // task io\\\\n  getTask,\\\\n  saveTask,\\\\n  updateTaskStatus,\\\\n  // feature status\\\\n  updateFeatureStatus,\\\\n  blockFeature,\\\\n  blockTask,\\\\n  finishFeature,\\\\n  finishSpec,\\\\n  // tester tools\\\\n  getTest,\\\\n  updateAcceptanceCriteria,\\\\n  updateTest,\\\\n  deleteTest,\\\\n  runTest,\\\\n  // orchestrator helpers\\\\n  getProjectDir,\\\\n  findNextAvailableFeature,\\\\n  createFeature,\\\\n  updateFeaturePlan,\\\\n  updateFeatureContext,\\\\n};\\\\n\\\\nexport type TaskUtils = typeof taskUtils;\\\\n\\\\n// New: create per-run, project-root scoped task utils (thread-safe)\\\\nexport function createTaskUtils(projectRoot: string) {\\\\n  // Instance-local project root\\\\n  let ROOT = path.resolve(projectRoot || FRAMEWORK_ROOT);\\\\n  const tasksDirLocal = () => path.join(ROOT, TASKS_DIR_NAME);\\\\n  const taskDirLocal = (taskId: string) => path.join(tasksDirLocal(), taskId);\\\\n  const taskPathLocal = (taskId: string) => path.join(taskDirLocal(taskId), 'task.json');\\\\n  const testPathLocal = (taskId: string, featureId: string) => path.join(taskDirLocal(taskId), 'tests', `test_${taskId}_${featureId}.py`);\\\\n\\\\n  async function getTaskLocal(taskId: string): Promise<Task> {\\\\n    const p = taskPathLocal(taskId);\\\\n    const raw = await fsp.readFile(p, 'utf8');\\\\n    return JSON.parse(raw);\\\\n  }\\\\n  async function saveTaskLocal(task: Task): Promise<void> {\\\\n    const p = taskPathLocal(task.id);\\\\n    await ensureDir(path.dirname(p));\\\\n    await fsp.writeFile(p, JSON.stringify(task, null, 2), 'utf8');\\\\n  }\\\\n  async function updateTaskStatusLocal(taskId: string, status: Status): Promise<Task> {\\\\n    const t = await getTaskLocal(taskId);\\\\n    t.status = status;\\\\n    await saveTaskLocal(t);\\\\n    return t;\\\\n  }\\\\n  async function updateFeatureStatusLocal(taskId: string, featureId: string, status: Status) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const feature = t.features.find(f => f.id === featureId);\\\\n    if (feature) {\\\\n      feature.status = status;\\\\n      await saveTaskLocal(t);\\\\n      return feature;\\\\n    }\\\\n    return undefined;\\\\n  }\\\\n  async function blockFeatureLocal(taskId: string, featureId: string, reason: string, agentType: string, git: GitManager) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const feature = t.features.find(f => f.id === featureId);\\\\n    if (feature) {\\\\n      feature.status = '?';\\\\n      feature.rejection = `Blocked: ${reason}`;\\\\n      await saveTaskLocal(t);\\\\n    }\\\\n    const title = feature?.title ?? '';\\\\n    let msg: string;\\\\n    if (agentType === 'developer') msg = `BLOCKED feat: Complete feature ${featureId} - ${title}`;\\\\n    else if (agentType === 'planner') msg = `BLOCKED plan: Add plan for feature ${featureId} - ${title}`;\\\\n    else if (agentType === 'tester') msg = `BLOCKED test: Add tests for feature ${featureId} - ${title}`;\\\\n    else if (agentType === 'contexter') msg = `BLOCKED context: Set context for feature ${featureId} - ${title}`;\\\\n    else throw new Error(`Unknown agent_type '${agentType}' called block_feature.`);\\\\n\\\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n\\\\n    console.log(`Feature ${featureId} blocked. Reason: ${reason}`);\\\\n    return feature;\\\\n  }\\\\n  async function blockTaskLocal(taskId: string, reason: string, agentType: string, git: GitManager) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    t.status = '?';\\\\n    t.rejection = `Blocked: ${reason}`;\\\\n    await saveTaskLocal(t);\\\\n    const msg = `BLOCKED task: ${t.id} - ${t.title}`;\\\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n    console.log(`Task ${taskId} blocked. Reason: ${reason}`);\\\\n    return t;\\\\n  }\\\\n  async function checkAndUpdateTaskCompletionLocal(taskId: string) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const allDone = (t.features || []).every(f => f.status === '+');\\\\n    if (allDone) {\\\\n      console.log(`All features for task ${taskId} are complete. Updating task status to '+'.`);\\\\n      await updateTaskStatusLocal(taskId, '+');\\\\n    }\\\\n  }\\\\n  async function finishFeatureLocal(taskId: string, featureId: string, agentType: string, git: GitManager) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const feature = t.features.find(f => f.id === featureId);\\\\n    const title = feature?.title ?? '';\\\\n    let msg: string;\\\\n    if (agentType === 'developer') {\\\\n      msg = `feat: Complete feature ${featureId} - ${title}`;\\\\n      await updateFeatureStatusLocal(taskId, featureId, '+');\\\\n      await checkAndUpdateTaskCompletionLocal(taskId);\\\\n    } else if (agentType === 'planner') {\\\\n      msg = `plan: Add plan for feature ${featureId} - ${title}`;\\\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\\\n    } else if (agentType === 'tester') {\\\\n      msg = `test: Add tests for feature ${featureId} - ${title}`;\\\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\\\n    } else if (agentType === 'contexter') {\\\\n      msg = `context: Set context for feature ${featureId} - ${title}`;\\\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\\\n    } else {\\\\n      throw new Error(`Unknown agent_type '${agentType}' called finish_feature.`);\\\\n    }\\\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n    return `Feature ${featureId} finished by ${agentType} and changes committed.`;\\\\n  }\\\\n  async function finishSpecLocal(taskId: string, agentType: string, git: GitManager) {\\\\n    if (agentType !== 'speccer') throw new Error(`Unknown agent_type '${agentType}' called finish_spec.`);\\\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n    const msg = `spec: Added spec for task: ${taskId}`;\\\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n    return `Task ${taskId} finished spec by ${agentType} and changes committed.`;\\\\n  }\\\\n  async function getTestLocal(taskId: string, featureId: string) {\\\\n    const p = testPathLocal(taskId, featureId);\\\\n    try { return await fsp.readFile(p, 'utf8'); } catch { return `Test file not found at ${p}`; }\\\\n  }\\\\n  async function updateTestLocal(taskId: string, featureId: string, test: string) {\\\\n    const p = testPathLocal(taskId, featureId);\\\\n    await ensureDir(path.dirname(p));\\\\n    await fsp.writeFile(p, test, 'utf8');\\\\n    return `Test file updated at ${p}`;\\\\n  }\\\\n  async function deleteTestLocal(taskId: string, featureId: string) {\\\\n    const p = testPathLocal(taskId, featureId);\\\\n    try { await fsp.unlink(p); return `Test file ${p} deleted.`; } catch { return `Test file ${p} not found.`; }\\\\n  }\\\\n  async function runTestLocal(taskId: string, featureId: string) {\\\\n    const p = testPathLocal(taskId, featureId);\\\\n    if (!fs.existsSync(p)) return 'FAIL: Test file not found.';\\\\n    const { spawn } = await import('node:child_process');\\\\n    return await new Promise<string>((resolve) => {\\\\n      const proc = spawn('python3', [p], { stdio: ['ignore', 'pipe', 'pipe'] });\\\\n      let stdout = '';\\\\n      let stderr = '';\\\\n      const timer = setTimeout(() => { try { proc.kill('SIGKILL'); } catch {} }, 30000);\\\\n      proc.stdout.on('data', (d: any) => { stdout += d.toString(); });\\\\n      proc.stderr.on('data', (d: any) => { stderr += d.toString(); });\\\\n      proc.on('close', (code: number) => {\\\\n        clearTimeout(timer);\\\\n        if (code === 0) resolve(`PASS: Test executed successfully.\\\\\\\\nOutput:\\\\\\\\n${stdout}`);\\\\n        else resolve(`FAIL: Test failed with exit code ${code}.\\\\\\\\nStderr:\\\\\\\\n${stderr}\\\\\\\\nStdout:\\\\\\\\n${stdout}`);\\\\n      });\\\\n      proc.on('error', (e: any) => {\\\\n        clearTimeout(timer);\\\\n        resolve(`FAIL: An unexpected error occurred while running the test: ${e}`);\\\\n      });\\\\n    });\\\\n  }\\\\n  async function createFeatureLocal(taskId: string, title: string, description: string): Promise<Feature> {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const id = (function uuidv4() {return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {const r = Math.random() * 16 | 0;const v = c === 'x' ? r : (r & 0x3 | 0x8);return v.toString(16);}); })();\\\\n    const newFeature: Feature = { id, status: '-', title, description, plan: '', context: [], acceptance: [], };\\\\n    t.features = t.features || [];\\\\n    t.features.push(newFeature);\\\\n    t.featureIdToDisplayIndex = t.featureIdToDisplayIndex || {};\\\\n    t.featureIdToDisplayIndex[id] = t.features.length;\\\\n    await saveTaskLocal(t);\\\\n    console.log(`New feature '${id}' created in task ${taskId}.`);\\\\n    return newFeature;\\\\n  }\\\\n  async function updateFeaturePlanLocal(taskId: string, featureId: string, plan: any) {\\\\n    const planStr = Array.isArray(plan) ? plan.map(String).join('\\\\\\\\n') : (typeof plan === 'string' ? plan : String(plan));\\\\n    const t = await getTaskLocal(taskId);\\\\n    const f = t.features.find(x => x.id === featureId);\\\\n    if (f) { f.plan = planStr; await saveTaskLocal(t); return f; }\\\\n    return undefined;\\\\n  }\\\\n  async function updateFeatureContextLocal(taskId: string, featureId: string, context: string[]) {\\\\n    const t = await getTaskLocal(taskId);\\\\n    const f = t.features.find(x => x.id === featureId);\\\\n    if (f) { f.context = context; await saveTaskLocal(t); return f; }\\\\n    return undefined;\\\\n  }\\\\n\\\\n  return {\\\\n    // instance project root mutator (instance-scoped)\\\\n    setProjectRoot: (p: string) => { ROOT = path.resolve(p || ROOT); },\\\\n    // task io\\\\n    getTask: getTaskLocal,\\\\n    saveTask: saveTaskLocal,\\\\n    updateTaskStatus: updateTaskStatusLocal,\\\\n    // feature status\\\\n    updateFeatureStatus: updateFeatureStatusLocal,\\\\n    blockFeature: blockFeatureLocal,\\\\n    blockTask: blockTaskLocal,\\\\n    finishFeature: finishFeatureLocal,\\\\n    finishSpec: finishSpecLocal,\\\\n    // tester tools\\\\n    getTest: getTestLocal,\\\\n    updateAcceptanceCriteria,\\\\n    updateTest: updateTestLocal,\\\\n    deleteTest: deleteTestLocal,\\\\n    runTest: runTestLocal,\\\\n    // orchestrator helpers\\\\n    getProjectDir, // always from FRAMEWORK_ROOT (shared, safe)\\\\n    findNextAvailableFeature,\\\\n    createFeature: createFeatureLocal,\\\\n    updateFeaturePlan: updateFeaturePlanLocal,\\\\n    updateFeatureContext: updateFeatureContextLocal,\\\\n  } as TaskUtils;\\\\n}\\\\n\\\"}\"}]",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 2,
        "source": "tools",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"I will search for usages of the test-related functions to decide whether to keep re-exports in taskUtils for compatibility, then implement src/testTools.ts with both singleton and factory, ensuring local variants, security, paths, ensureDir, and timeout handling. Then I will modify taskUtils.ts to remove direct implementations and delegate to testTools, keeping the same signatures to avoid breaking code.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"search_files\",\n      \"args\": {\n        \"query\": \"getTest updateTest deleteTest runTest updateAcceptanceCriteria\",\n        \"path\": \"src\"\n      }\n    }\n  ]\n}",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 3,
        "askedAt": "2025-09-08T11:59:04.118Z",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"search_files\",\"result\":[\"src/orchestrator.ts\",\"src/taskUtils.ts\"]}]",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 3,
        "source": "tools",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "assistant",
        "content": "{\n  \"thoughts\": \"Open orchestrator.ts to see how test-related functions are used, ensuring we match signatures and exports.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"read_files\",\n      \"args\": {\n        \"paths\": [\n          \"src/orchestrator.ts\"\n        ]\n      }\n    }\n  ]\n}",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 4,
        "askedAt": "2025-09-08T11:59:13.962Z",
        "createdAt": "2025-09-08T11:59:18.169Z"
      },
      {
        "role": "user",
        "content": "[{\"name\":\"read_files\",\"result\":\"{\\\"src/orchestrator.ts\\\":\\\"import fs from 'node:fs';\\\\nimport fsp from 'node:fs/promises';\\\\nimport path from 'node:path';\\\\nimport os from 'node:os';\\\\nimport { AgentResponse, AgentType, CompletionClient, CompletionMessage, Feature, MatchAgentResponse, MatchToolCall, Task, ToolCall, ToolResult } from './types.js';\\\\nimport type { TaskUtils } from './taskUtils.js';\\\\nimport type { FileTools } from './fileTools.js';\\\\nimport type { GitManager } from './gitManager.js';\\\\nimport { logger, logLLMStep } from './logger.js';\\\\nimport agent_response_example from '../docs/agent_response_example.json'\\\\nimport { getAgentFile } from './utils.js';\\\\n\\\\nconst MAX_TURNS_PER_FEATURE = 100;\\\\n\\\\nconst NEWLINE = '\\\\\\\\n';\\\\n\\\\nconst PROTOCOL_INSTRUCTIONS = (() => {\\\\n  return [\\\\n    'You **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:',\\\\n    '```json',\\\\n    agent_response_example,\\\\n    '```',\\\\n    'The thoughts field is for your reasoning, and tool_calls is a list of actions to execute.',\\\\n    'Your response will be parsed as JSON. Do not include any text outside of this JSON object.',\\\\n    'As responses to the tool calls you will send, you will also receive JSON objects in the form:',\\\\n    '```json',\\\\n    '{\\\\\\\\n\\\\\\\"name\\\\\\\":\\\\\\\"tool_name\\\\\\\",\\\\\\\\n\\\\\\\"result\\\\\\\":\\\\\\\"...\\\\\\\"\\\\\\\\n}',\\\\n    '```',\\\\n  ].join('\\\\\\\\n');\\\\n})();\\\\n\\\\n// Human-readable descriptions for tools to avoid duplicating them in agent docs\\\\nconst TOOL_DESCRIPTIONS: Record<string, string> = {\\\\n  // Base tools\\\\n  read_files: 'Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).',\\\\n  search_files: 'Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords',\\\\n  list_files: 'List files and directories at a relative path from the project root.',\\\\n  finish_feature: 'Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.',\\\\n  block_feature: 'Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).',\\\\n\\\\n  // Speccer\\\\n  create_feature: 'Define and add a new, atomic feature to the task. Include a concise title and a clear description.',\\\\n  finish_spec: 'Signal that the feature specification is complete for the current task.',\\\\n  block_task: 'Stop work on the task and report why you are blocked at the task level.',\\\\n\\\\n  // Developer\\\\n  write_file: 'Create or overwrite a file with the given content. Always use this to write code or docs.',\\\\n  rename_file: 'Rename or move a file from one path to another.',\\\\n  delete_file: 'Delete a file. Use with caution and only when necessary.',\\\\n  run_test: 'Run the test for the current feature and return the output. Use to verify implementation.',\\\\n\\\\n  // Planner\\\\n  update_feature_plan: 'Save a concise, step-by-step implementation plan for the assigned feature.',\\\\n\\\\n  // Tester\\\\n  update_acceptance_criteria: 'Save a clear, verifiable list of acceptance criteria for the assigned feature.',\\\\n  update_test: 'Save the Python test script that validates the acceptance criteria for this feature.',\\\\n\\\\n  // Contexter\\\\n  update_feature_context: 'Save the minimal set of file paths (relative to repo root) required to implement the feature.'\\\\n};\\\\n\\\\nfunction toolSigsForAgent(agent: string, taskTools: TaskUtils, fileTools: FileTools, git: GitManager): [Record<string, (args: any) => Promise<any> | any>, string[]] {\\\\n  const base: Record<string, [(args: any) => Promise<any> | any, string]> = {\\\\n    read_files: [ (args: { paths: string[] }) => fileTools.readFiles(args.paths), \\\\\\\"read_files(paths: list[str]) -> list[str]\\\\\\\" ],\\\\n    search_files: [ (args: { query: string; path?: string }) => fileTools.searchFiles(args.query, args.path ?? '.'), \\\\\\\"search_files(query: str, path: str = '.') -> list[str]\\\\\\\" ],\\\\n    block_feature: [ (args: { task_id: string; feature_id: string; reason: string }) => taskTools.blockFeature?.(args.task_id, args.feature_id, args.reason, agent, git), 'block_feature(reason: str)' ],\\\\n    finish_feature: [ (args: { task_id: string; feature_id: string }) => taskTools.finishFeature?.(args.task_id, args.feature_id, agent, git), 'finish_feature()' ],\\\\n    list_files: [ (args: { path: string }) => fileTools.listFiles(args.path), 'list_files(path: str)' ],\\\\n  };\\\\n\\\\n  const agentTools: Record<string, [(args: any) => Promise<any> | any, string]> = {};\\\\n\\\\n  if (agent === 'speccer') {\\\\n    agentTools.create_feature = [ (args: { task_id: string; title: string; description: string }) => taskTools.createFeature?.(args.task_id, args.title, args.description), 'create_feature(title: str, description: str)' ];\\\\n    agentTools.finish_spec = [ (args: { task_id: string }) => taskTools.finishSpec?.(args.task_id, agent, git), 'finish_spec()' ];\\\\n    agentTools.block_task = [ (args: { task_id: string; reason: string }) => taskTools.blockTask?.(args.task_id, args.reason, agent, git), 'block_task()' ];\\\\n  } else if (agent === 'developer') {\\\\n    agentTools.write_file = [ (args: { filename: string; content: string }) => fileTools.writeFile(args.filename, args.content), 'write_file(filename: str, content: str)' ];\\\\n    agentTools.rename_file = [ (args: { filename: string; new_filename: string }) => fileTools.renameFile(args.filename, args.new_filename), 'rename_file(filename: str, new_filename: str)' ];\\\\n    agentTools.delete_file = [ (args: { filename: string }) => fileTools.deleteFile(args.filename), 'delete_file(filename: str)' ];\\\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => taskTools.runTest?.(args.task_id, args.feature_id), 'run_test() -> str' ];\\\\n  } else if (agent === 'planner') {\\\\n    agentTools.update_feature_plan = [ (args: { task_id: string; feature_id: string; plan: any }) => taskTools.updateFeaturePlan?.(args.task_id, args.feature_id, args.plan), 'update_feature_plan(plan: str)' ];\\\\n  } else if (agent === 'tester') {\\\\n    agentTools.update_acceptance_criteria = [ (args: { task_id: string; feature_id: string; criteria: string[] }) => taskTools.updateAcceptanceCriteria?.(args.task_id, args.feature_id, args.criteria), 'update_acceptance_criteria(criteria: list[str])' ];\\\\n    agentTools.update_test = [ (args: { task_id: string; feature_id: string; test: string }) => taskTools.updateTest?.(args.task_id, args.feature_id, args.test), 'update_test(test: str)' ];\\\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => taskTools.runTest?.(args.task_id, args.feature_id), 'run_test() -> str' ];\\\\n  } else if (agent === 'contexter') {\\\\n    agentTools.update_feature_context = [ (args: { task_id: string; feature_id: string; context: string[] }) => taskTools.updateFeatureContext?.(args.task_id, args.feature_id, args.context), 'update_feature_context(context: list[str])' ];\\\\n  }\\\\n\\\\n  const merged = { ...base, ...agentTools };\\\\n  const funcs: Record<string, (args: any) => Promise<any> | any> = {};\\\\n  const sigs: string[] = [];\\\\n  for (const [name, [fn, sig]] of Object.entries(merged)) {\\\\n    if (fn) {\\\\n      funcs[name] = fn;\\\\n      const desc = TOOL_DESCRIPTIONS[name] ? ` - ${TOOL_DESCRIPTIONS[name]}` : '';\\\\n      sigs.push(`${sig}${desc}`);\\\\n    }\\\\n  }\\\\n  return [funcs, sigs];\\\\n}\\\\n\\\\nfunction constructSystemPrompt(agent: string, task: Task, feature: Feature | null, agentSystemPrompt: string, context: string, toolSignatures: string[]): string {\\\\n  const plan = feature && (agent === 'developer' || agent === 'tester' || agent === 'contexter' || agent === 'planner') ? feature.plan : undefined;\\\\n  const acceptance = feature && (agent === 'developer' || agent === 'tester') ? feature.acceptance : undefined\\\\n  const acceptanceStr = acceptance?.map((c, i) => `${i + 1}. ${c}`).join('\\\\\\\\n');\\\\n  const toolSignaturesStr = toolSignatures.map(sig => `- ${sig}`).join('\\\\\\\\n');\\\\n\\\\n  const featureBlock = feature ? `#ASSIGNED FEATURE: ${feature.title} (ID: ${feature.id})${NEWLINE}##DESCRIPTION: ${feature.description}${NEWLINE}` : '';\\\\n  const featureRejection = feature?.rejection ? `##REJECTION REASON:${NEWLINE}${feature.rejection}${NEWLINE}` : '';\\\\n  const taskRejection = task.rejection ? `##REJECTION REASON:${NEWLINE}${task.rejection}` : '';\\\\n\\\\n  return [\\\\n    agentSystemPrompt,\\\\n    `#CURRENT TASK (ID: ${task.id})`,\\\\n    '##TITLE:',\\\\n    task.title,\\\\n    '##DESCRIPTION:',\\\\n    task.description,\\\\n    taskRejection,\\\\n    '',\\\\n    featureBlock,\\\\n    featureRejection,\\\\n    plan ? '#THE PLAN' + plan : '',\\\\n    '',\\\\n    acceptanceStr ? '#ACCEPTANCE CRITERIA:' + acceptanceStr : '',\\\\n    '',\\\\n    '#TOOL SIGNATURES:',\\\\n    `${toolSignaturesStr}`,\\\\n    '',\\\\n    '#RESPONSE FORMAT INSTRUCTIONS:',\\\\n    PROTOCOL_INSTRUCTIONS,\\\\n    '',\\\\n    '#CONTEXT FILES PROVIDED:',\\\\n    context,\\\\n    '',\\\\n    'Begin now.'\\\\n  ].join('\\\\\\\\n');\\\\n}\\\\n\\\\n// Attach metadata to messages so history can be reconstructed reliably after persistence\\\\nfunction annotateMessage<T extends CompletionMessage>(msg: T, meta: { featureId?: string; agentType?: string; turn?: number; source?: string; marker?: string; askedAt?: string }): T {\\\\n  const anyMsg = msg as any;\\\\n  if (meta.featureId) anyMsg.featureId = meta.featureId;\\\\n  if (meta.agentType) anyMsg.agentType = meta.agentType;\\\\n  if (typeof meta.turn === 'number') anyMsg.turn = meta.turn;\\\\n  if (meta.source) anyMsg.source = meta.source;\\\\n  if (meta.marker) anyMsg.marker = meta.marker;\\\\n  if (meta.askedAt) anyMsg.askedAt = meta.askedAt;\\\\n  anyMsg.createdAt = new Date().toISOString();\\\\n  return msg;\\\\n}\\\\n\\\\n// Grouped history structure for persistence/readability\\\\ntype FeatureMessagesGroup = { startDate: string; endDate?: string; featureId: string; messages: CompletionMessage[] };\\\\n\\\\nfunction ensureGroup(groups: Record<string, FeatureMessagesGroup>, featureId: string): FeatureMessagesGroup {\\\\n  if (!groups[featureId]) {\\\\n    groups[featureId] = { featureId, startDate: new Date().toISOString(), messages: [] };\\\\n  }\\\\n  return groups[featureId];\\\\n}\\\\n\\\\nfunction parseAgentResponse(content: string) : AgentResponse | undefined\\\\n{\\\\n  let parsed: MatchAgentResponse | undefined;\\\\n  try { parsed = JSON.parse(content) as MatchAgentResponse; } catch {}\\\\n\\\\n  if (!parsed) { return }\\\\n  const thoughts = parsed.thoughts\\\\n  const toolCallsMatched: MatchToolCall[] = parsed.tool_calls ?? parsed.tools ?? parsed.calls ?? []; \\\\n\\\\n  let tool_calls : ToolCall[] = []\\\\n  for(const t of toolCallsMatched){\\\\n    tool_calls.push({\\\\n      tool_name: t.tool_name ?? t.name ?? t.tool ?? \\\\\\\"\\\\\\\",\\\\n      arguments: t.arguments ?? t.args ?? t.parameters ?? t.params,\\\\n    })\\\\n  }\\\\n  return { thoughts, tool_calls }\\\\n}\\\\n\\\\nasync function runConversation(opts: {\\\\n  model: string;\\\\n  availableTools: Record<string, (args: any) => Promise<any> | any>;\\\\n  systemPrompt: string;\\\\n  task: Task;\\\\n  feature: Feature | null;\\\\n  agentType: string;\\\\n  taskTools: TaskUtils;\\\\n  git: GitManager;\\\\n  completion: CompletionClient;\\\\n  complete: (why: 'finish' | 'block' | 'max_turns', info?: any) => void;\\\\n  emit?: (e: { type: string; payload?: any }) => void; // event sink for logging/stats\\\\n}) {\\\\n  const { model, availableTools, systemPrompt, task, feature, agentType, taskTools, git, completion, complete, emit } = opts;\\\\n  const doEmit = (e: { type: string; payload?: any }) => { try { emit?.(e); } catch {} };\\\\n\\\\n  const featureKey = feature?.id ?? '__task__';\\\\n\\\\n  const initialUser: CompletionMessage = annotateMessage(\\\\n    { role: 'user', content: systemPrompt } as any,\\\\n    { featureId: featureKey, agentType, turn: 0, source: 'initial' }\\\\n  );\\\\n  const messages: CompletionMessage[] = [initialUser];\\\\n  doEmit({ type: 'llm/messages/init', payload: { messages: messages.slice(), featureId: featureKey, turn: 0 } });\\\\n\\\\n  for (let i = 0; i < MAX_TURNS_PER_FEATURE; i++) {\\\\n    try {\\\\n      // Emit snapshot of request context before calling the LLM\\\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i } });\\\\n      const startedAt = Date.now();\\\\n      const res = await completion({ model, messages, response_format: { type: 'json_object' } });\\\\n      const durationMs = Date.now() - startedAt;\\\\n\\\\n      const agentResponse = parseAgentResponse(res.message.content)\\\\n\\\\n      const assistant = annotateMessage(\\\\n        { role: 'assistant' as const, content: JSON.stringify(agentResponse) ?? res.message.content },\\\\n        { featureId: featureKey, agentType, turn: i, askedAt: new Date(startedAt).toISOString() }\\\\n      );\\\\n      messages.push(assistant);\\\\n      // Emit assistant message and timing\\\\n      doEmit({ type: 'llm/message', payload: { message: assistant, featureId: featureKey, durationMs } });\\\\n\\\\n      // Parse and log succinct info\\\\n      logLLMStep({ turn: i, thoughts: agentResponse?.thoughts, toolCalls: agentResponse?.tool_calls, durationMs, tag: agentType });\\\\n\\\\n      if (!agentResponse?.tool_calls?.length) {\\\\n        // No tool calls; continue loop.\\\\n        doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i, note: 'no_tool_calls' } });\\\\n        doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} complete` } });\\\\n        continue;\\\\n      }\\\\n\\\\n      const toolOutputs: ToolResult[] = [];\\\\n\\\\n      for (const call of agentResponse.tool_calls) {\\\\n        const toolName = call.tool_name\\\\n        const args = call.arguments\\\\n\\\\n        if (availableTools[toolName]) {\\\\n          if (!('task_id' in args)) args.task_id = task.id;\\\\n          if (feature && !('feature_id' in args)) args.feature_id = feature.id;\\\\n          const result = await Promise.resolve(availableTools[toolName](args));\\\\n          toolOutputs.push({ name: toolName, result });\\\\n        } else {\\\\n          toolOutputs.push({ name: toolName, result: `Error: Tool '${toolName}' not found.` });\\\\n        }\\\\n\\\\n        // Termination tools mirror Python; do not append a tool result turn, final message is assistant\\\\n        if (['finish_feature', 'block_feature', 'finish_spec', 'block_task'].includes(toolName)) {\\\\n          doEmit({ type: 'llm/messages/final', payload: { messages: messages.slice(), featureId: featureKey, tool: toolName } });\\\\n          complete(toolName === 'block_feature' || toolName === 'block_task' ? 'block' : 'finish');\\\\n          return;\\\\n        }\\\\n      }\\\\n\\\\n      // Append tool results as a dedicated 'user' role message to avoid confusing with user turns\\\\n      const toolResultMsg: CompletionMessage = annotateMessage(\\\\n        { role: 'user', content: JSON.stringify(toolOutputs) } as any,\\\\n        { featureId: featureKey, agentType, turn: i, source: 'tools' }\\\\n      );\\\\n      messages.push(toolResultMsg);\\\\n      doEmit({ type: 'llm/message', payload: { message: toolResultMsg, featureId: featureKey, turn: i, source: 'tools' } });\\\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), featureId: featureKey, turn: i, note: 'tools_appended' } });\\\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} tool calls processed` } });\\\\n    } catch (e) {\\\\n      if (feature) {\\\\n        await taskTools.blockFeature?.(task.id, feature.id, `Agent loop failed: ${e}`, agentType, git);\\\\n      } else {\\\\n        await taskTools.blockTask?.(task.id, `Agent loop failed: ${e}`, agentType, git);\\\\n      }\\\\n      doEmit({ type: 'llm/messages/error', payload: { error: String(e), messages: messages.slice(), featureId: featureKey } });\\\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: undefined, message: 'Error encountered' } });\\\\n      logger.error('Agent loop error:', e as any);\\\\n      complete('block', e);\\\\n      return;\\\\n    }\\\\n  }\\\\n\\\\n  // Max turns reached -> block\\\\n  if (feature) {\\\\n    await taskTools.blockFeature?.(task.id, feature.id, 'Agent loop exceeded max turns', agentType, git);\\\\n  } else {\\\\n    await taskTools.blockTask?.(task.id, 'Agent loop exceeded max turns', agentType, git);\\\\n  }\\\\n  doEmit({ type: 'llm/messages/final', payload: { messages: [{ role: 'system', content: systemPrompt }] as CompletionMessage[], featureId: featureKey, reason: 'max_turns' } });\\\\n  doEmit({ type: 'run/progress/snapshot', payload: { progress: 1, message: 'Max turns reached' } });\\\\n  logger.warn('Max turns reached without completion.');\\\\n  complete('max_turns');\\\\n}\\\\n\\\\nasync function runAgentOnTask(model: string, agentType: AgentType, task: Task, taskTools: TaskUtils, fileTools: FileTools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\\\n  logger.debug(`\\\\\\\\n--- Activating Agent ${agentType} for task: [${task.id}] ${task.title} ---`);\\\\n  const agentDocs = getAgentFile(agentType);\\\\n  const contextFiles = ['docs/FILE_ORGANISATION.md'];\\\\n  const [funcs, sigs] = toolSigsForAgent(agentType, taskTools, fileTools, git);\\\\n  const context = await Promise.resolve(fileTools.readFiles(contextFiles));\\\\n  const systemPrompt = constructSystemPrompt(agentType, task, null, agentDocs, context, sigs);\\\\n\\\\n  // Maintain grouped structure for task-level chat\\\\n  const groups: Record<string, FeatureMessagesGroup> = {};\\\\n  const fid = '__task__';\\\\n  ensureGroup(groups, fid);\\\\n\\\\n  await runConversation({\\\\n    model,\\\\n    availableTools: funcs,\\\\n    systemPrompt,\\\\n    task,\\\\n    feature: null,\\\\n    agentType,\\\\n    taskTools,\\\\n    git,\\\\n    completion,\\\\n    complete: () => {},\\\\n    emit: (e) => {\\\\n      // Pass-through event, but attach grouped messages snapshot when available\\\\n      try {\\\\n        if (e?.payload?.messages && Array.isArray(e.payload.messages)) {\\\\n          // Update group messages with annotated copies\\\\n          const msgs = (e.payload.messages as CompletionMessage[]).map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? fid, agentType, turn: (m as any).turn ?? idx }));\\\\n          groups[fid].messages = msgs;\\\\n          if (e.type === 'llm/messages/final') groups[fid].endDate = new Date().toISOString();\\\\n          emit?.({ ...e, payload: { ...e.payload, messageGroups: { ...groups }, featureId: fid } });\\\\n          return;\\\\n        }\\\\n      } catch {}\\\\n      emit?.(e);\\\\n    },\\\\n  });\\\\n}\\\\n\\\\nasync function runAgentOnFeature(model: string, agentType: AgentType, task: Task, feature: Feature, taskTools: TaskUtils, fileTools: FileTools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\\\n  logger.debug(`\\\\\\\\n--- Activating Agent ${agentType} for Feature: [${feature.id}] ${feature.title} ---`);\\\\n\\\\n  if (agentType === 'developer') await taskTools.updateFeatureStatus?.(task.id, feature.id, '~');\\\\n\\\\n  const agentDocs = getAgentFile(agentType);\\\\n  const featureContextFiles = ['docs/FILE_ORGANISATION.md', ...(feature.context ?? [])];\\\\n  const [funcs, sigs] = toolSigsForAgent(agentType, taskTools, fileTools, git);\\\\n  const context = await Promise.resolve(fileTools.readFiles(featureContextFiles));\\\\n  const systemPrompt = constructSystemPrompt(agentType, task, feature, agentDocs, context, sigs);\\\\n\\\\n  if (agentType === 'developer') await taskTools.updateFeatureStatus?.(task.id, feature.id, '~');\\\\n\\\\n  await runConversation({\\\\n    model,\\\\n    availableTools: funcs,\\\\n    systemPrompt,\\\\n    task,\\\\n    feature,\\\\n    agentType,\\\\n    taskTools,\\\\n    git,\\\\n    completion,\\\\n    complete: () => {},\\\\n    emit,\\\\n  });\\\\n}\\\\n\\\\nasync function runOrchestrator(opts: {\\\\n  model: string;\\\\n  agentType: AgentType;\\\\n  taskId: string; \\\\n  featureId?: string; \\\\n  projectDir?: string;\\\\n  taskTools: TaskUtils;\\\\n  fileTools: FileTools;\\\\n  git: GitManager;\\\\n  completion: CompletionClient;\\\\n  emit?: (e: { type: string; payload?: any }) => void;\\\\n}) {\\\\n  const { model, agentType, taskId, projectDir, taskTools, fileTools, git, completion, emit } = opts;\\\\n\\\\n  if (projectDir) taskTools.setProjectRoot(projectDir);\\\\n  if (projectDir) fileTools.setProjectRoot(projectDir);\\\\n\\\\n  const currentTask: Task = await taskTools.getTask(taskId);\\\\n  if (!currentTask) {\\\\n    logger.warn('No available tasks to work on in the repository.');\\\\n    return;\\\\n  }\\\\n\\\\n  logger.debug(`Selected Task: [${currentTask.id}] ${currentTask.title}`);\\\\n\\\\n  const branch = `features/${currentTask.id}`;\\\\n  try {\\\\n    await git.checkoutBranch(branch, true);\\\\n  } catch (e) {\\\\n    logger.warn(`Could not create or checkout branch '${branch}': ${e}`);\\\\n    await git.checkoutBranch(branch, false);\\\\n  }\\\\n  try {\\\\n    await git.pull(branch);\\\\n  } catch (e) {\\\\n    logger.warn(`Could not pull branch '${branch}': ${e}`);\\\\n  }\\\\n\\\\n  const processed = new Set<string>();\\\\n\\\\n  // Aggregate all messages across features for this run\\\\n  let aggregatedMessages: CompletionMessage[] = [];\\\\n  const aggregatedGroups: Record<string, FeatureMessagesGroup> = {};\\\\n\\\\n  if (agentType === 'speccer') {\\\\n    const freshTask = await taskTools.getTask(currentTask.id);\\\\n    await runAgentOnTask(model, agentType, freshTask, taskTools, fileTools, git, completion, (e) => {\\\\n      // For task-level runs, forward events and add grouped snapshot for persistence\\\\n      if (e?.payload?.messages) {\\\\n        const msgs = e.payload.messages as CompletionMessage[];\\\\n        const fid = '__task__';\\\\n        const annotated = msgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? fid, agentType, turn: (m as any).turn ?? idx }));\\\\n        aggregatedMessages = annotated.slice();\\\\n        const group = ensureGroup(aggregatedGroups, fid);\\\\n        group.messages = annotated.slice();\\\\n        if (e.type === 'llm/messages/final') group.endDate = new Date().toISOString();\\\\n        emit?.({ ...e, payload: { ...e.payload, featureId: fid, messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups } } });\\\\n      } else {\\\\n        emit?.(e);\\\\n      }\\\\n    });\\\\n    return;\\\\n  }\\\\n\\\\n  while (true) {\\\\n    const freshTask = await taskTools.getTask(currentTask.id);\\\\n    const next = taskTools.findNextAvailableFeature(freshTask, processed, agentType !== 'developer');\\\\n    if (!next) {\\\\n      logger.debug(`\\\\\\\\nNo more available features for task ${freshTask.id}.`);\\\\n      break;\\\\n    }\\\\n\\\\n    // Ensure a group exists for this feature\\\\n    ensureGroup(aggregatedGroups, next.id);\\\\n\\\\n    // Insert a system marker before each feature to clearly separate in UI and history (flat array only)\\\\n    const featureMarker: CompletionMessage = annotateMessage(\\\\n      { role: 'system', content: `--- BEGIN FEATURE ${next.id}: ${next.title} ---` } as any,\\\\n      { featureId: next.id, agentType, marker: 'feature_begin' }\\\\n    );\\\\n    aggregatedMessages.push(featureMarker);\\\\n    emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'feature_begin', featureId: next.id } });\\\\n\\\\n    // Wrap emit to merge current feature's messages with the aggregate so far\\\\n    let lastFeatureMessages: CompletionMessage[] = [];\\\\n    const baseEmit = emit;\\\\n    const wrappedEmit = (e: { type: string; payload?: any }) => {\\\\n      const t = e?.type;\\\\n      if ((t === 'llm/messages/init' || t === 'llm/messages/snapshot' || t === 'llm/messages/final') && e?.payload?.messages) {\\\\n        try {\\\\n          const featureMsgs: CompletionMessage[] = e.payload.messages || [];\\\\n          // Ensure every message is tagged with this feature id and agentType for persistence\\\\n          const ensured = featureMsgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? next.id, agentType, turn: (m as any).turn ?? idx }));\\\\n          lastFeatureMessages = ensured.slice();\\\\n          // Update groups\\\\n          const g = ensureGroup(aggregatedGroups, next.id);\\\\n          g.messages = ensured.slice();\\\\n          if (t === 'llm/messages/final') g.endDate = new Date().toISOString();\\\\n          // Update flat aggregate for readability (kept for backward compatibility)\\\\n          const combined = aggregatedMessages.concat(ensured);\\\\n          const payload = { ...e.payload, featureId: next.id, messages: combined, messageGroups: { ...aggregatedGroups } };\\\\n          baseEmit?.({ ...e, payload });\\\\n          return;\\\\n        } catch {}\\\\n      }\\\\n      baseEmit?.(e);\\\\n    };\\\\n\\\\n    await runAgentOnFeature(model, agentType, freshTask, next, taskTools, fileTools, git, completion, wrappedEmit);\\\\n\\\\n    // After the feature completes, fold its messages into the aggregate\\\\n    if (lastFeatureMessages && lastFeatureMessages.length) {\\\\n      aggregatedMessages = aggregatedMessages.concat(lastFeatureMessages);\\\\n      // Emit a snapshot to persist the full sequence after folding\\\\n      emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'feature_folded', featureId: next.id } });\\\\n    }\\\\n\\\\n    processed.add(next.id);\\\\n  }\\\\n\\\\n  // Emit final snapshot at end of task run with complete sequence of feature conversations\\\\n  emit?.({ type: 'llm/messages/final', payload: { messages: aggregatedMessages.slice(), messageGroups: { ...aggregatedGroups }, note: 'task_run_complete' } });\\\\n}\\\\n\\\\n// --- Isolated Runner (mimic Python run.py) ---\\\\n\\\\nfunction shouldIgnoreCopy(relPath: string): boolean {\\\\n  // Ignore common build, cache, and IDE artifacts for TypeScript/Node/Electron projects\\\\n  // Preserve .git (do NOT ignore)\\\\n  const parts = relPath.split(path.sep);\\\\n  const name = parts[parts.length - 1] || relPath;\\\\n\\\\n  // If path is within .git, do not ignore (preserve repo history/branches)\\\\n  if (parts.includes('.git')) return false;\\\\n\\\\n  const dirIgnore = new Set([\\\\n    // Package managers and caches\\\\n    'node_modules', '.pnpm', '.pnp', '.pnp.cjs', '.pnp.js', '.npm', '.yarn', '.yarn-cache', '.yarnrc',\\\\n    // Build/output directories\\\\n    'dist', 'build', 'out', 'release', 'storybook-static',\\\\n    // Framework-specific\\\\n    '.next', 'next', '.nuxt', '.svelte-kit',\\\\n    // Bundlers and dev servers caches\\\\n    '.vite', '.rollup.cache', '.parcel-cache', '.webpack',\\\\n    // Test/coverage\\\\n    'coverage', '.nyc_output',\\\\n    // Monorepo/turbo caches\\\\n    '.turbo',\\\\n    // Generic caches\\\\n    '.cache', '.eslintcache', '.rpt2_cache', '.tscache',\\\\n    // Editors/IDE\\\\n    '.idea', '.vscode',\\\\n    // Python (from original mirror)\\\\n    'venv', '__pycache__',\\\\n    // Logs and temp\\\\n    'logs', 'tmp', 'temp'\\\\n  ]);\\\\n\\\\n  // If any path segment matches an ignored dir name\\\\n  if (parts.some(p => dirIgnore.has(p))) return true;\\\\n\\\\n  // Ignore specific file patterns\\\\n  const lower = name.toLowerCase();\\\\n  if (lower === '.ds_Store'.toLowerCase() || lower === 'thumbs.db') return true;\\\\n  if (lower.endsWith('.log')) return true; // npm/yarn/pnpm debug logs\\\\n  if (lower.endsWith('.pyc')) return true; // Python bytecode files\\\\n  if (lower.endsWith('.tsbuildinfo')) return true; // TypeScript incremental build info\\\\n\\\\n  // Ignore Electron asar content markers when encountered as path segments\\\\n  if (parts.some(p => p.endsWith('.asar') || p.endsWith('.asar.unpacked'))) return true;\\\\n\\\\n  return false;\\\\n}\\\\n\\\\nasync function copyTree(src: string, dest: string) {\\\\n  // Recursively copy, respecting ignore patterns and skipping asar/virtual entries\\\\n  let stat: fs.Stats;\\\\n  try {\\\\n    stat = await fsp.stat(src);\\\\n  } catch (e: any) {\\\\n    throw new Error(`Source path does not exist or is not accessible: ${src} (${e?.code || e})`);\\\\n    }\\\\n  if (!stat.isDirectory()) throw new Error(`Source ${src} is not a directory`);\\\\n  await fsp.mkdir(dest, { recursive: true });\\\\n\\\\n  const walk = async (from: string, to: string) => {\\\\n    let entries: fs.Dirent[] = [] as unknown as fs.Dirent[];\\\\n    try {\\\\n      entries = await fsp.readdir(from, { withFileTypes: true });\\\\n    } catch (e: any) {\\\\n      // Skip unreadable directories (e.g., asar virtuals)\\\\n      logger.warn(`copyTree: Skipping unreadable directory ${from}: ${e?.code || e}`);\\\\n      return;\\\\n    }\\\\n    for (const entry of entries) {\\\\n      const rel = path.relative(src, path.join(from, entry.name));\\\\n      if (shouldIgnoreCopy(rel)) continue;\\\\n      const srcPath = path.join(from, entry.name);\\\\n      const dstPath = path.join(to, entry.name);\\\\n\\\\n      // Skip any path that traverses into an asar archive\\\\n      if (srcPath.includes('.asar')) continue;\\\\n\\\\n      try {\\\\n        if (entry.isDirectory()) {\\\\n          await fsp.mkdir(dstPath, { recursive: true });\\\\n          await walk(srcPath, dstPath);\\\\n        } else if (entry.isSymbolicLink()) {\\\\n          // Resolve symlink target and copy contents (best-effort)\\\\n          try {\\\\n            const linkTarget = await fsp.readlink(srcPath);\\\\n            const resolved = path.resolve(path.dirname(srcPath), linkTarget);\\\\n            const st = await fsp.stat(resolved);\\\\n            if (st.isDirectory()) {\\\\n              await fsp.mkdir(dstPath, { recursive: true });\\\\n              await walk(resolved, dstPath);\\\\n            } else {\\\\n              await fsp.copyFile(resolved, dstPath);\\\\n            }\\\\n          } catch {\\\\n            // Fallback: copy file bytes of the link itself (as file)\\\\n            try { await fsp.copyFile(srcPath, dstPath); } catch {}\\\\n          }\\\\n        } else if (entry.isFile()) {\\\\n          await fsp.copyFile(srcPath, dstPath);\\\\n        }\\\\n      } catch (e: any) {\\\\n        // Skip problematic entries (e.g., ENOENT due to virtualized packaging paths)\\\\n        if (e && (e.code === 'ENOENT' || e.code === 'EBUSY' || e.code === 'EPERM')) {\\\\n          logger.warn(`copyTree: Skipping ${srcPath}: ${e.code}`);\\\\n          continue;\\\\n        }\\\\n        throw e;\\\\n      }\\\\n    }\\\\n  };\\\\n\\\\n  await walk(src, dest);\\\\n}\\\\n\\\\nexport async function runIsolatedOrchestrator(opts: {\\\\n  model: string;\\\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\\\n  projectId: string; \\\\n  taskId: string;\\\\n  featureId?: string; \\\\n  taskTools: TaskUtils,\\\\n  fileTools: FileTools,\\\\n  gitFactory: (projectRoot: string) => GitManager;  // git bound to projectRoot\\\\n  completion: CompletionClient;\\\\n  emit?: (e: { type: string; payload?: any }) => void;\\\\n}) {\\\\n  const { model, agentType, projectId, taskId, featureId, taskTools, fileTools, gitFactory, completion, emit } = opts;\\\\n\\\\n  const projectDir = await taskTools.getProjectDir(projectId);\\\\n\\\\n  // Create temp workspace\\\\n  const tmpBase = fs.mkdtempSync(path.join(os.tmpdir(), 'factory-ts-'));\\\\n  // Keep a subfolder to host the copied source\\\\n  const workspace = path.join(tmpBase, 'workspace');\\\\n\\\\n  logger.info(`Copying repository from '${projectDir}' to temporary workspace: '${workspace}'`);\\\\n  try {\\\\n    await copyTree(projectDir, workspace);\\\\n  } catch (e) {\\\\n    logger.error(`FATAL: Failed to copy repository to temporary directory from '${projectDir}' -> '${workspace}': ${e}`);\\\\n    // best-effort cleanup\\\\n    try { fs.rmSync(tmpBase, { recursive: true, force: true }); } catch {}\\\\n    return;\\\\n  }\\\\n\\\\n  const git = gitFactory(workspace);\\\\n\\\\n  try {\\\\n    await runOrchestrator({\\\\n      model,\\\\n      agentType,\\\\n      taskId,\\\\n      featureId,\\\\n      projectDir: workspace,\\\\n      taskTools,\\\\n      fileTools,\\\\n      git,\\\\n      completion,\\\\n      emit,\\\\n    });\\\\n  } catch (e) {\\\\n    logger.error(`An error occurred while running the agent orchestrator: ${e}`);\\\\n  } finally {\\\\n    // Cleanup temporary directory\\\\n    try {\\\\n      fs.rmSync(tmpBase, { recursive: true, force: true });\\\\n      logger.info('Agent run finished. Temporary directory cleaned up.');\\\\n    } catch (e) {\\\\n      logger.warn(`Failed to cleanup temporary directory '${tmpBase}': ${e}`);\\\\n    }\\\\n  }\\\\n}\\\\n\\\"}\"}]",
        "featureId": "827ebb41-2edf-431f-b90f-54501e1c4069",
        "agentType": "developer",
        "turn": 4,
        "source": "tools",
        "createdAt": "2025-09-08T11:59:18.169Z"
      }
    ]
  }
}