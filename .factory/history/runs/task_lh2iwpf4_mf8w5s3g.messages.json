[
  {
    "role": "system",
    "content": "--- BEGIN FEATURE 86314974-b368-49d5-8137-4b5b0d053adb: Running a task from another project, when one is ongoing fails ---",
    "featureId": "86314974-b368-49d5-8137-4b5b0d053adb",
    "agentType": "developer",
    "marker": "feature_begin",
    "createdAt": "2025-09-06T23:24:54.111Z"
  },
  {
    "role": "user",
    "content": "# Developer Agent Steps Execution\n\nYou are the Developer Agent. You will be assigned a single feature to implement. Your goal is to complete it by following these steps precisely.\n\n## Workflow\n\n1.  **Analyze the Feature**: Read the feature's title, description and rejection (if provided) to understand its goal.\n2.  **Consult the File Structure**: Use the provided `docs/FILE_ORGANISATION.md` to understand the project context.\n3.  **Implement**: Write or modify files to meet the feature's acceptance criteria. Use the `write_file`, `rename_file`, `delete_file`, `list_files` and `search_files` tools for all file operations.\n4.  **Complete the Feature**: When the feature is complete, you **MUST** call the `finish_feature` tool. This is your final step for a successful implementation.\n5.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_feature` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n## Notes\n\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\n#CURRENT TASK (ID: f67e8921-b197-40c9-9154-e95db8f27deb)\n##TITLE:\nUI Improvements\n##DESCRIPTION:\nVarious UI improvements to the app\n\n\n#ASSIGNED FEATURE: Running a task from another project, when one is ongoing fails (ID: 86314974-b368-49d5-8137-4b5b0d053adb)\n##DESCRIPTION: A run is in progress for 1 project, and then a 2nd one is started for a 2nd project - this 2nd one immediately fails.\n@packages/factory-ts/src/orchestrator.ts or @src/tools/factory/mainOrchestrator.js should be at fault here\n\n\n\n\n\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- write_file(filename: str, content: str) - Create or overwrite a file with the given content. Always use this to write code or docs.\n- rename_file(filename: str, new_filename: str) - Rename or move a file from one path to another.\n- delete_file(filename: str) - Delete a file. Use with caution and only when necessary.\n- run_test() -> str - Run the test for the current feature and return the output. Use to verify implementation.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n{\n  \"thoughts\": \"A string explaining your reasoning, analysis, and plan for this step. For example: 'I need to create the main application file and then add the basic boilerplate.'\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"name_of_the_tool_to_call\",\n      \"arguments\": {\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\"\n      }\n    }\n  ]\n}\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\nAs responses to the tool calls you will send, you will also receive JSON objects in the form:\n```json\n{\n\"name\":\"tool_name\",\n\"result\":\"...\"\n}\n```\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"# File Organisation\\n\\nPurpose\\n- Provide a high-level map of the repository so contributors and agents can quickly find the right area.\\n- This is not a change log and not a per-file inventory.\\n\\nEditing Rules (read before updating)\\n- Only document major directories and subsystems. Do not list individual files.\\n- Keep bullets short (one sentence) and avoid \\\"New:\\\" or historical notes.\\n- When adding/removing a major directory or moving a subsystem, update a single bullet here.\\n- Prefer linking or pointing to deeper docs (README/OVERVIEW) rather than describing internals here.\\n- Never document build related artifacts.\\n\\nTop-Level Layout\\n- docs/: Project-wide documentation and specs; single source of truth for protocols and workflows.\\n- src/: Application source (Electron app: main, preload, renderer, and tooling).\\n  - renderer/: React UI (components, screens, hooks, services, navigation, preview runtime).\\n    - components/agents/: Agent-specific UI (status chips, run bullets, model selectors, project/cost/token chips).\\n    - services/: Renderer-side services (e.g., pricingService for LLM price lookup via IPC).\\n    - hooks/useShortcuts: Keyboard shortcuts provider; respects user-selected modifier and avoids interfering with text input.\\n  - tools/: Developer and agent tooling (preview analyzer, factory integration, helpers).\\n  - main.js: Electron main process entry.\\n  - preload.js: Safe IPC surface exposed to the renderer.\\n- packages/: Local monorepo packages.\\n  - factory-ts/: Agent orchestration library (orchestrator, pricing, history, completion, git integration).\\n- scripts/: Project automation scripts and CLIs.\\n- Root config files: package.json, tsconfig.json, tailwind/postcss configs, vite configs, forge config, .env.\\n\\nWhere to Learn More\\n- Agents and roles: packages/factory-ts/docs (AGENT_*.md).\\n- Factory TS overview and APIs: packages/factory-ts (see README/OVERVIEW files in that package).\\n- Preview system: see src/renderer/preview and related docs in docs/ (preview usage and analyzer).\\n- IPC and factory integration: src/tools/factory (renderer bridge and main process handlers).\\n\\nConventions (brief)\\n- Keep cross-cutting documentation in docs/; place domain-specific or area-specific READMEs next to the code they describe.\\n- Use descriptive directory names and keep responsibilities separated by area (renderer vs main vs tools vs packages).\\n\\nEnvironment & Credentials\\n- .env at the repo root is used for local development (e.g., credentials consumed by tooling and factory-ts).\\n\\nNotes\\n- If you are unsure whether something belongs here, it probably belongs in a local README under its directory, with this file providing only a one-line pointer to that area.\\n\",\"packages/factory-ts/src/orchestrator.ts\":\"import fs from 'node:fs';\\nimport fsp from 'node:fs/promises';\\nimport path from 'node:path';\\nimport os from 'node:os';\\nimport { AgentResponse, CompletionClient, CompletionMessage, Feature, Task, ToolCall, ToolResult } from './types.js';\\nimport type { TaskUtils } from './taskUtils.js';\\nimport type { FileTools } from './fileTools.js';\\nimport type { GitManager } from './gitManager.js';\\nimport { logger, logLLMStep } from './logger.js';\\n\\nconst MAX_TURNS_PER_FEATURE = 100;\\n\\n// Prefer process.cwd(), but do not assume it points to a real filesystem root when packaged (asar)\\nconst FRAMEWORK_ROOT = path.resolve(process.cwd());\\nconst NEWLINE = '\\\\n';\\n\\nfunction loadAgentDocs(agent: string): string {\\n  // Mirror Python: docs live under packages/factory-ts/docs\\n  const p = path.join(FRAMEWORK_ROOT, 'packages', 'factory-ts', 'docs', `AGENT_${agent.toUpperCase()}.md`);\\n  return fs.readFileSync(p, 'utf8');\\n}\\n\\nfunction loadProtocolExample(): string {\\n  try {\\n    const p = path.join(FRAMEWORK_ROOT, 'packages', 'factory-ts', 'docs', 'agent_response_example.json');\\n    const data = JSON.parse(fs.readFileSync(p, 'utf8'));\\n    return JSON.stringify(data, null, 2);\\n  } catch (e) {\\n    return '{\\\\n\\\"thoughts\\\":\\\"Your reasoning here...\\\",\\\\n\\\"tool_calls\\\":[ ... ]\\\\n}';\\n  }\\n}\\n\\nconst PROTOCOL_INSTRUCTIONS = (() => {\\n  const example = loadProtocolExample();\\n  return [\\n    'You **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:',\\n    '```json',\\n    example,\\n    '```',\\n    'The thoughts field is for your reasoning, and tool_calls is a list of actions to execute.',\\n    'Your response will be parsed as JSON. Do not include any text outside of this JSON object.',\\n    'As responses to the tool calls you will send, you will also receive JSON objects in the form:',\\n    '```json',\\n    '{\\\\n\\\"name\\\":\\\"tool_name\\\",\\\\n\\\"result\\\":\\\"...\\\"\\\\n}',\\n    '```',\\n  ].join('\\\\n');\\n})();\\n\\n// Human-readable descriptions for tools to avoid duplicating them in agent docs\\nconst TOOL_DESCRIPTIONS: Record<string, string> = {\\n  // Base tools\\n  read_files: 'Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).',\\n  search_files: 'Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords',\\n  list_files: 'List files and directories at a relative path from the project root.',\\n  finish_feature: 'Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.',\\n  block_feature: 'Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).',\\n\\n  // Speccer\\n  create_feature: 'Define and add a new, atomic feature to the task. Include a concise title and a clear description.',\\n  finish_spec: 'Signal that the feature specification is complete for the current task.',\\n  block_task: 'Stop work on the task and report why you are blocked at the task level.',\\n\\n  // Developer\\n  write_file: 'Create or overwrite a file with the given content. Always use this to write code or docs.',\\n  rename_file: 'Rename or move a file from one path to another.',\\n  delete_file: 'Delete a file. Use with caution and only when necessary.',\\n  run_test: 'Run the test for the current feature and return the output. Use to verify implementation.',\\n\\n  // Planner\\n  update_feature_plan: 'Save a concise, step-by-step implementation plan for the assigned feature.',\\n\\n  // Tester\\n  update_acceptance_criteria: 'Save a clear, verifiable list of acceptance criteria for the assigned feature.',\\n  update_test: 'Save the Python test script that validates the acceptance criteria for this feature.',\\n\\n  // Contexter\\n  update_feature_context: 'Save the minimal set of file paths (relative to repo root) required to implement the feature.'\\n};\\n\\nfunction toolSigsForAgent(agent: string, taskTools: TaskUtils, fileTools: FileTools, git: GitManager): [Record<string, (args: any) => Promise<any> | any>, string[]] {\\n  const base: Record<string, [(args: any) => Promise<any> | any, string]> = {\\n    read_files: [ (args: { paths: string[] }) => fileTools.readFiles(args.paths), \\\"read_files(paths: list[str]) -> list[str]\\\" ],\\n    search_files: [ (args: { query: string; path?: string }) => fileTools.searchFiles(args.query, args.path ?? '.'), \\\"search_files(query: str, path: str = '.') -> list[str]\\\" ],\\n    block_feature: [ (args: { task_id: string; feature_id: string; reason: string }) => taskTools.blockFeature?.(args.task_id, args.feature_id, args.reason, agent, git), 'block_feature(reason: str)' ],\\n    finish_feature: [ (args: { task_id: string; feature_id: string }) => taskTools.finishFeature?.(args.task_id, args.feature_id, agent, git), 'finish_feature()' ],\\n    list_files: [ (args: { path: string }) => fileTools.listFiles(args.path), 'list_files(path: str)' ],\\n  };\\n\\n  const agentTools: Record<string, [(args: any) => Promise<any> | any, string]> = {};\\n\\n  if (agent === 'speccer') {\\n    agentTools.create_feature = [ (args: { task_id: string; title: string; description: string }) => taskTools.createFeature?.(args.task_id, args.title, args.description), 'create_feature(title: str, description: str)' ];\\n    agentTools.finish_spec = [ (args: { task_id: string }) => taskTools.finishSpec?.(args.task_id, agent, git), 'finish_spec()' ];\\n    agentTools.block_task = [ (args: { task_id: string; reason: string }) => taskTools.blockTask?.(args.task_id, args.reason, agent, git), 'block_task()' ];\\n  } else if (agent === 'developer') {\\n    agentTools.write_file = [ (args: { filename: string; content: string }) => fileTools.writeFile(args.filename, args.content), 'write_file(filename: str, content: str)' ];\\n    agentTools.rename_file = [ (args: { filename: string; new_filename: string }) => fileTools.renameFile(args.filename, args.new_filename), 'rename_file(filename: str, new_filename: str)' ];\\n    agentTools.delete_file = [ (args: { filename: string }) => fileTools.deleteFile(args.filename), 'delete_file(filename: str)' ];\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => taskTools.runTest?.(args.task_id, args.feature_id), 'run_test() -> str' ];\\n  } else if (agent === 'planner') {\\n    agentTools.update_feature_plan = [ (args: { task_id: string; feature_id: string; plan: any }) => taskTools.updateFeaturePlan?.(args.task_id, args.feature_id, args.plan), 'update_feature_plan(plan: str)' ];\\n  } else if (agent === 'tester') {\\n    agentTools.update_acceptance_criteria = [ (args: { task_id: string; feature_id: string; criteria: string[] }) => taskTools.updateAcceptanceCriteria?.(args.task_id, args.feature_id, args.criteria), 'update_acceptance_criteria(criteria: list[str])' ];\\n    agentTools.update_test = [ (args: { task_id: string; feature_id: string; test: string }) => taskTools.updateTest?.(args.task_id, args.feature_id, args.test), 'update_test(test: str)' ];\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => taskTools.runTest?.(args.task_id, args.feature_id), 'run_test() -> str' ];\\n  } else if (agent === 'contexter') {\\n    agentTools.update_feature_context = [ (args: { task_id: string; feature_id: string; context: string[] }) => taskTools.updateFeatureContext?.(args.task_id, args.feature_id, args.context), 'update_feature_context(context: list[str])' ];\\n  }\\n\\n  const merged = { ...base, ...agentTools };\\n  const funcs: Record<string, (args: any) => Promise<any> | any> = {};\\n  const sigs: string[] = [];\\n  for (const [name, [fn, sig]] of Object.entries(merged)) {\\n    if (fn) {\\n      funcs[name] = fn;\\n      const desc = TOOL_DESCRIPTIONS[name] ? ` - ${TOOL_DESCRIPTIONS[name]}` : '';\\n      sigs.push(`${sig}${desc}`);\\n    }\\n  }\\n  return [funcs, sigs];\\n}\\n\\nfunction constructSystemPrompt(agent: string, task: Task, feature: Feature | null, agentSystemPrompt: string, context: string, toolSignatures: string[]): string {\\n  const plan = feature && (agent === 'developer' || agent === 'tester' || agent === 'contexter' || agent === 'planner') ? feature.plan : undefined;\\n  const acceptance = feature && (agent === 'developer' || agent === 'tester') ? feature.acceptance : undefined\\n  const acceptanceStr = acceptance?.map((c, i) => `${i + 1}. ${c}`).join('\\\\n');\\n  const toolSignaturesStr = toolSignatures.map(sig => `- ${sig}`).join('\\\\n');\\n\\n  const featureBlock = feature ? `#ASSIGNED FEATURE: ${feature.title} (ID: ${feature.id})${NEWLINE}##DESCRIPTION: ${feature.description}${NEWLINE}` : '';\\n  const featureRejection = feature?.rejection ? `##REJECTION REASON:${NEWLINE}${feature.rejection}${NEWLINE}` : '';\\n  const taskRejection = task.rejection ? `##REJECTION REASON:${NEWLINE}${task.rejection}` : '';\\n\\n  return [\\n    agentSystemPrompt,\\n    `#CURRENT TASK (ID: ${task.id})`,\\n    '##TITLE:',\\n    task.title,\\n    '##DESCRIPTION:',\\n    task.description,\\n    taskRejection,\\n    '',\\n    featureBlock,\\n    featureRejection,\\n    plan ? '#THE PLAN' + plan : '',\\n    '',\\n    acceptanceStr ? '#ACCEPTANCE CRITERIA:' + acceptanceStr : '',\\n    '',\\n    '#TOOL SIGNATURES:',\\n    `${toolSignaturesStr}`,\\n    '',\\n    '#RESPONSE FORMAT INSTRUCTIONS:',\\n    PROTOCOL_INSTRUCTIONS,\\n    '',\\n    '#CONTEXT FILES PROVIDED:',\\n    context,\\n    '',\\n    'Begin now.'\\n  ].join('\\\\n');\\n}\\n\\n// Attach metadata to messages so history can be reconstructed reliably after persistence\\nfunction annotateMessage<T extends CompletionMessage>(msg: T, meta: { featureId?: string; agentType?: string; turn?: number; source?: string; marker?: string }): T {\\n  const anyMsg = msg as any;\\n  if (meta.featureId) anyMsg.featureId = meta.featureId;\\n  if (meta.agentType) anyMsg.agentType = meta.agentType;\\n  if (typeof meta.turn === 'number') anyMsg.turn = meta.turn;\\n  if (meta.source) anyMsg.source = meta.source;\\n  if (meta.marker) anyMsg.marker = meta.marker;\\n  anyMsg.createdAt = new Date().toISOString();\\n  return msg;\\n}\\n\\nasync function runConversation(opts: {\\n  model: string;\\n  availableTools: Record<string, (args: any) => Promise<any> | any>;\\n  systemPrompt: string;\\n  task: Task;\\n  feature: Feature | null;\\n  agentType: string;\\n  taskTools: TaskUtils;\\n  git: GitManager;\\n  completion: CompletionClient;\\n  complete: (why: 'finish' | 'block' | 'max_turns', info?: any) => void;\\n  emit?: (e: { type: string; payload?: any }) => void; // event sink for logging/stats\\n}) {\\n  const { model, availableTools, systemPrompt, task, feature, agentType, taskTools, git, completion, complete, emit } = opts;\\n  const doEmit = (e: { type: string; payload?: any }) => { try { emit?.(e); } catch {} };\\n\\n  const initialUser: CompletionMessage = annotateMessage(\\n    { role: 'user', content: systemPrompt } as any,\\n    { featureId: feature?.id ?? '__task__', agentType, turn: 0, source: 'initial' }\\n  );\\n  const messages: CompletionMessage[] = [initialUser];\\n  doEmit({ type: 'llm/messages/init', payload: { messages: messages.slice(), turn: 0 } });\\n\\n  for (let i = 0; i < MAX_TURNS_PER_FEATURE; i++) {\\n    try {\\n      // Emit snapshot of request context before calling the LLM\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), turn: i } });\\n      const startedAt = Date.now();\\n      const res = await completion({ model, messages, response_format: { type: 'json_object' } });\\n      const durationMs = Date.now() - startedAt;\\n\\n      const assistant = annotateMessage(\\n        { role: 'assistant' as const, content: res.message.content },\\n        { featureId: feature?.id ?? '__task__', agentType, turn: i }\\n      );\\n      messages.push(assistant);\\n      // Emit assistant message and timing\\n      doEmit({ type: 'llm/message', payload: { message: assistant, durationMs } });\\n\\n      // Parse and log succinct info\\n      let parsed: AgentResponse | undefined;\\n      try { parsed = JSON.parse((assistant as any).content) as AgentResponse; } catch {}\\n      const toolCalls: ToolCall[] = parsed?.tool_calls ?? [];\\n      logLLMStep({ turn: i, thoughts: parsed?.thoughts, toolCalls, durationMs, tag: agentType });\\n\\n      if (!toolCalls.length) {\\n        // No tool calls; continue loop.\\n        doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), turn: i, note: 'no_tool_calls' } });\\n        doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} complete` } });\\n        continue;\\n      }\\n\\n      const toolOutputs: ToolResult[] = [];\\n\\n      for (const call of toolCalls) {\\n        const toolName = (call.tool_name || call.tool || call.name || 'unknown_tool');\\n        const args = (call.arguments || call.parameters || {}) as Record<string, any>;\\n\\n        if (availableTools[toolName]) {\\n          if (!('task_id' in args)) args.task_id = task.id;\\n          if (feature && !('feature_id' in args)) args.feature_id = feature.id;\\n          const result = await Promise.resolve(availableTools[toolName](args));\\n          toolOutputs.push({ name: toolName, result });\\n        } else {\\n          toolOutputs.push({ name: toolName, result: `Error: Tool '${toolName}' not found.` });\\n        }\\n\\n        // Termination tools mirror Python; do not append a tool result turn, final message is assistant\\n        if (['finish_feature', 'block_feature', 'finish_spec', 'block_task'].includes(toolName)) {\\n          doEmit({ type: 'llm/messages/final', payload: { messages: messages.slice(), tool: toolName } });\\n          complete(toolName === 'block_feature' || toolName === 'block_task' ? 'block' : 'finish');\\n          return;\\n        }\\n      }\\n\\n      // Append tool results as a dedicated 'tool' role message to avoid confusing with user turns\\n      const toolResultMsg: CompletionMessage = annotateMessage(\\n        { role: 'user', content: JSON.stringify(toolOutputs) } as any,\\n        { featureId: feature?.id ?? '__task__', agentType, turn: i, source: 'tools' }\\n      );\\n      messages.push(toolResultMsg);\\n      doEmit({ type: 'llm/message', payload: { message: toolResultMsg, turn: i, source: 'tools' } });\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), turn: i, note: 'tools_appended' } });\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} tool calls processed` } });\\n    } catch (e) {\\n      if (feature) {\\n        await taskTools.blockFeature?.(task.id, feature.id, `Agent loop failed: ${e}`, agentType, git);\\n      } else {\\n        await taskTools.blockTask?.(task.id, `Agent loop failed: ${e}`, agentType, git);\\n      }\\n      doEmit({ type: 'llm/messages/error', payload: { error: String(e), messages: messages.slice() } });\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: undefined, message: 'Error encountered' } });\\n      logger.error('Agent loop error:', e as any);\\n      complete('block', e);\\n      return;\\n    }\\n  }\\n\\n  // Max turns reached -> block\\n  if (feature) {\\n    await taskTools.blockFeature?.(task.id, feature.id, 'Agent loop exceeded max turns', agentType, git);\\n  } else {\\n    await taskTools.blockTask?.(task.id, 'Agent loop exceeded max turns', agentType, git);\\n  }\\n  doEmit({ type: 'llm/messages/final', payload: { messages: [{ role: 'system', content: systemPrompt }] as CompletionMessage[], reason: 'max_turns' } });\\n  doEmit({ type: 'run/progress/snapshot', payload: { progress: 1, message: 'Max turns reached' } });\\n  logger.warn('Max turns reached without completion.');\\n  complete('max_turns');\\n}\\n\\nasync function runAgentOnTask(model: string, agentType: string, task: Task, taskTools: TaskUtils, fileTools: FileTools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\n  logger.debug(`\\\\n--- Activating Agent ${agentType} for task: [${task.id}] ${task.title} ---`);\\n  const agentDocs = loadAgentDocs(agentType);\\n  const contextFiles = ['docs/FILE_ORGANISATION.md'];\\n  const [funcs, sigs] = toolSigsForAgent(agentType, taskTools, fileTools, git);\\n  const context = await Promise.resolve(fileTools.readFiles(contextFiles));\\n  const systemPrompt = constructSystemPrompt(agentType, task, null, agentDocs, context, sigs);\\n\\n  await runConversation({\\n    model,\\n    availableTools: funcs,\\n    systemPrompt,\\n    task,\\n    feature: null,\\n    agentType,\\n    taskTools,\\n    git,\\n    completion,\\n    complete: () => {},\\n    emit,\\n  });\\n}\\n\\nasync function runAgentOnFeature(model: string, agentType: string, task: Task, feature: Feature, taskTools: TaskUtils, fileTools: FileTools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\n  logger.debug(`\\\\n--- Activating Agent ${agentType} for Feature: [${feature.id}] ${feature.title} ---`);\\n\\n  if (agentType === 'developer') await taskTools.updateFeatureStatus?.(task.id, feature.id, '~');\\n\\n  const agentDocs = loadAgentDocs(agentType);\\n  const featureContextFiles = ['docs/FILE_ORGANISATION.md', ...(feature.context ?? [])];\\n  const [funcs, sigs] = toolSigsForAgent(agentType, taskTools, fileTools, git);\\n  const context = await Promise.resolve(fileTools.readFiles(featureContextFiles));\\n  const systemPrompt = constructSystemPrompt(agentType, task, feature, agentDocs, context, sigs);\\n\\n  if (agentType === 'developer') await taskTools.updateFeatureStatus?.(task.id, feature.id, '~');\\n\\n  await runConversation({\\n    model,\\n    availableTools: funcs,\\n    systemPrompt,\\n    task,\\n    feature,\\n    agentType,\\n    taskTools,\\n    git,\\n    completion,\\n    complete: () => {},\\n    emit,\\n  });\\n}\\n\\nasync function runOrchestrator(opts: {\\n  model: string;\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\n  taskId: string; \\n  featureId?: string; \\n  projectDir?: string;\\n  taskTools: TaskUtils;\\n  fileTools: FileTools;\\n  git: GitManager;\\n  completion: CompletionClient;\\n  emit?: (e: { type: string; payload?: any }) => void;\\n}) {\\n  const { model, agentType, taskId, projectDir, taskTools, fileTools, git, completion, emit } = opts;\\n\\n  if (projectDir) taskTools.setProjectRoot(projectDir);\\n  if (projectDir) fileTools.setProjectRoot(projectDir);\\n\\n  const currentTask: Task = await taskTools.getTask(taskId);\\n  if (!currentTask) {\\n    logger.warn('No available tasks to work on in the repository.');\\n    return;\\n  }\\n\\n  logger.debug(`Selected Task: [${currentTask.id}] ${currentTask.title}`);\\n\\n  const branch = `features/${currentTask.id}`;\\n  try {\\n    await git.checkoutBranch(branch, true);\\n  } catch (e) {\\n    logger.warn(`Could not create or checkout branch '${branch}': ${e}`);\\n    await git.checkoutBranch(branch, false);\\n  }\\n  try {\\n    await git.pull(branch);\\n  } catch (e) {\\n    logger.warn(`Could not pull branch '${branch}': ${e}`);\\n  }\\n\\n  const processed = new Set<string>();\\n\\n  // Aggregate all messages across features for this run\\n  let aggregatedMessages: CompletionMessage[] = [];\\n\\n  if (agentType === 'speccer') {\\n    const freshTask = await taskTools.getTask(currentTask.id);\\n    await runAgentOnTask(model, agentType, freshTask, taskTools, fileTools, git, completion, (e) => {\\n      // For task-level runs, forward events as-is and track messages when present\\n      if (e?.payload?.messages) {\\n        const msgs = e.payload.messages as CompletionMessage[];\\n        // Ensure metadata on messages for task-level runs\\n        const annotated = msgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? '__task__', agentType, turn: (m as any).turn ?? idx }));\\n        aggregatedMessages = annotated.slice();\\n        emit?.({ ...e, payload: { ...e.payload, messages: aggregatedMessages.slice() } });\\n      } else {\\n        emit?.(e);\\n      }\\n    });\\n    return;\\n  }\\n\\n  while (true) {\\n    const freshTask = await taskTools.getTask(currentTask.id);\\n    const next = taskTools.findNextAvailableFeature(freshTask, processed, agentType !== 'developer');\\n    if (!next) {\\n      logger.debug(`\\\\nNo more available features for task ${freshTask.id}.`);\\n      break;\\n    }\\n\\n    // Insert a system marker before each feature to clearly separate in UI and history\\n    const featureMarker: CompletionMessage = annotateMessage(\\n      { role: 'system', content: `--- BEGIN FEATURE ${next.id}: ${next.title} ---` } as any,\\n      { featureId: next.id, agentType, marker: 'feature_begin' }\\n    );\\n    aggregatedMessages.push(featureMarker);\\n    emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), note: 'feature_begin', featureId: next.id } });\\n\\n    // Wrap emit to merge current feature's messages with the aggregate so far\\n    let lastFeatureMessages: CompletionMessage[] = [];\\n    const baseEmit = emit;\\n    const wrappedEmit = (e: { type: string; payload?: any }) => {\\n      const t = e?.type;\\n      if ((t === 'llm/messages/init' || t === 'llm/messages/snapshot' || t === 'llm/messages/final') && e?.payload?.messages) {\\n        try {\\n          const featureMsgs: CompletionMessage[] = e.payload.messages || [];\\n          // Ensure every message is tagged with this feature id and agentType for persistence\\n          const ensured = featureMsgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? next.id, agentType, turn: (m as any).turn ?? idx }));\\n          lastFeatureMessages = ensured.slice();\\n          const combined = aggregatedMessages.concat(ensured);\\n          const payload = { ...e.payload, messages: combined };\\n          baseEmit?.({ ...e, payload });\\n          return;\\n        } catch {}\\n      }\\n      baseEmit?.(e);\\n    };\\n\\n    await runAgentOnFeature(model, agentType, freshTask, next, taskTools, fileTools, git, completion, wrappedEmit);\\n\\n    // After the feature completes, fold its messages into the aggregate\\n    if (lastFeatureMessages && lastFeatureMessages.length) {\\n      aggregatedMessages = aggregatedMessages.concat(lastFeatureMessages);\\n      // Emit a snapshot to persist the full sequence after folding\\n      emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), note: 'feature_folded', featureId: next.id } });\\n    }\\n\\n    processed.add(next.id);\\n  }\\n\\n  // Emit final snapshot at end of task run with complete sequence of feature conversations\\n  emit?.({ type: 'llm/messages/final', payload: { messages: aggregatedMessages.slice(), note: 'task_run_complete' } });\\n}\\n\\n// --- Isolated Runner (mimic Python run.py) ---\\n\\nfunction shouldIgnoreCopy(relPath: string): boolean {\\n  // Ignore common build, cache, and IDE artifacts for TypeScript/Node/Electron projects\\n  // Preserve .git (do NOT ignore)\\n  const parts = relPath.split(path.sep);\\n  const name = parts[parts.length - 1] || relPath;\\n\\n  // If path is within .git, do not ignore (preserve repo history/branches)\\n  if (parts.includes('.git')) return false;\\n\\n  const dirIgnore = new Set([\\n    // Package managers and caches\\n    'node_modules', '.pnpm', '.pnp', '.pnp.cjs', '.pnp.js', '.npm', '.yarn', '.yarn-cache', '.yarnrc',\\n    // Build/output directories\\n    'dist', 'build', 'out', 'release', 'storybook-static',\\n    // Framework-specific\\n    '.next', 'next', '.nuxt', '.svelte-kit',\\n    // Bundlers and dev servers caches\\n    '.vite', '.rollup.cache', '.parcel-cache', '.webpack',\\n    // Test/coverage\\n    'coverage', '.nyc_output',\\n    // Monorepo/turbo caches\\n    '.turbo',\\n    // Generic caches\\n    '.cache', '.eslintcache', '.rpt2_cache', '.tscache',\\n    // Editors/IDE\\n    '.idea', '.vscode',\\n    // Python (from original mirror)\\n    'venv', '__pycache__',\\n    // Logs and temp\\n    'logs', 'tmp', 'temp'\\n  ]);\\n\\n  // If any path segment matches an ignored dir name\\n  if (parts.some(p => dirIgnore.has(p))) return true;\\n\\n  // Ignore specific file patterns\\n  const lower = name.toLowerCase();\\n  if (lower === '.ds_Store'.toLowerCase() || lower === 'thumbs.db') return true;\\n  if (lower.endsWith('.log')) return true; // npm/yarn/pnpm debug logs\\n  if (lower.endsWith('.pyc')) return true; // Python bytecode files\\n  if (lower.endsWith('.tsbuildinfo')) return true; // TypeScript incremental build info\\n\\n  // Ignore Electron asar content markers when encountered as path segments\\n  if (parts.some(p => p.endsWith('.asar') || p.endsWith('.asar.unpacked'))) return true;\\n\\n  return false;\\n}\\n\\nasync function copyTree(src: string, dest: string) {\\n  // Recursively copy, respecting ignore patterns and skipping asar/virtual entries\\n  let stat: fs.Stats;\\n  try {\\n    stat = await fsp.stat(src);\\n  } catch (e: any) {\\n    throw new Error(`Source path does not exist or is not accessible: ${src} (${e?.code || e})`);\\n    }\\n  if (!stat.isDirectory()) throw new Error(`Source ${src} is not a directory`);\\n  await fsp.mkdir(dest, { recursive: true });\\n\\n  const walk = async (from: string, to: string) => {\\n    let entries: fs.Dirent[] = [] as unknown as fs.Dirent[];\\n    try {\\n      entries = await fsp.readdir(from, { withFileTypes: true });\\n    } catch (e: any) {\\n      // Skip unreadable directories (e.g., asar virtuals)\\n      logger.warn(`copyTree: Skipping unreadable directory ${from}: ${e?.code || e}`);\\n      return;\\n    }\\n    for (const entry of entries) {\\n      const rel = path.relative(src, path.join(from, entry.name));\\n      if (shouldIgnoreCopy(rel)) continue;\\n      const srcPath = path.join(from, entry.name);\\n      const dstPath = path.join(to, entry.name);\\n\\n      // Skip any path that traverses into an asar archive\\n      if (srcPath.includes('.asar')) continue;\\n\\n      try {\\n        if (entry.isDirectory()) {\\n          await fsp.mkdir(dstPath, { recursive: true });\\n          await walk(srcPath, dstPath);\\n        } else if (entry.isSymbolicLink()) {\\n          // Resolve symlink target and copy contents (best-effort)\\n          try {\\n            const linkTarget = await fsp.readlink(srcPath);\\n            const resolved = path.resolve(path.dirname(srcPath), linkTarget);\\n            const st = await fsp.stat(resolved);\\n            if (st.isDirectory()) {\\n              await fsp.mkdir(dstPath, { recursive: true });\\n              await walk(resolved, dstPath);\\n            } else {\\n              await fsp.copyFile(resolved, dstPath);\\n            }\\n          } catch {\\n            // Fallback: copy file bytes of the link itself (as file)\\n            try { await fsp.copyFile(srcPath, dstPath); } catch {}\\n          }\\n        } else if (entry.isFile()) {\\n          await fsp.copyFile(srcPath, dstPath);\\n        }\\n      } catch (e: any) {\\n        // Skip problematic entries (e.g., ENOENT due to virtualized packaging paths)\\n        if (e && (e.code === 'ENOENT' || e.code === 'EBUSY' || e.code === 'EPERM')) {\\n          logger.warn(`copyTree: Skipping ${srcPath}: ${e.code}`);\\n          continue;\\n        }\\n        throw e;\\n      }\\n    }\\n  };\\n\\n  await walk(src, dest);\\n}\\n\\nexport async function runIsolatedOrchestrator(opts: {\\n  model: string;\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\n  projectId: string; \\n  taskId: string;\\n  featureId?: string; \\n  taskTools: TaskUtils,\\n  fileTools: FileTools,\\n  gitFactory: (projectRoot: string) => GitManager;  // git bound to projectRoot\\n  completion: CompletionClient;\\n  emit?: (e: { type: string; payload?: any }) => void;\\n}) {\\n  const { model, agentType, projectId, taskId, featureId, taskTools, fileTools, gitFactory, completion, emit } = opts;\\n\\n  const projectDir = await taskTools.getProjectDir(projectId);\\n\\n  // Create temp workspace\\n  const tmpBase = fs.mkdtempSync(path.join(os.tmpdir(), 'factory-ts-'));\\n  // Keep a subfolder to host the copied source\\n  const workspace = path.join(tmpBase, 'workspace');\\n\\n  logger.info(`Copying repository from '${projectDir}' to temporary workspace: '${workspace}'`);\\n  try {\\n    await copyTree(projectDir, workspace);\\n  } catch (e) {\\n    logger.error(`FATAL: Failed to copy repository to temporary directory from '${projectDir}' -> '${workspace}': ${e}`);\\n    // best-effort cleanup\\n    try { fs.rmSync(tmpBase, { recursive: true, force: true }); } catch {}\\n    return;\\n  }\\n\\n  const git = gitFactory(workspace);\\n\\n  try {\\n    await runOrchestrator({\\n      model,\\n      agentType,\\n      taskId,\\n      featureId,\\n      projectDir: workspace,\\n      taskTools,\\n      fileTools,\\n      git,\\n      completion,\\n      emit,\\n    });\\n  } catch (e) {\\n    logger.error(`An error occurred while running the agent orchestrator: ${e}`);\\n  } finally {\\n    // Cleanup temporary directory\\n    try {\\n      fs.rmSync(tmpBase, { recursive: true, force: true });\\n      logger.info('Agent run finished. Temporary directory cleaned up.');\\n    } catch (e) {\\n      logger.warn(`Failed to cleanup temporary directory '${tmpBase}': ${e}`);\\n    }\\n  }\\n}\\n\",\"src/tools/factory/mainOrchestrator.js\":\"import { ipcMain, webContents } from 'electron';\\nimport IPC_HANDLER_KEYS from '../../ipcHandlersKeys.js';\\nimport path from 'node:path';\\nimport fs from 'node:fs';\\n\\n// Load local package factory-ts from monorepo\\n// Use dynamic import to avoid issues with CJS/ESM resolution in Electron\\nlet factoryTs;\\nasync function loadFactory()\\n{\\n  if (factoryTs) return factoryTs;\\n  const cwd = process.cwd();\\n  const distEsm = path.resolve(cwd, 'packages/factory-ts/dist/index.js');\\n  const distCjs = path.resolve(cwd, 'packages/factory-ts/dist/index.cjs');\\n  try {\\n    console.log('[factory] Loading factory-ts from', distEsm);\\n    factoryTs = await import(distEsm);\\n  } catch (errEsm) {\\n    console.warn('[factory] Failed to load ESM build, trying CJS', errEsm?.message || errEsm);\\n    try {\\n      factoryTs = await import(distCjs);\\n    } catch (errCjs) {\\n      console.error('[factory] Failed to load factory-ts from dist. Did you build it? npm run factory:build');\\n      console.error(errCjs?.stack || String(errCjs));\\n      throw errCjs;\\n    }\\n  }\\n  console.log('[factory] factory-ts loaded successfully');\\n  return factoryTs;\\n}\\n\\nconst RUN_SUBSCRIBERS = new Map(); // runId -> Set<webContentsId>\\nconst RUNS = new Map(); // runId -> RunHandle\\nconst RUN_META = new Map(); // runId -> metadata snapshot\\nconst RUN_TIMERS = new Map(); // runId -> heartbeat timer\\nconst RUN_MESSAGES = new Map(); // runId -> last messages array\\n\\nlet PRICING = null;\\nlet HISTORY = null;\\n\\nfunction sendEventToWC(wcId, runId, event) {\\n  const wc = webContents.fromId(wcId);\\n  if (wc && !wc.isDestroyed()) {\\n    try {\\n      wc.send(IPC_HANDLER_KEYS.FACTORY_EVENT, { runId, event });\\n    } catch (err) {\\n      console.warn(`[factory] Failed to send event to wc ${wcId} for run ${runId}:`, err?.message || err);\\n    }\\n  }\\n}\\n\\nfunction broadcastEventToSubscribers(runId, event) {\\n  const subscribers = RUN_SUBSCRIBERS.get(runId);\\n  if (!subscribers || subscribers.size === 0) return;\\n  for (const wcId of subscribers) {\\n    sendEventToWC(wcId, runId, event);\\n  }\\n}\\n\\nfunction maskSecrets(obj) {\\n  try {\\n    const o = JSON.parse(JSON.stringify(obj));\\n    if (o && o.llmConfig && typeof o.llmConfig === 'object') {\\n      if ('apiKey' in o.llmConfig) o.llmConfig.apiKey = '***';\\n    }\\n    return o;\\n  } catch {\\n    return obj;\\n  }\\n}\\n\\nfunction nowIso() {\\n  return new Date().toISOString();\\n}\\n\\nfunction persistMeta(runId) {\\n  try {\\n    const meta = RUN_META.get(runId);\\n    if (!meta || !HISTORY) return;\\n    const h = HISTORY;\\n    if (typeof h.addOrUpdateRun === 'function') {\\n      h.addOrUpdateRun(meta);\\n    } else if (typeof h.updateRunMeta === 'function') {\\n      h.updateRunMeta(meta.runId, meta);\\n    } else if (typeof h.upsertRun === 'function') {\\n      h.upsertRun(meta);\\n    } else if (typeof h.addRun === 'function') {\\n      h.addRun(meta);\\n    } else {\\n      // No known persistence API; noop\\n    }\\n  } catch (e) {\\n    console.warn('[factory] persistMeta error', e?.message || e);\\n  }\\n}\\n\\nfunction persistMessages(runId, messages) {\\n  try {\\n    if (!HISTORY || !messages) return;\\n    const h = HISTORY;\\n    if (typeof h.writeMessages === 'function') {\\n      h.writeMessages(runId, messages);\\n    } else if (typeof h.saveMessages === 'function') {\\n      h.saveMessages(runId, messages);\\n    }\\n  } catch (e) {\\n    console.warn('[factory] persistMessages error', e?.message || e);\\n  }\\n}\\n\\nfunction updateMetaFromEvent(runId, e) {\\n  const meta = RUN_META.get(runId);\\n  if (!meta) return;\\n  meta.updatedAt = e?.ts || e?.time || nowIso();\\n  const type = e?.type;\\n  const payload = e?.payload || {};\\n  if (type === 'run/progress' || type === 'run/progress/snapshot') {\\n    if (typeof payload?.progress === 'number') meta.progress = payload.progress;\\n    else if (typeof payload?.percent === 'number') meta.progress = Math.max(0, Math.min(1, payload.percent / 100));\\n    if (payload?.message) meta.message = payload.message;\\n  } else if (type === 'run/usage') {\\n    if (payload?.costUSD != null) meta.costUSD = payload.costUSD;\\n    else if (payload?.costUsd != null) meta.costUSD = payload.costUsd;\\n    else if (payload?.usd != null) meta.costUSD = payload.usd;\\n    if (payload?.promptTokens != null) meta.promptTokens = payload.promptTokens;\\n    if (payload?.completionTokens != null) meta.completionTokens = payload.completionTokens;\\n    if (payload?.provider) meta.provider = payload.provider;\\n    if (payload?.model) meta.model = payload.model;\\n  } else if (type === 'run/start') {\\n    if (payload?.llm?.provider) meta.provider = payload.llm.provider;\\n    if (payload?.llm?.model) meta.model = payload.llm.model;\\n  } else if (type === 'run/error') {\\n    meta.state = 'error';\\n    meta.message = payload?.message || payload?.error || 'Error';\\n  } else if (type === 'run/cancelled') {\\n    meta.state = 'cancelled';\\n    meta.message = payload?.reason || 'Cancelled';\\n  } else if (type === 'run/completed' || type === 'run/complete') {\\n    meta.state = 'completed';\\n    meta.message = payload?.message || payload?.summary || 'Completed';\\n  }\\n  // Persist snapshot on each update\\n  persistMeta(runId);\\n}\\n\\nfunction loadWorkspaceDotenv(projectRoot) {\\n  try {\\n    const dotenv = require('dotenv');\\n    const envPath = path.join(projectRoot, '.env');\\n    if (fs.existsSync(envPath)) {\\n      dotenv.config({ path: envPath });\\n      console.log('[factory] Loaded workspace .env from', envPath);\\n    } else {\\n      console.log('[factory] No .env at', envPath);\\n    }\\n  } catch (e) {\\n    // If dotenv isn't available or fails, ignore silently to avoid crashing Electron main\\n    console.warn('[factory] dotenv not loaded in main process (optional):', e?.message || e);\\n  }\\n}\\n\\n// --- Normalization: convert persisted messages array into feature-keyed logs ---\\nconst DEFAULT_FEATURE_KEY = '__task__';\\nfunction parseFeatureMarker(content) {\\n  if (!content || typeof content !== 'string') return null;\\n  // Matches lines like: --- BEGIN FEATURE <id>: <title> ---\\n  const m = /^---\\\\s*BEGIN\\\\s+FEATURE\\\\s+([^:]+)\\\\s*:/.exec(content);\\n  return m ? String(m[1]).trim() : null;\\n}\\nfunction ensureGroup(map, featureId) {\\n  if (!map[featureId]) {\\n    map[featureId] = { startDate: new Date().toISOString(), featureId, messages: [] };\\n  }\\n  return map[featureId];\\n}\\nfunction normalizeRunMessagesToFeatureLog(messages) {\\n  // If already in the expected shape (object of { featureId: { startDate, messages } }), return as-is\\n  if (messages && !Array.isArray(messages) && typeof messages === 'object') {\\n    return messages;\\n  }\\n  const result = {};\\n  if (!Array.isArray(messages)) {\\n    // Unknown shape -> fallback to empty task bucket\\n    result[DEFAULT_FEATURE_KEY] = { startDate: new Date().toISOString(), featureId: DEFAULT_FEATURE_KEY, messages: [] };\\n    return result;\\n  }\\n  let current = DEFAULT_FEATURE_KEY;\\n  ensureGroup(result, current);\\n  for (const msg of messages) {\\n    try {\\n      const role = msg?.role;\\n      const content = msg?.content;\\n      if (role === 'system') {\\n        const fid = parseFeatureMarker(content);\\n        if (fid) {\\n          current = fid;\\n          ensureGroup(result, current);\\n          // Do not include the marker message in the feature messages\\n          continue;\\n        }\\n      }\\n      const grp = ensureGroup(result, current);\\n      // Push shallow clone to avoid accidental mutations downstream\\n      grp.messages.push({ ...msg });\\n    } catch {}\\n  }\\n  // Assign a simple endDate for groups that have messages\\n  const now = new Date().toISOString();\\n  for (const fid of Object.keys(result)) {\\n    const g = result[fid];\\n    if (g && Array.isArray(g.messages) && g.messages.length > 0) {\\n      g.endDate = now;\\n    }\\n  }\\n  return result;\\n}\\n\\nexport async function registerFactoryIPC(mainWindow, projectRoot) {\\n  console.log('[factory] Registering IPC handlers. projectRoot=', projectRoot);\\n\\n  // Ensure workspace .env is loaded in main process so child processes and libs see credentials\\n  loadWorkspaceDotenv(projectRoot);\\n\\n  const factory = await loadFactory();\\n  const { createOrchestrator, createHistoryStore, createPricingManager } = factory\\n\\n  try {\\n    const dbPath = path.join(projectRoot, '.factory', 'history.sqlite');\\n    if (typeof createHistoryStore === 'function') {\\n      console.log('[factory] Initializing history store at', dbPath);\\n      HISTORY = createHistoryStore({ dbPath });\\n    } else {\\n      console.log('[factory] History store not available; proceeding without persistence');\\n    }\\n  } catch (err) {\\n    console.warn('[factory] Optional history init failed; continuing without it:', err?.message || err);\\n  }\\n\\n  // Initialize pricing manager and keep reference for IPC operations\\n  try {\\n    PRICING = createPricingManager({ projectRoot });\\n    console.log('[factory] Pricing manager initialized. Loaded', PRICING?.listPrices()?.prices?.length || 0, 'prices.');\\n  } catch (err) {\\n    console.warn('[factory] Failed to initialize pricing manager:', err?.message || err);\\n  }\\n\\n  console.log('[factory] Creating orchestrator');\\n  const orchestrator = createOrchestrator({ projectRoot, history: HISTORY, pricing: PRICING });\\n  console.log('[factory] Orchestrator ready');\\n\\n  function startHeartbeat(runId) {\\n    const prev = RUN_TIMERS.get(runId);\\n    if (prev) clearInterval(prev);\\n    const timer = setInterval(() => {\\n      const meta = RUN_META.get(runId);\\n      if (!meta) return;\\n      // Only heartbeat while running\\n      if (meta.state === 'running') {\\n        const evt = { type: 'run/heartbeat', payload: {}, ts: nowIso() };\\n        updateMetaFromEvent(runId, evt);\\n        broadcastEventToSubscribers(runId, evt);\\n      }\\n    }, 15000);\\n    RUN_TIMERS.set(runId, timer);\\n  }\\n\\n  function stopHeartbeat(runId) {\\n    const t = RUN_TIMERS.get(runId);\\n    if (t) {\\n      clearInterval(t);\\n      RUN_TIMERS.delete(runId);\\n    }\\n  }\\n\\n  function attachRun(runHandle, initMeta) {\\n    console.log('[factory] Attaching run', runHandle?.id);\\n    RUNS.set(runHandle.id, runHandle);\\n    RUN_META.set(runHandle.id, initMeta);\\n    // Persist initial meta\\n    persistMeta(runHandle.id);\\n    startHeartbeat(runHandle.id);\\n\\n    const unsubscribe = runHandle.onEvent((e) => {\\n      try {\\n        // Rich log for visibility; include payload for llm events\\n        const t = e?.type || 'unknown';\\n        if (String(t).startsWith('llm/')) {\\n          console.log('[factory] event', runHandle.id, t, e?.payload ? JSON.parse(JSON.stringify(e.payload)) : undefined);\\n        } else if (t === 'run/log' || t === 'run/progress' || t === 'run/progress/snapshot') {\\n          console.log('[factory] event', runHandle.id, t, e?.payload?.message || '');\\n        } else {\\n          console.log('[factory] event', runHandle.id, t);\\n        }\\n      } catch {}\\n\\n      // Capture and persist messages when provided (init, snapshots, or final)\\n      try {\\n        if ((e?.type === 'llm/messages/snapshot' || e?.type === 'llm/messages/final' || e?.type === 'llm/messages/init') && e?.payload?.messages) {\\n          RUN_MESSAGES.set(runHandle.id, e.payload.messages);\\n          persistMessages(runHandle.id, e.payload.messages);\\n        }\\n      } catch (err) {\\n        console.warn('[factory] Failed to persist messages for', runHandle.id, err?.message || err);\\n      }\\n\\n      updateMetaFromEvent(runHandle.id, e);\\n      broadcastEventToSubscribers(runHandle.id, e);\\n\\n      // If we receive a run/cancelled event, proactively flush last messages (if any)\\n      if (e?.type === 'run/cancelled') {\\n        const last = RUN_MESSAGES.get(runHandle.id);\\n        if (last) persistMessages(runHandle.id, last);\\n      }\\n    });\\n\\n    const cleanup = () => {\\n      console.log('[factory] Cleaning up run', runHandle.id);\\n      try { unsubscribe(); } catch {}\\n      stopHeartbeat(runHandle.id);\\n      RUNS.delete(runHandle.id);\\n      RUN_SUBSCRIBERS.delete(runHandle.id);\\n      RUN_MESSAGES.delete(runHandle.id);\\n      // keep RUN_META for a while? Persisted already\\n      RUN_META.delete(runHandle.id);\\n    };\\n\\n    runHandle.onEvent((e) => {\\n      if (e?.type === 'run/cancelled' || e?.type === 'run/completed' || e?.type === 'run/complete' || e?.type === 'run/error') {\\n        cleanup();\\n      }\\n    });\\n  }\\n\\n  // Helper to proactively mark and persist cancellation, even if the run handle doesn't emit an event\\n  function markCancelled(runId, reason) {\\n    const meta = RUN_META.get(runId);\\n    if (!meta) return;\\n    const evt = { type: 'run/cancelled', payload: { reason: reason || 'Cancelled' }, ts: nowIso() };\\n    updateMetaFromEvent(runId, evt);\\n    broadcastEventToSubscribers(runId, evt);\\n    // Persist last known messages if we have any\\n    const last = RUN_MESSAGES.get(runId);\\n    if (last) persistMessages(runId, last);\\n    stopHeartbeat(runId);\\n  }\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_START_TASK, (_evt, { agentType, projectId, taskId, llmConfig, options }) => {\\n    console.log('[factory] START_TASK', maskSecrets({ agentType, projectId, taskId, llmConfig, options }));\\n    try {\\n      const run = orchestrator.startRun({ agentType, projectId, taskId, llmConfig, options });\\n      console.log('[factory] Run started (task)', run?.id);\\n      const initMeta = {\\n        runId: run.id,\\n        agentType,\\n        projectId,\\n        taskId,\\n        featureId: undefined,\\n        state: 'running',\\n        message: 'Starting agent... ',\\n        progress: undefined,\\n        costUSD: undefined,\\n        promptTokens: undefined,\\n        completionTokens: undefined,\\n        provider: llmConfig?.provider,\\n        model: llmConfig?.model,\\n        startedAt: nowIso(),\\n        updatedAt: nowIso(),\\n      };\\n      attachRun(run, initMeta);\\n      // Emit a synthetic start snapshot\\n      broadcastEventToSubscribers(run.id, { type: 'run/snapshot', payload: initMeta, ts: nowIso() });\\n      return { runId: run.id };\\n    } catch (err) {\\n      console.error('[factory] Failed to start task run', err?.stack || String(err));\\n      throw err;\\n    }\\n  });\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_START_FEATURE, (_evt, { agentType, projectId, taskId, featureId, llmConfig, options }) => {\\n    console.log('[factory] START_FEATURE', maskSecrets({ agentType, projectId, taskId, featureId, llmConfig, options }));\\n    try {\\n      const run = orchestrator.startRun({ agentType, projectId, taskId, featureId, llmConfig, options });\\n      console.log('[factory] Run started (feature)', run?.id);\\n      const initMeta = {\\n        runId: run.id,\\n        agentType,\\n        projectId,\\n        taskId,\\n        featureId,\\n        state: 'running',\\n        message: 'Starting agent... ',\\n        progress: undefined,\\n        costUSD: undefined,\\n        promptTokens: undefined,\\n        completionTokens: undefined,\\n        provider: llmConfig?.provider,\\n        model: llmConfig?.model,\\n        startedAt: nowIso(),\\n        updatedAt: nowIso(),\\n      };\\n      attachRun(run, initMeta);\\n      // Emit a synthetic start snapshot\\n      broadcastEventToSubscribers(run.id, { type: 'run/snapshot', payload: initMeta, ts: nowIso() });\\n      return { runId: run.id };\\n    } catch (err) {\\n      console.error('[factory] Failed to start feature run', err?.stack || String(err));\\n      throw err;\\n    }\\n  });\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_CANCEL_RUN, (_evt, { runId, reason }) => {\\n    console.log('[factory] CANCEL_RUN', { runId, reason });\\n    const run = RUNS.get(runId);\\n    // Proactively mark as cancelled for UI/history even if run handle doesn't emit an event\\n    try { markCancelled(runId, reason); } catch {}\\n    if (run) {\\n      try { run.cancel(reason); } catch (err) { console.warn('[factory] Error cancelling run', runId, err?.message || err); }\\n    } else {\\n      console.warn('[factory] Cancel requested for unknown run', runId);\\n    }\\n    return { ok: true };\\n  });\\n\\n  ipcMain.on(IPC_HANDLER_KEYS.FACTORY_SUBSCRIBE, (evt, { runId }) => {\\n    const wcId = evt.sender.id;\\n    console.log('[factory] SUBSCRIBE', { runId, wcId });\\n    let set = RUN_SUBSCRIBERS.get(runId);\\n    if (!set) {\\n      set = new Set();\\n      RUN_SUBSCRIBERS.set(runId, set);\\n    }\\n    set.add(wcId);\\n    evt.sender.once('destroyed', () => {\\n      const s = RUN_SUBSCRIBERS.get(runId);\\n      if (s) {\\n        s.delete(wcId);\\n        console.log('[factory] Unsubscribed (wc destroyed)', { runId, wcId });\\n      }\\n    });\\n\\n    // Immediately send a snapshot to this subscriber to sync current state\\n    const meta = RUN_META.get(runId);\\n    if (meta) {\\n      sendEventToWC(wcId, runId, { type: 'run/snapshot', payload: meta, ts: nowIso() });\\n    }\\n  });\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_LIST_ACTIVE, () => {\\n    // Return currently running runs (best-effort snapshot)\\n    const list = [];\\n    for (const [runId, meta] of RUN_META.entries()) {\\n      if (meta?.state === 'running') {\\n        list.push({ ...meta, runId });\\n      }\\n    }\\n    return list;\\n  });\\n\\n  // History listing and messages API\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_HISTORY_LIST, () => {\\n    try {\\n      return HISTORY?.listRuns?.() || [];\\n    } catch (e) {\\n      console.warn('[factory] history:list error', e?.message || e);\\n      return [];\\n    }\\n  });\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_HISTORY_MESSAGES, (_evt, { runId }) => {\\n    try {\\n      const raw = HISTORY?.getRunMessages?.(runId) || [];\\n      const normalized = normalizeRunMessagesToFeatureLog(raw);\\n      return normalized;\\n    } catch (e) {\\n      console.warn('[factory] history:messages error', e?.message || e);\\n      // Return empty feature log structure to satisfy UI expectations\\n      return { [DEFAULT_FEATURE_KEY]: { startDate: nowIso(), featureId: DEFAULT_FEATURE_KEY, messages: [] } };\\n    }\\n  });\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_HISTORY_DELETE, (_evt, { runId }) => {\\n    try {\\n      if (HISTORY && typeof HISTORY.deleteRun === 'function') {\\n        HISTORY.deleteRun(runId);\\n        return { ok: true };\\n      }\\n      console.warn('[factory] HISTORY.deleteRun not available');\\n      return { ok: false };\\n    } catch (e) {\\n      console.warn('[factory] history:delete error', e?.message || e);\\n      return { ok: false, error: e?.message || String(e) };\\n    }\\n  });\\n\\n  // Pricing handlers\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_PRICING_GET, () => {\\n    try {\\n      const state = PRICING?.listPrices();\\n      return state || { updatedAt: nowIso(), prices: [] };\\n    } catch (e) {\\n      return { updatedAt: nowIso(), prices: [] };\\n    }\\n  });\\n\\n  ipcMain.handle(IPC_HANDLER_KEYS.FACTORY_PRICING_REFRESH, async (_evt, { provider, url }) => {\\n    try {\\n      const state = await PRICING?.refresh(provider, url);\\n      return state || { updatedAt: nowIso(), prices: [] };\\n    } catch (e) {\\n      return { updatedAt: nowIso(), prices: [] };\\n    }\\n  });\\n\\n  // Log window lifecycle for context\\n  if (mainWindow && mainWindow.webContents) {\\n    mainWindow.webContents.on('destroyed', () => console.log('[factory] Main window destroyed'));\\n  }\\n  return factory\\n}\\n\"}\n\nBegin now.",
    "featureId": "86314974-b368-49d5-8137-4b5b0d053adb",
    "agentType": "developer",
    "turn": 0,
    "source": "initial",
    "createdAt": "2025-09-06T23:29:08.708Z"
  },
  {
    "role": "assistant",
    "content": "{\n  \"thoughts\": \"The failure when starting a run for a second project while one is already ongoing is likely due to shared, mutable state in orchestrator.ts: runOrchestrator mutates taskTools.setProjectRoot and fileTools.setProjectRoot globally for the process. Concurrent runs then race and overwrite each other’s project roots, causing one run to fail immediately. The fix is to avoid mutating shared tool state and instead create run-scoped tool instances that are bound to a specific project root. I will modify packages/factory-ts/src/orchestrator.ts to create scoped wrappers for taskTools and fileTools that forward calls without touching the global project root. This should allow concurrent runs across different projects to operate independently.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"search_files\",\n      \"arguments\": {\n        \"query\": \"TaskUtils FileTools setProjectRoot\",\n        \"path\": \".\"\n      }\n    }\n  ]\n}",
    "featureId": "86314974-b368-49d5-8137-4b5b0d053adb",
    "agentType": "developer",
    "turn": 0,
    "createdAt": "2025-09-06T23:29:08.708Z"
  },
  {
    "role": "user",
    "content": "[{\"name\":\"search_files\",\"result\":[\".factory/history/runs/task_1d8nb33q_mf5vyyh8.messages.json\",\".factory/history/runs/task_31t7beqj_mf62wgt6.messages.json\",\".factory/history/runs/task_5gy6omvl_mf7i2ciw.messages.json\",\".factory/history/runs/task_7uzhi517_mf8vhxcl.messages.json\",\".factory/history/runs/task_9ujdo52r_mf7wlxqj.messages.json\",\".factory/history/runs/task_c1gnwubw_mf5wuag3.messages.json\",\".factory/history/runs/task_hrs3cx5j_mf60yquv.messages.json\",\".factory/history/runs/task_hylaw8a6_mf7i2j5r.messages.json\",\".factory/history/runs/task_tstc9kee_mf60n4p6.messages.json\",\".factory/history/runs/task_u1gbvefb_mf8uuiqf.messages.json\",\".factory/history/runs/task_y727hadg_mf60nckf.messages.json\",\"packages/factory-ts/src/chatTools.ts\",\"packages/factory-ts/src/fileTools.ts\",\"packages/factory-ts/src/index.ts\",\"packages/factory-ts/src/orchestrator.ts\",\"packages/factory-ts/src/taskUtils.ts\",\"packages/factory-ts/tasks/89257920-d018-41bf-892a-583569d11d53/task.json\",\"packages/factory-ts/tasks/e334cc68-fb9b-45cf-9440-bb13b39f832d/task.json\",\"tasks/f67e8921-b197-40c9-9154-e95db8f27deb/task.json\",\"tasks/ffc07e5a-e89d-4094-958a-90f9e5a4d67d/task.json\"]}]",
    "featureId": "86314974-b368-49d5-8137-4b5b0d053adb",
    "agentType": "developer",
    "turn": 0,
    "source": "tools",
    "createdAt": "2025-09-06T23:29:08.708Z"
  },
  {
    "role": "assistant",
    "content": "{\n  \"thoughts\": \"I need to inspect fileTools.ts and taskUtils.ts to see how project root is handled and confirm whether setProjectRoot mutates shared state, causing cross-project runs to collide. Then, I can modify orchestrator.ts to avoid global mutation and create run-scoped tool wrappers bound to the specific projectDir.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"read_files\",\n      \"arguments\": {\n        \"paths\": [\n          \"packages/factory-ts/src/fileTools.ts\",\n          \"packages/factory-ts/src/taskUtils.ts\",\n          \"packages/factory-ts/src/index.ts\"\n        ]\n      }\n    }\n  ]\n}",
    "featureId": "86314974-b368-49d5-8137-4b5b0d053adb",
    "agentType": "developer",
    "turn": 1,
    "createdAt": "2025-09-06T23:29:08.708Z"
  },
  {
    "role": "user",
    "content": "[{\"name\":\"read_files\",\"result\":\"{\\\"packages/factory-ts/src/fileTools.ts\\\":\\\"import fs from 'node:fs';\\\\nimport fsp from 'node:fs/promises';\\\\nimport path from 'node:path';\\\\n\\\\nlet PROJECT_ROOT = path.resolve(process.cwd());\\\\n\\\\nfunction setProjectRoot(p: string) { PROJECT_ROOT = path.resolve(p); }\\\\nfunction getProjectRoot() { return PROJECT_ROOT; }\\\\n\\\\nasync function ensureDir(p: string) { await fsp.mkdir(p, { recursive: true }); }\\\\n\\\\nfunction isWithinRoot(abs: string) {\\\\n  const root = getProjectRoot();\\\\n  const normRoot = path.resolve(root) + path.sep;\\\\n  const normAbs = path.resolve(abs) + path.sep;\\\\n  return normAbs.startsWith(normRoot) || path.resolve(abs) === path.resolve(root);\\\\n}\\\\n\\\\nasync function readFiles(pathsRel: string[]): Promise<string> {\\\\n  const result: Record<string, any> = {};\\\\n  for (const rel of pathsRel) {\\\\n    try {\\\\n      const abs = path.resolve(getProjectRoot(), rel);\\\\n      if (!isWithinRoot(abs)) { result[rel] = 'SECURITY ERROR: Cannot access path outside project directory.\\\\\\\\n'; continue; }\\\\n      const st = await fsp.stat(abs).catch(() => null);\\\\n      if (!st) { result[rel] = 'Path not found or is not a regular file/directory.'; continue; }\\\\n      if (st.isDirectory()) {\\\\n        const entries = await fsp.readdir(abs);\\\\n        result[rel] = entries;\\\\n      } else if (st.isFile()) {\\\\n        result[rel] = await fsp.readFile(abs, 'utf8');\\\\n      } else {\\\\n        result[rel] = 'Path not found or is not a regular file/directory.';\\\\n      }\\\\n    } catch (e) {\\\\n      result[rel] = String(e);\\\\n    }\\\\n  }\\\\n  return JSON.stringify(result, null, 0);\\\\n}\\\\n\\\\nasync function listFiles(relPath: string): Promise<string[]> {\\\\n  try {\\\\n    const abs = path.resolve(getProjectRoot(), relPath);\\\\n    if (!isWithinRoot(abs)) return [];\\\\n    const st = await fsp.stat(abs).catch(() => null);\\\\n    if (!st || !st.isDirectory()) return [];\\\\n    const entries = await fsp.readdir(abs);\\\\n    return entries;\\\\n  } catch {\\\\n    return [];\\\\n  }\\\\n}\\\\n\\\\nasync function writeFile(relPath: string, content: string) {\\\\n  const abs = path.resolve(getProjectRoot(), relPath);\\\\n  if (!isWithinRoot(abs)) throw new Error(`Security violation: Attempt to write outside of project root: ${relPath}`);\\\\n  await ensureDir(path.dirname(abs));\\\\n  await fsp.writeFile(abs, content, 'utf8');\\\\n  return `File securely written to: ${relPath}`;\\\\n}\\\\n\\\\nasync function renameFile(srcRel: string, dstRel: string) {\\\\n  const src = path.resolve(getProjectRoot(), srcRel);\\\\n  const dst = path.resolve(getProjectRoot(), dstRel);\\\\n  if (!isWithinRoot(src)) throw new Error(`Security violation: Attempt to read outside of project root: ${srcRel}`);\\\\n  if (!isWithinRoot(dst)) throw new Error(`Security violation: Attempt to write outside of project root: ${dstRel}`);\\\\n  await ensureDir(path.dirname(dst));\\\\n  await fsp.rename(src, dst);\\\\n  return `File ${srcRel} securely renamed to: ${dstRel}`;\\\\n}\\\\n\\\\nasync function deleteFile(relPath: string) {\\\\n  const abs = path.resolve(getProjectRoot(), relPath);\\\\n  if (!isWithinRoot(abs)) throw new Error(`Security violation: Attempt to delete outside of project root: ${relPath}`);\\\\n  const st = await fsp.stat(abs).catch(() => null);\\\\n  if (!st) return `File not found: ${relPath}`;\\\\n  if (st.isDirectory()) {\\\\n    await fsp.rmdir(abs);\\\\n  } else {\\\\n    await fsp.unlink(abs).catch(() => {});\\\\n  }\\\\n  return `File securely deleted: ${relPath}`;\\\\n}\\\\n\\\\nasync function searchFiles(query: string, relPath = '.'): Promise<string[]> {\\\\n  if (!query) return [];\\\\n  const root = getProjectRoot();\\\\n  const start = path.resolve(root, relPath);\\\\n  if (!isWithinRoot(start)) return [];\\\\n\\\\n  const ignore = new Set(['.git', 'node_modules', '.venv', 'venv', 'dist', 'build', 'out', '.next', '.cache']);\\\\n  const maxBytes = 2 * 1024 * 1024;\\\\n  const queries = query.toLowerCase().split(\\\\\\\" \\\\\\\");\\\\n  const matches: string[] = [];\\\\n  const seen = new Set<string>();\\\\n\\\\n  const walk = async (dir: string) => {\\\\n    let entries: fs.Dirent[];\\\\n    try {\\\\n      entries = await fsp.readdir(dir, { withFileTypes: true });\\\\n    } catch { return; }\\\\n    for (const ent of entries) {\\\\n      const full = path.join(dir, ent.name);\\\\n      const rel = path.relative(root, full);\\\\n      if (!isWithinRoot(full)) continue;\\\\n      if (ent.isDirectory()) {\\\\n        if (ignore.has(ent.name)) continue;\\\\n        await walk(full);\\\\n      } else if (ent.isFile()) {\\\\n        let added = false;\\\\n        for(const q of queries){\\\\n          if (ent.name.toLowerCase().includes(q)) {\\\\n            if (!seen.has(rel)) { matches.push(rel); seen.add(rel); }\\\\n            added = true;\\\\n            break\\\\n          }\\\\n          if (!added) {\\\\n            try {\\\\n              const st = await fsp.stat(full);\\\\n              if (st.size <= maxBytes) {\\\\n                const data = await fsp.readFile(full);\\\\n                const text = data.toString('utf8');\\\\n                if (text.toLowerCase().includes(q)) {\\\\n                  if (!seen.has(rel)) { matches.push(rel); seen.add(rel); }\\\\n                }\\\\n              }\\\\n            } catch {}\\\\n          }\\\\n        }\\\\n        if (matches.length >= 500) return; // cap results\\\\n      }\\\\n    }\\\\n  };\\\\n\\\\n  await walk(start);\\\\n  return matches;\\\\n}\\\\n\\\\n\\\\nexport const fileTools = {\\\\n  setProjectRoot,\\\\n  \\\\n  readFiles,\\\\n  listFiles,\\\\n  writeFile,\\\\n  renameFile,\\\\n  deleteFile,\\\\n  searchFiles, \\\\n};\\\\n\\\\nexport type FileTools = typeof fileTools;\\\\n\\\",\\\"packages/factory-ts/src/taskUtils.ts\\\":\\\"import fs from 'node:fs';\\\\nimport fsp from 'node:fs/promises';\\\\nimport path from 'node:path';\\\\n\\\\nimport type { Status, Feature, Task } from './types.js';\\\\nimport type { GitManager } from './gitManager.js';\\\\n\\\\n// Stable framework root (monorepo/app root) captured at module load.\\\\n// This should never be mutated by per-run operations.\\\\nconst FRAMEWORK_ROOT = path.resolve(process.cwd());\\\\n\\\\n// Mutable project root used for file tools operating within a specific workspace copy.\\\\nlet PROJECT_ROOT = FRAMEWORK_ROOT;\\\\nconst TASKS_DIR_NAME = 'tasks';\\\\n\\\\nfunction setProjectRoot(p: string) { PROJECT_ROOT = path.resolve(p || FRAMEWORK_ROOT); }\\\\nfunction getProjectRoot() { return PROJECT_ROOT; }\\\\n\\\\nfunction tasksDir() { return path.join(PROJECT_ROOT, TASKS_DIR_NAME); }\\\\nfunction taskDir(taskId: string) { return path.join(tasksDir(), taskId); }\\\\nfunction taskPath(taskId: string) { return path.join(taskDir(taskId), 'task.json'); }\\\\nfunction testPath(taskId: string, featureId: string) { return path.join(taskDir(taskId), 'tests', `test_${taskId}_${featureId}.py`); }\\\\n\\\\nconst PROJECTS_DIR_NAME = 'projects';\\\\n// Project configs must always be read from the stable framework root, not the mutable project root.\\\\nfunction projectsDirStable() { return path.join(FRAMEWORK_ROOT, PROJECTS_DIR_NAME); }\\\\nfunction projectPathStable(projectId: string) { return path.join(projectsDirStable(), `${projectId}.json`); }\\\\n\\\\nasync function ensureDir(p: string) { await fsp.mkdir(p, { recursive: true }); }\\\\n\\\\nasync function getProjectDir(projectId: string): Promise<string> {\\\\n  // Read the project config from the stable framework root so multiple runs do not depend on temporary workspace state.\\\\n  const p = projectPathStable(projectId);\\\\n  const raw = await fsp.readFile(p, 'utf8');\\\\n  const project = JSON.parse(raw);\\\\n  // project.path is assumed to be relative to the projects dir or the repo root; resolve from FRAMEWORK_ROOT\\\\n  return path.join(FRAMEWORK_ROOT, PROJECTS_DIR_NAME, project.path)\\\\n}\\\\n\\\\nasync function getTask(taskId: string): Promise<Task> {\\\\n  const p = taskPath(taskId);\\\\n  const raw = await fsp.readFile(p, 'utf8');\\\\n  return JSON.parse(raw);\\\\n}\\\\n\\\\nasync function saveTask(task: Task): Promise<void> {\\\\n  const p = taskPath(task.id);\\\\n  await ensureDir(path.dirname(p));\\\\n  await fsp.writeFile(p, JSON.stringify(task, null, 2), 'utf8');\\\\n}\\\\n\\\\nasync function updateTaskStatus(taskId: string, status: Status): Promise<Task> {\\\\n  const t = await getTask(taskId);\\\\n  t.status = status;\\\\n  await saveTask(t);\\\\n  return t;\\\\n}\\\\n\\\\n// File utilities (sandboxed under project root)\\\\nfunction isWithinRoot(abs: string) {\\\\n  const root = getProjectRoot();\\\\n  const normRoot = path.resolve(root) + path.sep;\\\\n  const normAbs = path.resolve(abs) + path.sep;\\\\n  return normAbs.startsWith(normRoot) || path.resolve(abs) === path.resolve(root);\\\\n}\\\\n\\\\nasync function readFiles(pathsRel: string[]): Promise<string> {\\\\n  const result: Record<string, any> = {};\\\\n  for (const rel of pathsRel) {\\\\n    try {\\\\n      const abs = path.resolve(getProjectRoot(), rel);\\\\n      if (!isWithinRoot(abs)) { result[rel] = 'SECURITY ERROR: Cannot access path outside project directory.\\\\\\\\n'; continue; }\\\\n      const st = await fsp.stat(abs).catch(() => null);\\\\n      if (!st) { result[rel] = 'Path not found or is not a regular file/directory.'; continue; }\\\\n      if (st.isDirectory()) {\\\\n        const entries = await fsp.readdir(abs);\\\\n        result[rel] = entries;\\\\n      } else if (st.isFile()) {\\\\n        result[rel] = await fsp.readFile(abs, 'utf8');\\\\n      } else {\\\\n        result[rel] = 'Path not found or is not a regular file/directory.';\\\\n      }\\\\n    } catch (e) {\\\\n      result[rel] = String(e);\\\\n    }\\\\n  }\\\\n  return JSON.stringify(result, null, 0);\\\\n}\\\\nasync function updateFeatureStatus(taskId: string, featureId: string, status: Status) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  if (feature) {\\\\n    feature.status = status;\\\\n    await saveTask(t);\\\\n    return feature;\\\\n  }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function blockFeature(taskId: string, featureId: string, reason: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  if (feature) {\\\\n    feature.status = '?';\\\\n    feature.rejection = `Blocked: ${reason}`;\\\\n    await saveTask(t);\\\\n  }\\\\n  const title = feature?.title ?? '';\\\\n  let msg: string;\\\\n  if (agentType === 'developer') msg = `BLOCKED feat: Complete feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'planner') msg = `BLOCKED plan: Add plan for feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'tester') msg = `BLOCKED test: Add tests for feature ${featureId} - ${title}`;\\\\n  else if (agentType === 'contexter') msg = `BLOCKED context: Set context for feature ${featureId} - ${title}`;\\\\n  else throw new Error(`Unknown agent_type '${agentType}' called block_feature.`);\\\\n\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n\\\\n  console.log(`Feature ${featureId} blocked. Reason: ${reason}`);\\\\n  return feature;\\\\n}\\\\n\\\\nasync function blockTask(taskId: string, reason: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  t.status = '?';\\\\n  t.rejection = `Blocked: ${reason}`;\\\\n  await saveTask(t);\\\\n  const msg = `BLOCKED task: ${t.id} - ${t.title}`;\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  console.log(`Task ${taskId} blocked. Reason: ${reason}`);\\\\n  return t;\\\\n}\\\\n\\\\nasync function checkAndUpdateTaskCompletion(taskId: string) {\\\\n  const t = await getTask(taskId);\\\\n  const allDone = (t.features || []).every(f => f.status === '+');\\\\n  if (allDone) {\\\\n    console.log(`All features for task ${taskId} are complete. Updating task status to '+'.`);\\\\n    await updateTaskStatus(taskId, '+');\\\\n  }\\\\n}\\\\n\\\\nasync function finishFeature(taskId: string, featureId: string, agentType: string, git: GitManager) {\\\\n  const t = await getTask(taskId);\\\\n  const feature = t.features.find(f => f.id === featureId);\\\\n  const title = feature?.title ?? '';\\\\n  let msg: string;\\\\n  if (agentType === 'developer') {\\\\n    msg = `feat: Complete feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '+');\\\\n    await checkAndUpdateTaskCompletion(taskId);\\\\n  } else if (agentType === 'planner') {\\\\n    msg = `plan: Add plan for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else if (agentType === 'tester') {\\\\n    msg = `test: Add tests for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else if (agentType === 'contexter') {\\\\n    msg = `context: Set context for feature ${featureId} - ${title}`;\\\\n    await updateFeatureStatus(taskId, featureId, '-');\\\\n  } else {\\\\n    throw new Error(`Unknown agent_type '${agentType}' called finish_feature.`);\\\\n  }\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  return `Feature ${featureId} finished by ${agentType} and changes committed.`;\\\\n}\\\\n\\\\nasync function finishSpec(taskId: string, agentType: string, git: GitManager) {\\\\n  if (agentType !== 'speccer') throw new Error(`Unknown agent_type '${agentType}' called finish_spec.`);\\\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\\\n  const msg = `spec: Added spec for task: ${taskId}`;\\\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\\\n  return `Task ${taskId} finished spec by ${agentType} and changes committed.`;\\\\n}\\\\n\\\\n// Tester tools\\\\nasync function getTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  try { return await fsp.readFile(p, 'utf8'); } catch { return `Test file not found at ${p}`; }\\\\n}\\\\n\\\\nasync function updateAcceptanceCriteria(taskId: string, featureId: string, criteria: string[]) {\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.acceptance = criteria; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function updateTest(taskId: string, featureId: string, test: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  await ensureDir(path.dirname(p));\\\\n  await fsp.writeFile(p, test, 'utf8');\\\\n  return `Test file updated at ${p}`;\\\\n}\\\\n\\\\nasync function deleteTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  try { await fsp.unlink(p); return `Test file ${p} deleted.`; } catch { return `Test file ${p} not found.`; }\\\\n}\\\\n\\\\nasync function runTest(taskId: string, featureId: string) {\\\\n  const p = testPath(taskId, featureId);\\\\n  if (!fs.existsSync(p)) return 'FAIL: Test file not found.';\\\\n  const { spawn } = await import('node:child_process');\\\\n  return await new Promise<string>((resolve) => {\\\\n    const proc = spawn('python3', [p], { stdio: ['ignore', 'pipe', 'pipe'] });\\\\n    let stdout = '';\\\\n    let stderr = '';\\\\n    const timer = setTimeout(() => { try { proc.kill('SIGKILL'); } catch {} }, 30000);\\\\n    proc.stdout.on('data', (d) => { stdout += d.toString(); });\\\\n    proc.stderr.on('data', (d) => { stderr += d.toString(); });\\\\n    proc.on('close', (code) => {\\\\n      clearTimeout(timer);\\\\n      if (code === 0) resolve(`PASS: Test executed successfully.\\\\\\\\nOutput:\\\\\\\\n${stdout}`);\\\\n      else resolve(`FAIL: Test failed with exit code ${code}.\\\\\\\\nStderr:\\\\\\\\n${stderr}\\\\\\\\nStdout:\\\\\\\\n${stdout}`);\\\\n    });\\\\n    proc.on('error', (e) => {\\\\n      clearTimeout(timer);\\\\n      resolve(`FAIL: An unexpected error occurred while running the test: ${e}`);\\\\n    });\\\\n  });\\\\n}\\\\n\\\\n// Orchestrator helpers\\\\nfunction findNextAvailableFeature(task: Task, excludeIds: Set<string> = new Set(), ignoreDependencies = false): Feature | undefined {\\\\n  const features = (task.features || []).slice();\\\\n  if (features.length === 0) return undefined;\\\\n\\\\n  // Create an index mapping using featureIdToDisplayIndex; fallback to array order\\\\n  const displayIndex: Record<string, number> = {};\\\\n  const map = (task as any).featureIdToDisplayIndex as Record<string, number> | undefined;\\\\n  for (let i = 0; i < features.length; i++) {\\\\n    const f = features[i];\\\\n    const idx = map?.[f.id];\\\\n    displayIndex[f.id] = typeof idx === 'number' ? idx : (i + 1); // 1-based fallback\\\\n  }\\\\n\\\\n  // Sort features by display index ascending\\\\n  features.sort((a, b) => {\\\\n    const ai = displayIndex[a.id] ?? Number.MAX_SAFE_INTEGER;\\\\n    const bi = displayIndex[b.id] ?? Number.MAX_SAFE_INTEGER;\\\\n    if (ai !== bi) return ai - bi;\\\\n    // Stable fallback using original array order if indexes equal/missing\\\\n    return 0;\\\\n  });\\\\n\\\\n  const completed = new Set(features.filter(f => f.status === '+').map(f => f.id));\\\\n  for (const f of features) {\\\\n    if (excludeIds.has(f.id)) continue;\\\\n    if (f.status === '-') {\\\\n      const deps = f.blockers || [];\\\\n      if (ignoreDependencies || deps.every(d => completed.has(d))) return f;\\\\n    }\\\\n  }\\\\n  return undefined;\\\\n}\\\\n\\\\nfunction uuidv4() {\\\\n  // Simple UUID v4 generator for local use\\\\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\\\\n    const r = Math.random() * 16 | 0;\\\\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\\\\n    return v.toString(16);\\\\n  });\\\\n}\\\\n\\\\nasync function createFeature(taskId: string, title: string, description: string): Promise<Feature> {\\\\n  const t = await getTask(taskId);\\\\n  const id = uuidv4();\\\\n  const newFeature: Feature = {\\\\n    id,\\\\n    status: '-',\\\\n    title,\\\\n    description,\\\\n    plan: '',\\\\n    context: [],\\\\n    acceptance: [],\\\\n  };\\\\n  t.features = t.features || [];\\\\n  t.features.push(newFeature);\\\\n  t.featureIdToDisplayIndex = t.featureIdToDisplayIndex || {};\\\\n  t.featureIdToDisplayIndex[id] = t.features.length;\\\\n  await saveTask(t);\\\\n  console.log(`New feature '${id}' created in task ${taskId}.`);\\\\n  return newFeature;\\\\n}\\\\n\\\\nasync function updateFeaturePlan(taskId: string, featureId: string, plan: any) {\\\\n  const planStr = Array.isArray(plan) ? plan.map(String).join('\\\\\\\\n') : (typeof plan === 'string' ? plan : String(plan));\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.plan = planStr; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nasync function updateFeatureContext(taskId: string, featureId: string, context: string[]) {\\\\n  const t = await getTask(taskId);\\\\n  const f = t.features.find(x => x.id === featureId);\\\\n  if (f) { f.context = context; await saveTask(t); return f; }\\\\n  return undefined;\\\\n}\\\\n\\\\nexport const taskUtils = {\\\\n  // project\\\\n  setProjectRoot,\\\\n  // task io\\\\n  getTask,\\\\n  saveTask,\\\\n  updateTaskStatus,\\\\n  // feature status\\\\n  updateFeatureStatus,\\\\n  blockFeature,\\\\n  blockTask,\\\\n  finishFeature,\\\\n  finishSpec,\\\\n  // tester tools\\\\n  getTest,\\\\n  updateAcceptanceCriteria,\\\\n  updateTest,\\\\n  deleteTest,\\\\n  runTest,\\\\n  // orchestrator helpers\\\\n  getProjectDir,\\\\n  findNextAvailableFeature,\\\\n  createFeature,\\\\n  updateFeaturePlan,\\\\n  updateFeatureContext,\\\\n};\\\\n\\\\nexport type TaskUtils = typeof taskUtils;\\\\n\\\",\\\"packages/factory-ts/src/index.ts\\\":\\\"import path from 'node:path';\\\\nimport fs from 'node:fs';\\\\nimport { EventEmitter } from 'node:events';\\\\nimport { taskUtils as defaultTaskUtils } from './taskUtils.js';\\\\nimport { fileTools as defaultFileTools } from './fileTools.js';\\\\nimport GitManager from './gitManager.js';\\\\nimport { runIsolatedOrchestrator } from './orchestrator.js';\\\\nimport { createCompletionClient, type CompletionClient } from './completion.js';\\\\nimport { setFactoryDebug, setLoggerConfig, getLoggerConfig, logger } from './logger.js';\\\\nimport { createPricingManager, PricingManager, estimateCostUSD } from './pricing.js';\\\\nimport { LLMConfig, RunEvent, AgentRun } from './types.js';\\\\nexport { buildChatTools } from './chatTools.js';\\\\n\\\\nexport type Unsubscribe = () => void;\\\\n\\\\nexport interface RunHandle {\\\\n  id: string;\\\\n  onEvent(cb: (e: RunEvent) => void): Unsubscribe;\\\\n  cancel(reason?: string): void;\\\\n}\\\\n\\\\nexport type RunMeta = {\\\\n  runId: string;\\\\n  projectId?: string;\\\\n  taskId?: string;\\\\n  featureId?: string;\\\\n  state: 'running' | 'completed' | 'cancelled' | 'error';\\\\n  message?: string;\\\\n  progress?: number;\\\\n  costUSD?: number;\\\\n  promptTokens?: number;\\\\n  completionTokens?: number;\\\\n  provider?: string;\\\\n  model?: string;\\\\n  startedAt?: string;\\\\n  updatedAt?: string;\\\\n};\\\\n\\\\nexport interface HistoryStore {\\\\n  addOrUpdateRun(meta: RunMeta): void;\\\\n  updateRunMeta(runId: string, patch: Partial<RunMeta>): void;\\\\n  writeMessages(runId: string, messages: any[]): void;\\\\n  listRuns(): RunMeta[];\\\\n  getRun(runId: string): RunMeta | undefined;\\\\n  getRunMessages(runId: string): any[];\\\\n  deleteRun?(runId: string): void;\\\\n}\\\\n\\\\nfunction ensureDir(p: string) {\\\\n  try { fs.mkdirSync(p, { recursive: true }); } catch {}\\\\n}\\\\n\\\\nexport function createHistoryStore(opts: { dbPath: string }): HistoryStore {\\\\n  // Use a file-backed store under <dirname(dbPath)>/history\\\\n  const baseDir = path.join(path.dirname(opts.dbPath || ''), 'history');\\\\n  const runsDir = path.join(baseDir, 'runs');\\\\n  const indexFile = path.join(baseDir, 'runs.json');\\\\n  ensureDir(runsDir);\\\\n\\\\n  function readIndex(): RunMeta[] {\\\\n    try {\\\\n      const raw = fs.readFileSync(indexFile, 'utf8');\\\\n      const arr = JSON.parse(raw);\\\\n      if (Array.isArray(arr)) return arr as RunMeta[];\\\\n      return [];\\\\n    } catch {\\\\n      return [];\\\\n    }\\\\n  }\\\\n  function writeIndex(list: RunMeta[]) {\\\\n    try { fs.writeFileSync(indexFile, JSON.stringify(list, null, 2), 'utf8'); } catch {}\\\\n  }\\\\n\\\\n  function addOrUpdateRun(meta: RunMeta) {\\\\n    const list = readIndex();\\\\n    const idx = list.findIndex(r => r.runId === meta.runId);\\\\n    const merged = { ...(idx >= 0 ? list[idx] : {}), ...meta } as RunMeta;\\\\n    if (idx >= 0) list[idx] = merged; else list.push(merged);\\\\n    // Keep sorted by updatedAt desc if present\\\\n    list.sort((a, b) => (b.updatedAt || '').localeCompare(a.updatedAt || ''));\\\\n    writeIndex(list);\\\\n  }\\\\n\\\\n  function updateRunMeta(runId: string, patch: Partial<RunMeta>) {\\\\n    const list = readIndex();\\\\n    const idx = list.findIndex(r => r.runId === runId);\\\\n    if (idx >= 0) {\\\\n      list[idx] = { ...list[idx], ...patch, runId } as RunMeta;\\\\n      list.sort((a, b) => (b.updatedAt || '').localeCompare(a.updatedAt || ''));\\\\n      writeIndex(list);\\\\n    } else {\\\\n      addOrUpdateRun({ runId, state: 'running', ...patch } as RunMeta);\\\\n    }\\\\n  }\\\\n\\\\n  function messagesFile(runId: string) { return path.join(runsDir, `${runId}.messages.json`); }\\\\n\\\\n  function writeMessages(runId: string, messages: any[]) {\\\\n    try { fs.writeFileSync(messagesFile(runId), JSON.stringify(messages ?? [], null, 2), 'utf8'); } catch {}\\\\n  }\\\\n\\\\n  function getRunMessages(runId: string): any[] {\\\\n    try {\\\\n      const raw = fs.readFileSync(messagesFile(runId), 'utf8');\\\\n      const arr = JSON.parse(raw);\\\\n      return Array.isArray(arr) ? arr : [];\\\\n    } catch {\\\\n      return [];\\\\n    }\\\\n  }\\\\n\\\\n  function listRuns(): RunMeta[] { return readIndex(); }\\\\n  function getRun(runId: string): RunMeta | undefined { return readIndex().find(r => r.runId === runId); }\\\\n\\\\n  function deleteRun(runId: string): void {\\\\n    // Remove from index\\\\n    const list = readIndex();\\\\n    const filtered = list.filter(r => r.runId !== runId);\\\\n    writeIndex(filtered);\\\\n    // Remove messages file\\\\n    try { fs.unlinkSync(messagesFile(runId)); } catch {}\\\\n  }\\\\n\\\\n  return { addOrUpdateRun, updateRunMeta, writeMessages, listRuns, getRun, getRunMessages, deleteRun } satisfies HistoryStore;\\\\n}\\\\n\\\\nfunction makeId(prefix: string) { return `${prefix}_${Math.random().toString(36).slice(2, 10)}_${Date.now().toString(36)}`; }\\\\n\\\\nfunction buildCompletion(llmConfig: LLMConfig): CompletionClient {\\\\n  // Delegate to completion.ts factory; tolerate missing fields\\\\n  return createCompletionClient(llmConfig);\\\\n}\\\\n\\\\nfunction attachLLMLogging(comp: CompletionClient, emit: (e: RunEvent) => void, opts?: { provider?: string; pricing?: PricingManager }): CompletionClient {\\\\n  // Accumulate usage across the run\\\\n  let totalPrompt = 0;\\\\n  let totalCompletion = 0;\\\\n  let totalUSD = 0;\\\\n\\\\n  // Wrap the completion client to emit llm events including request messages and timing\\\\n  const wrapped: CompletionClient = async (req) => {\\\\n    const startedAt = Date.now();\\\\n    try {\\\\n      emit({ type: 'llm/request', payload: { model: req.model, messages: req.messages } });\\\\n    } catch {}\\\\n    try {\\\\n      const res = await comp(req);\\\\n      const durationMs = Date.now() - startedAt;\\\\n      emit({ type: 'llm/response', payload: { model: req.model, message: res.message, durationMs } });\\\\n      // Usage (if provided by client)\\\\n      const u = res.usage || {};\\\\n      const pDelta = Number(u.promptTokens || 0);\\\\n      const cDelta = Number(u.completionTokens || 0);\\\\n      totalPrompt += pDelta;\\\\n      totalCompletion += cDelta;\\\\n\\\\n      // Compute/accumulate cost incrementally\\\\n      let lastCostUSD: number | undefined = undefined;\\\\n      // Prefer provider-reported cost if available\\\\n      if (u.costUSD != null && isFinite(Number(u.costUSD))) {\\\\n        lastCostUSD = Number(u.costUSD);\\\\n      } else if (opts?.pricing) {\\\\n        const price = opts.pricing.getPrice(u.provider || opts.provider, u.model || req.model);\\\\n        lastCostUSD = estimateCostUSD(pDelta, cDelta, price);\\\\n      }\\\\n      if (lastCostUSD != null) totalUSD += lastCostUSD;\\\\n\\\\n      try {\\\\n        emit({\\\\n          type: 'run/usage',\\\\n          payload: {\\\\n            provider: u.provider || opts?.provider,\\\\n            model: u.model || req.model,\\\\n            promptTokens: totalPrompt,\\\\n            completionTokens: totalCompletion,\\\\n            totalTokens: (totalPrompt + totalCompletion) || u.totalTokens,\\\\n            // Emit 0 when no price is available yet, rather than undefined\\\\n            costUSD: totalUSD,\\\\n            lastDurationMs: durationMs,\\\\n          }\\\\n        } satisfies RunEvent);\\\\n      } catch {}\\\\n      return res;\\\\n    } catch (err) {\\\\n      const durationMs = Date.now() - startedAt;\\\\n      emit({ type: 'llm/error', payload: { error: String((err as Error)?.message || err), durationMs } });\\\\n      throw err;\\\\n    }\\\\n  };\\\\n  return wrapped;\\\\n}\\\\n\\\\nexport function createOrchestrator(opts: { projectRoot?: string; history?: HistoryStore; pricing?: PricingManager }) {\\\\n  const projectRoot = path.resolve(opts.projectRoot || process.cwd());\\\\n\\\\n  // A run registry\\\\n  const runs = new Map<string, { ee: EventEmitter; cancelled: boolean; cancel: (r?: string) => void }>();\\\\n\\\\n  // Pricing manager (load/set defaults from disk on app start)\\\\n  const pricing = opts.pricing || createPricingManager({ projectRoot });\\\\n\\\\n  function newRunHandle(prefix: string): { id: string; ee: EventEmitter; handle: RunHandle; signalCancelled: () => boolean } {\\\\n    const id = makeId(prefix);\\\\n    const ee = new EventEmitter();\\\\n    let cancelled = false;\\\\n    const handle: RunHandle = {\\\\n      id,\\\\n      onEvent: (cb) => {\\\\n        const fn = (e: RunEvent) => cb(e);\\\\n        ee.on('event', fn);\\\\n        return () => { try { ee.off('event', fn); } catch {} };\\\\n      },\\\\n      cancel: (reason?: string) => {\\\\n        if (!cancelled) {\\\\n          cancelled = true;\\\\n          ee.emit('event', { type: 'run/cancelled', payload: { reason } } satisfies RunEvent);\\\\n        }\\\\n      }\\\\n    };\\\\n    runs.set(id, { ee, cancelled, cancel: handle.cancel });\\\\n    return { id, ee, handle, signalCancelled: () => cancelled };\\\\n  }\\\\n\\\\n  function getAgentFromArgs(args: { agentType?: string, agent?: any; metadata?: any }, fallback: any = 'developer') {\\\\n    return args.agentType || args.agent || args.metadata?.agent || fallback;\\\\n  }\\\\n\\\\n  function startRun(args: AgentRun): RunHandle {\\\\n    const { id, ee, handle } = newRunHandle('task');\\\\n    (async () => {\\\\n      ee.emit('event', { type: 'run/start', payload: { scope: 'task', id, taskId: args.taskId, llm: { model: args.llmConfig?.model, provider: args.llmConfig?.provider } } } satisfies RunEvent);\\\\n      try {\\\\n        const taskTools = { ...defaultTaskUtils };\\\\n        const fileTools = { ...defaultFileTools };\\\\n\\\\n        const completion = attachLLMLogging(buildCompletion(args.llmConfig), (e) => ee.emit('event', e), { provider: args.llmConfig?.provider, pricing });\\\\n        const agentType = getAgentFromArgs(args, 'developer');\\\\n\\\\n        const projectId = args.projectId\\\\n        const taskId = args.taskId;\\\\n        const featureId = args.featureId;\\\\n        await runIsolatedOrchestrator({ model: args.llmConfig.model, agentType, projectId, taskId, featureId, gitFactory: (p) => new GitManager(p), taskTools, fileTools, completion, emit: (e) => ee.emit('event', e) });\\\\n\\\\n        ee.emit('event', { type: 'run/completed', payload: { ok: true } } satisfies RunEvent);\\\\n      } catch (err) {\\\\n        ee.emit('event', { type: 'run/error', payload: { error: String((err as Error)?.stack || err) } } satisfies RunEvent);\\\\n      } finally {\\\\n        ee.emit('event', { type: 'run/complete' } satisfies RunEvent);\\\\n      }\\\\n    })();\\\\n    return handle;\\\\n  }\\\\n\\\\n  return {\\\\n    startRun,\\\\n    pricing, // expose for external IPC if needed\\\\n  };\\\\n}\\\\n\\\\nexport { setFactoryDebug, setLoggerConfig, getLoggerConfig, logger, createPricingManager };\\\\n\\\\nexport default { createOrchestrator, createHistoryStore, setFactoryDebug, setLoggerConfig, getLoggerConfig, logger, createPricingManager };\\\\n\\\"}\"}]",
    "featureId": "86314974-b368-49d5-8137-4b5b0d053adb",
    "agentType": "developer",
    "turn": 1,
    "source": "tools",
    "createdAt": "2025-09-06T23:29:08.708Z"
  },
  {
    "role": "assistant",
    "content": "{\n  \"thoughts\": \"I will implement per-run, project-root scoped tools to avoid global PROJECT_ROOT mutation collisions. I'll add createFileTools and createTaskUtils that capture a root in closure, update orchestrator.ts to avoid calling setProjectRoot and to instantiate scoped tools inside runIsolatedOrchestrator using the workspace path, and leave existing exports for backward compatibility. This should fix concurrent runs across different projects.\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"write_file\",\n      \"arguments\": {\n        \"filename\": \"packages/factory-ts/src/fileTools.ts\",\n        \"content\": \"import fs from 'node:fs';\\nimport fsp from 'node:fs/promises';\\nimport path from 'node:path';\\n\\nlet PROJECT_ROOT = path.resolve(process.cwd());\\n\\nfunction setProjectRoot(p: string) { PROJECT_ROOT = path.resolve(p); }\\nfunction getProjectRoot() { return PROJECT_ROOT; }\\n\\nasync function ensureDir(p: string) { await fsp.mkdir(p, { recursive: true }); }\\n\\nfunction isWithinRootFactory(rootGetter: () => string) {\\n  return function isWithinRoot(abs: string) {\\n    const root = rootGetter();\\n    const normRoot = path.resolve(root) + path.sep;\\n    const normAbs = path.resolve(abs) + path.sep;\\n    return normAbs.startsWith(normRoot) || path.resolve(abs) === path.resolve(root);\\n  }\\n}\\n\\nasync function readFilesImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, pathsRel: string[]): Promise<string> {\\n  const result: Record<string, any> = {};\\n  for (const rel of pathsRel) {\\n    try {\\n      const abs = path.resolve(rootGetter(), rel);\\n      if (!isWithinRoot(abs)) { result[rel] = 'SECURITY ERROR: Cannot access path outside project directory.\\\\n'; continue; }\\n      const st = await fsp.stat(abs).catch(() => null);\\n      if (!st) { result[rel] = 'Path not found or is not a regular file/directory.'; continue; }\\n      if (st.isDirectory()) {\\n        const entries = await fsp.readdir(abs);\\n        result[rel] = entries;\\n      } else if (st.isFile()) {\\n        result[rel] = await fsp.readFile(abs, 'utf8');\\n      } else {\\n        result[rel] = 'Path not found or is not a regular file/directory.';\\n      }\\n    } catch (e) {\\n      result[rel] = String(e);\\n    }\\n  }\\n  return JSON.stringify(result, null, 0);\\n}\\n\\nasync function listFilesImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, relPath: string): Promise<string[]> {\\n  try {\\n    const abs = path.resolve(rootGetter(), relPath);\\n    if (!isWithinRoot(abs)) return [];\\n    const st = await fsp.stat(abs).catch(() => null);\\n    if (!st || !st.isDirectory()) return [];\\n    const entries = await fsp.readdir(abs);\\n    return entries;\\n  } catch {\\n    return [];\\n  }\\n}\\n\\nasync function writeFileImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, relPath: string, content: string) {\\n  const abs = path.resolve(rootGetter(), relPath);\\n  if (!isWithinRoot(abs)) throw new Error(`Security violation: Attempt to write outside of project root: ${relPath}`);\\n  await ensureDir(path.dirname(abs));\\n  await fsp.writeFile(abs, content, 'utf8');\\n  return `File securely written to: ${relPath}`;\\n}\\n\\nasync function renameFileImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, srcRel: string, dstRel: string) {\\n  const src = path.resolve(rootGetter(), srcRel);\\n  const dst = path.resolve(rootGetter(), dstRel);\\n  if (!isWithinRoot(src)) throw new Error(`Security violation: Attempt to read outside of project root: ${srcRel}`);\\n  if (!isWithinRoot(dst)) throw new Error(`Security violation: Attempt to write outside of project root: ${dstRel}`);\\n  await ensureDir(path.dirname(dst));\\n  await fsp.rename(src, dst);\\n  return `File ${srcRel} securely renamed to: ${dstRel}`;\\n}\\n\\nasync function deleteFileImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, relPath: string) {\\n  const abs = path.resolve(rootGetter(), relPath);\\n  if (!isWithinRoot(abs)) throw new Error(`Security violation: Attempt to delete outside of project root: ${relPath}`);\\n  const st = await fsp.stat(abs).catch(() => null);\\n  if (!st) return `File not found: ${relPath}`;\\n  if (st.isDirectory()) {\\n    await fsp.rmdir(abs);\\n  } else {\\n    await fsp.unlink(abs).catch(() => {});\\n  }\\n  return `File securely deleted: ${relPath}`;\\n}\\n\\nasync function searchFilesImpl(rootGetter: () => string, isWithinRoot: (abs: string) => boolean, query: string, relPath = '.'): Promise<string[]> {\\n  if (!query) return [];\\n  const root = rootGetter();\\n  const start = path.resolve(root, relPath);\\n  if (!isWithinRoot(start)) return [];\\n\\n  const ignore = new Set(['.git', 'node_modules', '.venv', 'venv', 'dist', 'build', 'out', '.next', '.cache']);\\n  const maxBytes = 2 * 1024 * 1024;\\n  const queries = query.toLowerCase().split(\\\" \\\");\\n  const matches: string[] = [];\\n  const seen = new Set<string>();\\n\\n  const walk = async (dir: string) => {\\n    let entries: fs.Dirent[];\\n    try {\\n      entries = await fsp.readdir(dir, { withFileTypes: true });\\n    } catch { return; }\\n    for (const ent of entries) {\\n      const full = path.join(dir, ent.name);\\n      const rel = path.relative(root, full);\\n      if (!isWithinRoot(full)) continue;\\n      if (ent.isDirectory()) {\\n        if (ignore.has(ent.name)) continue;\\n        await walk(full);\\n      } else if (ent.isFile()) {\\n        let added = false;\\n        for(const q of queries){\\n          if (ent.name.toLowerCase().includes(q)) {\\n            if (!seen.has(rel)) { matches.push(rel); seen.add(rel); }\\n            added = true;\\n            break\\n          }\\n          if (!added) {\\n            try {\\n              const st = await fsp.stat(full);\\n              if (st.size <= maxBytes) {\\n                const data = await fsp.readFile(full);\\n                const text = data.toString('utf8');\\n                if (text.toLowerCase().includes(q)) {\\n                  if (!seen.has(rel)) { matches.push(rel); seen.add(rel); }\\n                }\\n              }\\n            } catch {}\\n          }\\n        }\\n        if (matches.length >= 500) return; // cap results\\n      }\\n    }\\n  };\\n\\n  await walk(start);\\n  return matches;\\n}\\n\\n// Default, process-global tools (backwards-compatible)\\nconst defaultIsWithinRoot = isWithinRootFactory(getProjectRoot);\\nasync function readFiles(pathsRel: string[]): Promise<string> { return readFilesImpl(getProjectRoot, defaultIsWithinRoot, pathsRel); }\\nasync function listFiles(relPath: string): Promise<string[]> { return listFilesImpl(getProjectRoot, defaultIsWithinRoot, relPath); }\\nasync function writeFile(relPath: string, content: string) { return writeFileImpl(getProjectRoot, defaultIsWithinRoot, relPath, content); }\\nasync function renameFile(srcRel: string, dstRel: string) { return renameFileImpl(getProjectRoot, defaultIsWithinRoot, srcRel, dstRel); }\\nasync function deleteFile(relPath: string) { return deleteFileImpl(getProjectRoot, defaultIsWithinRoot, relPath); }\\nasync function searchFiles(query: string, relPath = '.') { return searchFilesImpl(getProjectRoot, defaultIsWithinRoot, query, relPath); }\\n\\nexport const fileTools = {\\n  setProjectRoot,\\n  \\n  readFiles,\\n  listFiles,\\n  writeFile,\\n  renameFile,\\n  deleteFile,\\n  searchFiles, \\n};\\n\\nexport type FileTools = typeof fileTools;\\n\\n// New: create per-run, project-root scoped tools (thread-safe)\\nexport function createFileTools(projectRoot: string) {\\n  let ROOT = path.resolve(projectRoot || process.cwd());\\n  const getRoot = () => ROOT;\\n  const isWithinRoot = isWithinRootFactory(getRoot);\\n  return {\\n    setProjectRoot: (p: string) => { ROOT = path.resolve(p || ROOT); },\\n    readFiles: (pathsRel: string[]) => readFilesImpl(getRoot, isWithinRoot, pathsRel),\\n    listFiles: (relPath: string) => listFilesImpl(getRoot, isWithinRoot, relPath),\\n    writeFile: (relPath: string, content: string) => writeFileImpl(getRoot, isWithinRoot, relPath, content),\\n    renameFile: (srcRel: string, dstRel: string) => renameFileImpl(getRoot, isWithinRoot, srcRel, dstRel),\\n    deleteFile: (relPath: string) => deleteFileImpl(getRoot, isWithinRoot, relPath),\\n    searchFiles: (query: string, relPath = '.') => searchFilesImpl(getRoot, isWithinRoot, query, relPath),\\n  } as FileTools;\\n}\\n\"\n      }\n    },\n    {\n      \"tool_name\": \"write_file\",\n      \"arguments\": {\n        \"filename\": \"packages/factory-ts/src/taskUtils.ts\",\n        \"content\": \"import fs from 'node:fs';\\nimport fsp from 'node:fs/promises';\\nimport path from 'node:path';\\n\\nimport type { Status, Feature, Task } from './types.js';\\nimport type { GitManager } from './gitManager.js';\\n\\n// Stable framework root (monorepo/app root) captured at module load.\\n// This should never be mutated by per-run operations.\\nconst FRAMEWORK_ROOT = path.resolve(process.cwd());\\n\\n// Mutable project root used for file tools operating within a specific workspace copy.\\nlet PROJECT_ROOT = FRAMEWORK_ROOT;\\nconst TASKS_DIR_NAME = 'tasks';\\n\\nfunction setProjectRoot(p: string) { PROJECT_ROOT = path.resolve(p || FRAMEWORK_ROOT); }\\nfunction getProjectRoot() { return PROJECT_ROOT; }\\n\\nfunction tasksDir() { return path.join(PROJECT_ROOT, TASKS_DIR_NAME); }\\nfunction taskDir(taskId: string) { return path.join(tasksDir(), taskId); }\\nfunction taskPath(taskId: string) { return path.join(taskDir(taskId), 'task.json'); }\\nfunction testPath(taskId: string, featureId: string) { return path.join(taskDir(taskId), 'tests', `test_${taskId}_${featureId}.py`); }\\n\\nconst PROJECTS_DIR_NAME = 'projects';\\n// Project configs must always be read from the stable framework root, not the mutable project root.\\nfunction projectsDirStable() { return path.join(FRAMEWORK_ROOT, PROJECTS_DIR_NAME); }\\nfunction projectPathStable(projectId: string) { return path.join(projectsDirStable(), `${projectId}.json`); }\\n\\nasync function ensureDir(p: string) { await fsp.mkdir(p, { recursive: true }); }\\n\\nasync function getProjectDir(projectId: string): Promise<string> {\\n  // Read the project config from the stable framework root so multiple runs do not depend on temporary workspace state.\\n  const p = projectPathStable(projectId);\\n  const raw = await fsp.readFile(p, 'utf8');\\n  const project = JSON.parse(raw);\\n  // project.path is assumed to be relative to the projects dir or the repo root; resolve from FRAMEWORK_ROOT\\n  return path.join(FRAMEWORK_ROOT, PROJECTS_DIR_NAME, project.path)\\n}\\n\\nasync function getTask(taskId: string): Promise<Task> {\\n  const p = taskPath(taskId);\\n  const raw = await fsp.readFile(p, 'utf8');\\n  return JSON.parse(raw);\\n}\\n\\nasync function saveTask(task: Task): Promise<void> {\\n  const p = taskPath(task.id);\\n  await ensureDir(path.dirname(p));\\n  await fsp.writeFile(p, JSON.stringify(task, null, 2), 'utf8');\\n}\\n\\nasync function updateTaskStatus(taskId: string, status: Status): Promise<Task> {\\n  const t = await getTask(taskId);\\n  t.status = status;\\n  await saveTask(t);\\n  return t;\\n}\\n\\n// File utilities (sandboxed under project root)\\nfunction isWithinRoot(abs: string) {\\n  const root = getProjectRoot();\\n  const normRoot = path.resolve(root) + path.sep;\\n  const normAbs = path.resolve(abs) + path.sep;\\n  return normAbs.startsWith(normRoot) || path.resolve(abs) === path.resolve(root);\\n}\\n\\nasync function readFiles(pathsRel: string[]): Promise<string> {\\n  const result: Record<string, any> = {};\\n  for (const rel of pathsRel) {\\n    try {\\n      const abs = path.resolve(getProjectRoot(), rel);\\n      if (!isWithinRoot(abs)) { result[rel] = 'SECURITY ERROR: Cannot access path outside project directory.\\\\n'; continue; }\\n      const st = await fsp.stat(abs).catch(() => null);\\n      if (!st) { result[rel] = 'Path not found or is not a regular file/directory.'; continue; }\\n      if (st.isDirectory()) {\\n        const entries = await fsp.readdir(abs);\\n        result[rel] = entries;\\n      } else if (st.isFile()) {\\n        result[rel] = await fsp.readFile(abs, 'utf8');\\n      } else {\\n        result[rel] = 'Path not found or is not a regular file/directory.';\\n      }\\n    } catch (e) {\\n      result[rel] = String(e);\\n    }\\n  }\\n  return JSON.stringify(result, null, 0);\\n}\\nasync function updateFeatureStatus(taskId: string, featureId: string, status: Status) {\\n  const t = await getTask(taskId);\\n  const feature = t.features.find(f => f.id === featureId);\\n  if (feature) {\\n    feature.status = status;\\n    await saveTask(t);\\n    return feature;\\n  }\\n  return undefined;\\n}\\n\\nasync function blockFeature(taskId: string, featureId: string, reason: string, agentType: string, git: GitManager) {\\n  const t = await getTask(taskId);\\n  const feature = t.features.find(f => f.id === featureId);\\n  if (feature) {\\n    feature.status = '?';\\n    feature.rejection = `Blocked: ${reason}`;\\n    await saveTask(t);\\n  }\\n  const title = feature?.title ?? '';\\n  let msg: string;\\n  if (agentType === 'developer') msg = `BLOCKED feat: Complete feature ${featureId} - ${title}`;\\n  else if (agentType === 'planner') msg = `BLOCKED plan: Add plan for feature ${featureId} - ${title}`;\\n  else if (agentType === 'tester') msg = `BLOCKED test: Add tests for feature ${featureId} - ${title}`;\\n  else if (agentType === 'contexter') msg = `BLOCKED context: Set context for feature ${featureId} - ${title}`;\\n  else throw new Error(`Unknown agent_type '${agentType}' called block_feature.`);\\n\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\n\\n  console.log(`Feature ${featureId} blocked. Reason: ${reason}`);\\n  return feature;\\n}\\n\\nasync function blockTask(taskId: string, reason: string, agentType: string, git: GitManager) {\\n  const t = await getTask(taskId);\\n  t.status = '?';\\n  t.rejection = `Blocked: ${reason}`;\\n  await saveTask(t);\\n  const msg = `BLOCKED task: ${t.id} - ${t.title}`;\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\n  console.log(`Task ${taskId} blocked. Reason: ${reason}`);\\n  return t;\\n}\\n\\nasync function checkAndUpdateTaskCompletion(taskId: string) {\\n  const t = await getTask(taskId);\\n  const allDone = (t.features || []).every(f => f.status === '+');\\n  if (allDone) {\\n    console.log(`All features for task ${taskId} are complete. Updating task status to '+'.`);\\n    await updateTaskStatus(taskId, '+');\\n  }\\n}\\n\\nasync function finishFeature(taskId: string, featureId: string, agentType: string, git: GitManager) {\\n  const t = await getTask(taskId);\\n  const feature = t.features.find(f => f.id === featureId);\\n  const title = feature?.title ?? '';\\n  let msg: string;\\n  if (agentType === 'developer') {\\n    msg = `feat: Complete feature ${featureId} - ${title}`;\\n    await updateFeatureStatus(taskId, featureId, '+');\\n    await checkAndUpdateTaskCompletion(taskId);\\n  } else if (agentType === 'planner') {\\n    msg = `plan: Add plan for feature ${featureId} - ${title}`;\\n    await updateFeatureStatus(taskId, featureId, '-');\\n  } else if (agentType === 'tester') {\\n    msg = `test: Add tests for feature ${featureId} - ${title}`;\\n    await updateFeatureStatus(taskId, featureId, '-');\\n  } else if (agentType === 'contexter') {\\n    msg = `context: Set context for feature ${featureId} - ${title}`;\\n    await updateFeatureStatus(taskId, featureId, '-');\\n  } else {\\n    throw new Error(`Unknown agent_type '${agentType}' called finish_feature.`);\\n  }\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\n  return `Feature ${featureId} finished by ${agentType} and changes committed.`;\\n}\\n\\nasync function finishSpec(taskId: string, agentType: string, git: GitManager) {\\n  if (agentType !== 'speccer') throw new Error(`Unknown agent_type '${agentType}' called finish_spec.`);\\n  try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\n  const msg = `spec: Added spec for task: ${taskId}`;\\n  try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\n  try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\n  return `Task ${taskId} finished spec by ${agentType} and changes committed.`;\\n}\\n\\n// Tester tools\\nasync function getTest(taskId: string, featureId: string) {\\n  const p = testPath(taskId, featureId);\\n  try { return await fsp.readFile(p, 'utf8'); } catch { return `Test file not found at ${p}`; }\\n}\\n\\nasync function updateAcceptanceCriteria(taskId: string, featureId: string, criteria: string[]) {\\n  const t = await getTask(taskId);\\n  const f = t.features.find(x => x.id === featureId);\\n  if (f) { f.acceptance = criteria; await saveTask(t); return f; }\\n  return undefined;\\n}\\n\\nasync function updateTest(taskId: string, featureId: string, test: string) {\\n  const p = testPath(taskId, featureId);\\n  await ensureDir(path.dirname(p));\\n  await fsp.writeFile(p, test, 'utf8');\\n  return `Test file updated at ${p}`;\\n}\\n\\nasync function deleteTest(taskId: string, featureId: string) {\\n  const p = testPath(taskId, featureId);\\n  try { await fsp.unlink(p); return `Test file ${p} deleted.`; } catch { return `Test file ${p} not found.`; }\\n}\\n\\nasync function runTest(taskId: string, featureId: string) {\\n  const p = testPath(taskId, featureId);\\n  if (!fs.existsSync(p)) return 'FAIL: Test file not found.';\\n  const { spawn } = await import('node:child_process');\\n  return await new Promise<string>((resolve) => {\\n    const proc = spawn('python3', [p], { stdio: ['ignore', 'pipe', 'pipe'] });\\n    let stdout = '';\\n    let stderr = '';\\n    const timer = setTimeout(() => { try { proc.kill('SIGKILL'); } catch {} }, 30000);\\n    proc.stdout.on('data', (d) => { stdout += d.toString(); });\\n    proc.stderr.on('data', (d) => { stderr += d.toString(); });\\n    proc.on('close', (code) => {\\n      clearTimeout(timer);\\n      if (code === 0) resolve(`PASS: Test executed successfully.\\\\nOutput:\\\\n${stdout}`);\\n      else resolve(`FAIL: Test failed with exit code ${code}.\\\\nStderr:\\\\n${stderr}\\\\nStdout:\\\\n${stdout}`);\\n    });\\n    proc.on('error', (e) => {\\n      clearTimeout(timer);\\n      resolve(`FAIL: An unexpected error occurred while running the test: ${e}`);\\n    });\\n  });\\n}\\n\\n// Orchestrator helpers\\nfunction findNextAvailableFeature(task: Task, excludeIds: Set<string> = new Set(), ignoreDependencies = false): Feature | undefined {\\n  const features = (task.features || []).slice();\\n  if (features.length === 0) return undefined;\\n\\n  // Create an index mapping using featureIdToDisplayIndex; fallback to array order\\n  const displayIndex: Record<string, number> = {};\\n  const map = (task as any).featureIdToDisplayIndex as Record<string, number> | undefined;\\n  for (let i = 0; i < features.length; i++) {\\n    const f = features[i];\\n    const idx = map?.[f.id];\\n    displayIndex[f.id] = typeof idx === 'number' ? idx : (i + 1); // 1-based fallback\\n  }\\n\\n  // Sort features by display index ascending\\n  features.sort((a, b) => {\\n    const ai = displayIndex[a.id] ?? Number.MAX_SAFE_INTEGER;\\n    const bi = displayIndex[b.id] ?? Number.MAX_SAFE_INTEGER;\\n    if (ai !== bi) return ai - bi;\\n    // Stable fallback using original array order if indexes equal/missing\\n    return 0;\\n  });\\n\\n  const completed = new Set(features.filter(f => f.status === '+').map(f => f.id));\\n  for (const f of features) {\\n    if (excludeIds.has(f.id)) continue;\\n    if (f.status === '-') {\\n      const deps = f.blockers || [];\\n      if (ignoreDependencies || deps.every(d => completed.has(d))) return f;\\n    }\\n  }\\n  return undefined;\\n}\\n\\nfunction uuidv4() {\\n  // Simple UUID v4 generator for local use\\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\\n    const r = Math.random() * 16 | 0;\\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\\n    return v.toString(16);\\n  });\\n}\\n\\nasync function createFeature(taskId: string, title: string, description: string): Promise<Feature> {\\n  const t = await getTask(taskId);\\n  const id = uuidv4();\\n  const newFeature: Feature = {\\n    id,\\n    status: '-',\\n    title,\\n    description,\\n    plan: '',\\n    context: [],\\n    acceptance: [],\\n  };\\n  t.features = t.features || [];\\n  t.features.push(newFeature);\\n  t.featureIdToDisplayIndex = t.featureIdToDisplayIndex || {};\\n  t.featureIdToDisplayIndex[id] = t.features.length;\\n  await saveTask(t);\\n  console.log(`New feature '${id}' created in task ${taskId}.`);\\n  return newFeature;\\n}\\n\\nasync function updateFeaturePlan(taskId: string, featureId: string, plan: any) {\\n  const planStr = Array.isArray(plan) ? plan.map(String).join('\\\\n') : (typeof plan === 'string' ? plan : String(plan));\\n  const t = await getTask(taskId);\\n  const f = t.features.find(x => x.id === featureId);\\n  if (f) { f.plan = planStr; await saveTask(t); return f; }\\n  return undefined;\\n}\\n\\nasync function updateFeatureContext(taskId: string, featureId: string, context: string[]) {\\n  const t = await getTask(taskId);\\n  const f = t.features.find(x => x.id === featureId);\\n  if (f) { f.context = context; await saveTask(t); return f; }\\n  return undefined;\\n}\\n\\nexport const taskUtils = {\\n  // project\\n  setProjectRoot,\\n  // task io\\n  getTask,\\n  saveTask,\\n  updateTaskStatus,\\n  // feature status\\n  updateFeatureStatus,\\n  blockFeature,\\n  blockTask,\\n  finishFeature,\\n  finishSpec,\\n  // tester tools\\n  getTest,\\n  updateAcceptanceCriteria,\\n  updateTest,\\n  deleteTest,\\n  runTest,\\n  // orchestrator helpers\\n  getProjectDir,\\n  findNextAvailableFeature,\\n  createFeature,\\n  updateFeaturePlan,\\n  updateFeatureContext,\\n};\\n\\nexport type TaskUtils = typeof taskUtils;\\n\\n// New: create per-run, project-root scoped task utils (thread-safe)\\nexport function createTaskUtils(projectRoot: string) {\\n  // Instance-local project root\\n  let ROOT = path.resolve(projectRoot || FRAMEWORK_ROOT);\\n  const tasksDirLocal = () => path.join(ROOT, TASKS_DIR_NAME);\\n  const taskDirLocal = (taskId: string) => path.join(tasksDirLocal(), taskId);\\n  const taskPathLocal = (taskId: string) => path.join(taskDirLocal(taskId), 'task.json');\\n  const testPathLocal = (taskId: string, featureId: string) => path.join(taskDirLocal(taskId), 'tests', `test_${taskId}_${featureId}.py`);\\n\\n  async function getTaskLocal(taskId: string): Promise<Task> {\\n    const p = taskPathLocal(taskId);\\n    const raw = await fsp.readFile(p, 'utf8');\\n    return JSON.parse(raw);\\n  }\\n  async function saveTaskLocal(task: Task): Promise<void> {\\n    const p = taskPathLocal(task.id);\\n    await ensureDir(path.dirname(p));\\n    await fsp.writeFile(p, JSON.stringify(task, null, 2), 'utf8');\\n  }\\n  async function updateTaskStatusLocal(taskId: string, status: Status): Promise<Task> {\\n    const t = await getTaskLocal(taskId);\\n    t.status = status;\\n    await saveTaskLocal(t);\\n    return t;\\n  }\\n  async function updateFeatureStatusLocal(taskId: string, featureId: string, status: Status) {\\n    const t = await getTaskLocal(taskId);\\n    const feature = t.features.find(f => f.id === featureId);\\n    if (feature) {\\n      feature.status = status;\\n      await saveTaskLocal(t);\\n      return feature;\\n    }\\n    return undefined;\\n  }\\n  async function blockFeatureLocal(taskId: string, featureId: string, reason: string, agentType: string, git: GitManager) {\\n    const t = await getTaskLocal(taskId);\\n    const feature = t.features.find(f => f.id === featureId);\\n    if (feature) {\\n      feature.status = '?';\\n      feature.rejection = `Blocked: ${reason}`;\\n      await saveTaskLocal(t);\\n    }\\n    const title = feature?.title ?? '';\\n    let msg: string;\\n    if (agentType === 'developer') msg = `BLOCKED feat: Complete feature ${featureId} - ${title}`;\\n    else if (agentType === 'planner') msg = `BLOCKED plan: Add plan for feature ${featureId} - ${title}`;\\n    else if (agentType === 'tester') msg = `BLOCKED test: Add tests for feature ${featureId} - ${title}`;\\n    else if (agentType === 'contexter') msg = `BLOCKED context: Set context for feature ${featureId} - ${title}`;\\n    else throw new Error(`Unknown agent_type '${agentType}' called block_feature.`);\\n\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\n\\n    console.log(`Feature ${featureId} blocked. Reason: ${reason}`);\\n    return feature;\\n  }\\n  async function blockTaskLocal(taskId: string, reason: string, agentType: string, git: GitManager) {\\n    const t = await getTaskLocal(taskId);\\n    t.status = '?';\\n    t.rejection = `Blocked: ${reason}`;\\n    await saveTaskLocal(t);\\n    const msg = `BLOCKED task: ${t.id} - ${t.title}`;\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\n    console.log(`Task ${taskId} blocked. Reason: ${reason}`);\\n    return t;\\n  }\\n  async function checkAndUpdateTaskCompletionLocal(taskId: string) {\\n    const t = await getTaskLocal(taskId);\\n    const allDone = (t.features || []).every(f => f.status === '+');\\n    if (allDone) {\\n      console.log(`All features for task ${taskId} are complete. Updating task status to '+'.`);\\n      await updateTaskStatusLocal(taskId, '+');\\n    }\\n  }\\n  async function finishFeatureLocal(taskId: string, featureId: string, agentType: string, git: GitManager) {\\n    const t = await getTaskLocal(taskId);\\n    const feature = t.features.find(f => f.id === featureId);\\n    const title = feature?.title ?? '';\\n    let msg: string;\\n    if (agentType === 'developer') {\\n      msg = `feat: Complete feature ${featureId} - ${title}`;\\n      await updateFeatureStatusLocal(taskId, featureId, '+');\\n      await checkAndUpdateTaskCompletionLocal(taskId);\\n    } else if (agentType === 'planner') {\\n      msg = `plan: Add plan for feature ${featureId} - ${title}`;\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\n    } else if (agentType === 'tester') {\\n      msg = `test: Add tests for feature ${featureId} - ${title}`;\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\n    } else if (agentType === 'contexter') {\\n      msg = `context: Set context for feature ${featureId} - ${title}`;\\n      await updateFeatureStatusLocal(taskId, featureId, '-');\\n    } else {\\n      throw new Error(`Unknown agent_type '${agentType}' called finish_feature.`);\\n    }\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\n    return `Feature ${featureId} finished by ${agentType} and changes committed.`;\\n  }\\n  async function finishSpecLocal(taskId: string, agentType: string, git: GitManager) {\\n    if (agentType !== 'speccer') throw new Error(`Unknown agent_type '${agentType}' called finish_spec.`);\\n    try { await git.stageAll() } catch (e) { console.warn('Warning: Could not stage files.', e); }\\n    const msg = `spec: Added spec for task: ${taskId}`;\\n    try { await git.commit(msg); console.log(`Committed changes with message: '${msg}'`); } catch (e) { console.warn('Warning: Git commit failed.', e); }\\n    try { await git.push(); } catch (e) { console.warn('Could not push:', e); }\\n    return `Task ${taskId} finished spec by ${agentType} and changes committed.`;\\n  }\\n  async function getTestLocal(taskId: string, featureId: string) {\\n    const p = testPathLocal(taskId, featureId);\\n    try { return await fsp.readFile(p, 'utf8'); } catch { return `Test file not found at ${p}`; }\\n  }\\n  async function updateTestLocal(taskId: string, featureId: string, test: string) {\\n    const p = testPathLocal(taskId, featureId);\\n    await ensureDir(path.dirname(p));\\n    await fsp.writeFile(p, test, 'utf8');\\n    return `Test file updated at ${p}`;\\n  }\\n  async function deleteTestLocal(taskId: string, featureId: string) {\\n    const p = testPathLocal(taskId, featureId);\\n    try { await fsp.unlink(p); return `Test file ${p} deleted.`; } catch { return `Test file ${p} not found.`; }\\n  }\\n  async function runTestLocal(taskId: string, featureId: string) {\\n    const p = testPathLocal(taskId, featureId);\\n    if (!fs.existsSync(p)) return 'FAIL: Test file not found.';\\n    const { spawn } = await import('node:child_process');\\n    return await new Promise<string>((resolve) => {\\n      const proc = spawn('python3', [p], { stdio: ['ignore', 'pipe', 'pipe'] });\\n      let stdout = '';\\n      let stderr = '';\\n      const timer = setTimeout(() => { try { proc.kill('SIGKILL'); } catch {} }, 30000);\\n      proc.stdout.on('data', (d) => { stdout += d.toString(); });\\n      proc.stderr.on('data', (d) => { stderr += d.toString(); });\\n      proc.on('close', (code) => {\\n        clearTimeout(timer);\\n        if (code === 0) resolve(`PASS: Test executed successfully.\\\\nOutput:\\\\n${stdout}`);\\n        else resolve(`FAIL: Test failed with exit code ${code}.\\\\nStderr:\\\\n${stderr}\\\\nStdout:\\\\n${stdout}`);\\n      });\\n      proc.on('error', (e) => {\\n        clearTimeout(timer);\\n        resolve(`FAIL: An unexpected error occurred while running the test: ${e}`);\\n      });\\n    });\\n  }\\n  async function createFeatureLocal(taskId: string, title: string, description: string): Promise<Feature> {\\n    const t = await getTaskLocal(taskId);\\n    const id = (function uuidv4() {return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {const r = Math.random() * 16 | 0;const v = c === 'x' ? r : (r & 0x3 | 0x8);return v.toString(16);}); })();\\n    const newFeature: Feature = { id, status: '-', title, description, plan: '', context: [], acceptance: [], };\\n    t.features = t.features || [];\\n    t.features.push(newFeature);\\n    t.featureIdToDisplayIndex = t.featureIdToDisplayIndex || {};\\n    t.featureIdToDisplayIndex[id] = t.features.length;\\n    await saveTaskLocal(t);\\n    console.log(`New feature '${id}' created in task ${taskId}.`);\\n    return newFeature;\\n  }\\n  async function updateFeaturePlanLocal(taskId: string, featureId: string, plan: any) {\\n    const planStr = Array.isArray(plan) ? plan.map(String).join('\\\\n') : (typeof plan === 'string' ? plan : String(plan));\\n    const t = await getTaskLocal(taskId);\\n    const f = t.features.find(x => x.id === featureId);\\n    if (f) { f.plan = planStr; await saveTaskLocal(t); return f; }\\n    return undefined;\\n  }\\n  async function updateFeatureContextLocal(taskId: string, featureId: string, context: string[]) {\\n    const t = await getTaskLocal(taskId);\\n    const f = t.features.find(x => x.id === featureId);\\n    if (f) { f.context = context; await saveTaskLocal(t); return f; }\\n    return undefined;\\n  }\\n\\n  return {\\n    // instance project root mutator (instance-scoped)\\n    setProjectRoot: (p: string) => { ROOT = path.resolve(p || ROOT); },\\n    // task io\\n    getTask: getTaskLocal,\\n    saveTask: saveTaskLocal,\\n    updateTaskStatus: updateTaskStatusLocal,\\n    // feature status\\n    updateFeatureStatus: updateFeatureStatusLocal,\\n    blockFeature: blockFeatureLocal,\\n    blockTask: blockTaskLocal,\\n    finishFeature: finishFeatureLocal,\\n    finishSpec: finishSpecLocal,\\n    // tester tools\\n    getTest: getTestLocal,\\n    updateAcceptanceCriteria,\\n    updateTest: updateTestLocal,\\n    deleteTest: deleteTestLocal,\\n    runTest: runTestLocal,\\n    // orchestrator helpers\\n    getProjectDir, // always from FRAMEWORK_ROOT (shared, safe)\\n    findNextAvailableFeature,\\n    createFeature: createFeatureLocal,\\n    updateFeaturePlan: updateFeaturePlanLocal,\\n    updateFeatureContext: updateFeatureContextLocal,\\n  } as TaskUtils;\\n}\\n\"\n      }\n    },\n    {\n      \"tool_name\": \"read_files\",\n      \"arguments\": {\n        \"paths\": [\n          \"packages/factory-ts/src/orchestrator.ts\"\n        ]\n      }\n    }\n  ]\n}",
    "featureId": "86314974-b368-49d5-8137-4b5b0d053adb",
    "agentType": "developer",
    "turn": 2,
    "createdAt": "2025-09-06T23:29:08.708Z"
  },
  {
    "role": "user",
    "content": "[{\"name\":\"write_file\",\"result\":\"File securely written to: packages/factory-ts/src/fileTools.ts\"},{\"name\":\"write_file\",\"result\":\"File securely written to: packages/factory-ts/src/taskUtils.ts\"},{\"name\":\"read_files\",\"result\":\"{\\\"packages/factory-ts/src/orchestrator.ts\\\":\\\"import fs from 'node:fs';\\\\nimport fsp from 'node:fs/promises';\\\\nimport path from 'node:path';\\\\nimport os from 'node:os';\\\\nimport { AgentResponse, CompletionClient, CompletionMessage, Feature, Task, ToolCall, ToolResult } from './types.js';\\\\nimport type { TaskUtils } from './taskUtils.js';\\\\nimport type { FileTools } from './fileTools.js';\\\\nimport type { GitManager } from './gitManager.js';\\\\nimport { logger, logLLMStep } from './logger.js';\\\\n\\\\nconst MAX_TURNS_PER_FEATURE = 100;\\\\n\\\\n// Prefer process.cwd(), but do not assume it points to a real filesystem root when packaged (asar)\\\\nconst FRAMEWORK_ROOT = path.resolve(process.cwd());\\\\nconst NEWLINE = '\\\\\\\\n';\\\\n\\\\nfunction loadAgentDocs(agent: string): string {\\\\n  // Mirror Python: docs live under packages/factory-ts/docs\\\\n  const p = path.join(FRAMEWORK_ROOT, 'packages', 'factory-ts', 'docs', `AGENT_${agent.toUpperCase()}.md`);\\\\n  return fs.readFileSync(p, 'utf8');\\\\n}\\\\n\\\\nfunction loadProtocolExample(): string {\\\\n  try {\\\\n    const p = path.join(FRAMEWORK_ROOT, 'packages', 'factory-ts', 'docs', 'agent_response_example.json');\\\\n    const data = JSON.parse(fs.readFileSync(p, 'utf8'));\\\\n    return JSON.stringify(data, null, 2);\\\\n  } catch (e) {\\\\n    return '{\\\\\\\\n\\\\\\\"thoughts\\\\\\\":\\\\\\\"Your reasoning here...\\\\\\\",\\\\\\\\n\\\\\\\"tool_calls\\\\\\\":[ ... ]\\\\\\\\n}';\\\\n  }\\\\n}\\\\n\\\\nconst PROTOCOL_INSTRUCTIONS = (() => {\\\\n  const example = loadProtocolExample();\\\\n  return [\\\\n    'You **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:',\\\\n    '```json',\\\\n    example,\\\\n    '```',\\\\n    'The thoughts field is for your reasoning, and tool_calls is a list of actions to execute.',\\\\n    'Your response will be parsed as JSON. Do not include any text outside of this JSON object.',\\\\n    'As responses to the tool calls you will send, you will also receive JSON objects in the form:',\\\\n    '```json',\\\\n    '{\\\\\\\\n\\\\\\\"name\\\\\\\":\\\\\\\"tool_name\\\\\\\",\\\\\\\\n\\\\\\\"result\\\\\\\":\\\\\\\"...\\\\\\\"\\\\\\\\n}',\\\\n    '```',\\\\n  ].join('\\\\\\\\n');\\\\n})();\\\\n\\\\n// Human-readable descriptions for tools to avoid duplicating them in agent docs\\\\nconst TOOL_DESCRIPTIONS: Record<string, string> = {\\\\n  // Base tools\\\\n  read_files: 'Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).',\\\\n  search_files: 'Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords',\\\\n  list_files: 'List files and directories at a relative path from the project root.',\\\\n  finish_feature: 'Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.',\\\\n  block_feature: 'Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).',\\\\n\\\\n  // Speccer\\\\n  create_feature: 'Define and add a new, atomic feature to the task. Include a concise title and a clear description.',\\\\n  finish_spec: 'Signal that the feature specification is complete for the current task.',\\\\n  block_task: 'Stop work on the task and report why you are blocked at the task level.',\\\\n\\\\n  // Developer\\\\n  write_file: 'Create or overwrite a file with the given content. Always use this to write code or docs.',\\\\n  rename_file: 'Rename or move a file from one path to another.',\\\\n  delete_file: 'Delete a file. Use with caution and only when necessary.',\\\\n  run_test: 'Run the test for the current feature and return the output. Use to verify implementation.',\\\\n\\\\n  // Planner\\\\n  update_feature_plan: 'Save a concise, step-by-step implementation plan for the assigned feature.',\\\\n\\\\n  // Tester\\\\n  update_acceptance_criteria: 'Save a clear, verifiable list of acceptance criteria for the assigned feature.',\\\\n  update_test: 'Save the Python test script that validates the acceptance criteria for this feature.',\\\\n\\\\n  // Contexter\\\\n  update_feature_context: 'Save the minimal set of file paths (relative to repo root) required to implement the feature.'\\\\n};\\\\n\\\\nfunction toolSigsForAgent(agent: string, taskTools: TaskUtils, fileTools: FileTools, git: GitManager): [Record<string, (args: any) => Promise<any> | any>, string[]] {\\\\n  const base: Record<string, [(args: any) => Promise<any> | any, string]> = {\\\\n    read_files: [ (args: { paths: string[] }) => fileTools.readFiles(args.paths), \\\\\\\"read_files(paths: list[str]) -> list[str]\\\\\\\" ],\\\\n    search_files: [ (args: { query: string; path?: string }) => fileTools.searchFiles(args.query, args.path ?? '.'), \\\\\\\"search_files(query: str, path: str = '.') -> list[str]\\\\\\\" ],\\\\n    block_feature: [ (args: { task_id: string; feature_id: string; reason: string }) => taskTools.blockFeature?.(args.task_id, args.feature_id, args.reason, agent, git), 'block_feature(reason: str)' ],\\\\n    finish_feature: [ (args: { task_id: string; feature_id: string }) => taskTools.finishFeature?.(args.task_id, args.feature_id, agent, git), 'finish_feature()' ],\\\\n    list_files: [ (args: { path: string }) => fileTools.listFiles(args.path), 'list_files(path: str)' ],\\\\n  };\\\\n\\\\n  const agentTools: Record<string, [(args: any) => Promise<any> | any, string]> = {};\\\\n\\\\n  if (agent === 'speccer') {\\\\n    agentTools.create_feature = [ (args: { task_id: string; title: string; description: string }) => taskTools.createFeature?.(args.task_id, args.title, args.description), 'create_feature(title: str, description: str)' ];\\\\n    agentTools.finish_spec = [ (args: { task_id: string }) => taskTools.finishSpec?.(args.task_id, agent, git), 'finish_spec()' ];\\\\n    agentTools.block_task = [ (args: { task_id: string; reason: string }) => taskTools.blockTask?.(args.task_id, args.reason, agent, git), 'block_task()' ];\\\\n  } else if (agent === 'developer') {\\\\n    agentTools.write_file = [ (args: { filename: string; content: string }) => fileTools.writeFile(args.filename, args.content), 'write_file(filename: str, content: str)' ];\\\\n    agentTools.rename_file = [ (args: { filename: string; new_filename: string }) => fileTools.renameFile(args.filename, args.new_filename), 'rename_file(filename: str, new_filename: str)' ];\\\\n    agentTools.delete_file = [ (args: { filename: string }) => fileTools.deleteFile(args.filename), 'delete_file(filename: str)' ];\\\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => taskTools.runTest?.(args.task_id, args.feature_id), 'run_test() -> str' ];\\\\n  } else if (agent === 'planner') {\\\\n    agentTools.update_feature_plan = [ (args: { task_id: string; feature_id: string; plan: any }) => taskTools.updateFeaturePlan?.(args.task_id, args.feature_id, args.plan), 'update_feature_plan(plan: str)' ];\\\\n  } else if (agent === 'tester') {\\\\n    agentTools.update_acceptance_criteria = [ (args: { task_id: string; feature_id: string; criteria: string[] }) => taskTools.updateAcceptanceCriteria?.(args.task_id, args.feature_id, args.criteria), 'update_acceptance_criteria(criteria: list[str])' ];\\\\n    agentTools.update_test = [ (args: { task_id: string; feature_id: string; test: string }) => taskTools.updateTest?.(args.task_id, args.feature_id, args.test), 'update_test(test: str)' ];\\\\n    agentTools.run_test = [ (args: { task_id: string; feature_id: string }) => taskTools.runTest?.(args.task_id, args.feature_id), 'run_test() -> str' ];\\\\n  } else if (agent === 'contexter') {\\\\n    agentTools.update_feature_context = [ (args: { task_id: string; feature_id: string; context: string[] }) => taskTools.updateFeatureContext?.(args.task_id, args.feature_id, args.context), 'update_feature_context(context: list[str])' ];\\\\n  }\\\\n\\\\n  const merged = { ...base, ...agentTools };\\\\n  const funcs: Record<string, (args: any) => Promise<any> | any> = {};\\\\n  const sigs: string[] = [];\\\\n  for (const [name, [fn, sig]] of Object.entries(merged)) {\\\\n    if (fn) {\\\\n      funcs[name] = fn;\\\\n      const desc = TOOL_DESCRIPTIONS[name] ? ` - ${TOOL_DESCRIPTIONS[name]}` : '';\\\\n      sigs.push(`${sig}${desc}`);\\\\n    }\\\\n  }\\\\n  return [funcs, sigs];\\\\n}\\\\n\\\\nfunction constructSystemPrompt(agent: string, task: Task, feature: Feature | null, agentSystemPrompt: string, context: string, toolSignatures: string[]): string {\\\\n  const plan = feature && (agent === 'developer' || agent === 'tester' || agent === 'contexter' || agent === 'planner') ? feature.plan : undefined;\\\\n  const acceptance = feature && (agent === 'developer' || agent === 'tester') ? feature.acceptance : undefined\\\\n  const acceptanceStr = acceptance?.map((c, i) => `${i + 1}. ${c}`).join('\\\\\\\\n');\\\\n  const toolSignaturesStr = toolSignatures.map(sig => `- ${sig}`).join('\\\\\\\\n');\\\\n\\\\n  const featureBlock = feature ? `#ASSIGNED FEATURE: ${feature.title} (ID: ${feature.id})${NEWLINE}##DESCRIPTION: ${feature.description}${NEWLINE}` : '';\\\\n  const featureRejection = feature?.rejection ? `##REJECTION REASON:${NEWLINE}${feature.rejection}${NEWLINE}` : '';\\\\n  const taskRejection = task.rejection ? `##REJECTION REASON:${NEWLINE}${task.rejection}` : '';\\\\n\\\\n  return [\\\\n    agentSystemPrompt,\\\\n    `#CURRENT TASK (ID: ${task.id})`,\\\\n    '##TITLE:',\\\\n    task.title,\\\\n    '##DESCRIPTION:',\\\\n    task.description,\\\\n    taskRejection,\\\\n    '',\\\\n    featureBlock,\\\\n    featureRejection,\\\\n    plan ? '#THE PLAN' + plan : '',\\\\n    '',\\\\n    acceptanceStr ? '#ACCEPTANCE CRITERIA:' + acceptanceStr : '',\\\\n    '',\\\\n    '#TOOL SIGNATURES:',\\\\n    `${toolSignaturesStr}`,\\\\n    '',\\\\n    '#RESPONSE FORMAT INSTRUCTIONS:',\\\\n    PROTOCOL_INSTRUCTIONS,\\\\n    '',\\\\n    '#CONTEXT FILES PROVIDED:',\\\\n    context,\\\\n    '',\\\\n    'Begin now.'\\\\n  ].join('\\\\\\\\n');\\\\n}\\\\n\\\\n// Attach metadata to messages so history can be reconstructed reliably after persistence\\\\nfunction annotateMessage<T extends CompletionMessage>(msg: T, meta: { featureId?: string; agentType?: string; turn?: number; source?: string; marker?: string }): T {\\\\n  const anyMsg = msg as any;\\\\n  if (meta.featureId) anyMsg.featureId = meta.featureId;\\\\n  if (meta.agentType) anyMsg.agentType = meta.agentType;\\\\n  if (typeof meta.turn === 'number') anyMsg.turn = meta.turn;\\\\n  if (meta.source) anyMsg.source = meta.source;\\\\n  if (meta.marker) anyMsg.marker = meta.marker;\\\\n  anyMsg.createdAt = new Date().toISOString();\\\\n  return msg;\\\\n}\\\\n\\\\nasync function runConversation(opts: {\\\\n  model: string;\\\\n  availableTools: Record<string, (args: any) => Promise<any> | any>;\\\\n  systemPrompt: string;\\\\n  task: Task;\\\\n  feature: Feature | null;\\\\n  agentType: string;\\\\n  taskTools: TaskUtils;\\\\n  git: GitManager;\\\\n  completion: CompletionClient;\\\\n  complete: (why: 'finish' | 'block' | 'max_turns', info?: any) => void;\\\\n  emit?: (e: { type: string; payload?: any }) => void; // event sink for logging/stats\\\\n}) {\\\\n  const { model, availableTools, systemPrompt, task, feature, agentType, taskTools, git, completion, complete, emit } = opts;\\\\n  const doEmit = (e: { type: string; payload?: any }) => { try { emit?.(e); } catch {} };\\\\n\\\\n  const initialUser: CompletionMessage = annotateMessage(\\\\n    { role: 'user', content: systemPrompt } as any,\\\\n    { featureId: feature?.id ?? '__task__', agentType, turn: 0, source: 'initial' }\\\\n  );\\\\n  const messages: CompletionMessage[] = [initialUser];\\\\n  doEmit({ type: 'llm/messages/init', payload: { messages: messages.slice(), turn: 0 } });\\\\n\\\\n  for (let i = 0; i < MAX_TURNS_PER_FEATURE; i++) {\\\\n    try {\\\\n      // Emit snapshot of request context before calling the LLM\\\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), turn: i } });\\\\n      const startedAt = Date.now();\\\\n      const res = await completion({ model, messages, response_format: { type: 'json_object' } });\\\\n      const durationMs = Date.now() - startedAt;\\\\n\\\\n      const assistant = annotateMessage(\\\\n        { role: 'assistant' as const, content: res.message.content },\\\\n        { featureId: feature?.id ?? '__task__', agentType, turn: i }\\\\n      );\\\\n      messages.push(assistant);\\\\n      // Emit assistant message and timing\\\\n      doEmit({ type: 'llm/message', payload: { message: assistant, durationMs } });\\\\n\\\\n      // Parse and log succinct info\\\\n      let parsed: AgentResponse | undefined;\\\\n      try { parsed = JSON.parse((assistant as any).content) as AgentResponse; } catch {}\\\\n      const toolCalls: ToolCall[] = parsed?.tool_calls ?? [];\\\\n      logLLMStep({ turn: i, thoughts: parsed?.thoughts, toolCalls, durationMs, tag: agentType });\\\\n\\\\n      if (!toolCalls.length) {\\\\n        // No tool calls; continue loop.\\\\n        doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), turn: i, note: 'no_tool_calls' } });\\\\n        doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} complete` } });\\\\n        continue;\\\\n      }\\\\n\\\\n      const toolOutputs: ToolResult[] = [];\\\\n\\\\n      for (const call of toolCalls) {\\\\n        const toolName = (call.tool_name || call.tool || call.name || 'unknown_tool');\\\\n        const args = (call.arguments || call.parameters || {}) as Record<string, any>;\\\\n\\\\n        if (availableTools[toolName]) {\\\\n          if (!('task_id' in args)) args.task_id = task.id;\\\\n          if (feature && !('feature_id' in args)) args.feature_id = feature.id;\\\\n          const result = await Promise.resolve(availableTools[toolName](args));\\\\n          toolOutputs.push({ name: toolName, result });\\\\n        } else {\\\\n          toolOutputs.push({ name: toolName, result: `Error: Tool '${toolName}' not found.` });\\\\n        }\\\\n\\\\n        // Termination tools mirror Python; do not append a tool result turn, final message is assistant\\\\n        if (['finish_feature', 'block_feature', 'finish_spec', 'block_task'].includes(toolName)) {\\\\n          doEmit({ type: 'llm/messages/final', payload: { messages: messages.slice(), tool: toolName } });\\\\n          complete(toolName === 'block_feature' || toolName === 'block_task' ? 'block' : 'finish');\\\\n          return;\\\\n        }\\\\n      }\\\\n\\\\n      // Append tool results as a dedicated 'tool' role message to avoid confusing with user turns\\\\n      const toolResultMsg: CompletionMessage = annotateMessage(\\\\n        { role: 'user', content: JSON.stringify(toolOutputs) } as any,\\\\n        { featureId: feature?.id ?? '__task__', agentType, turn: i, source: 'tools' }\\\\n      );\\\\n      messages.push(toolResultMsg);\\\\n      doEmit({ type: 'llm/message', payload: { message: toolResultMsg, turn: i, source: 'tools' } });\\\\n      doEmit({ type: 'llm/messages/snapshot', payload: { messages: messages.slice(), turn: i, note: 'tools_appended' } });\\\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: Math.min(0.99, (i + 1) / MAX_TURNS_PER_FEATURE), message: `Turn ${i} tool calls processed` } });\\\\n    } catch (e) {\\\\n      if (feature) {\\\\n        await taskTools.blockFeature?.(task.id, feature.id, `Agent loop failed: ${e}`, agentType, git);\\\\n      } else {\\\\n        await taskTools.blockTask?.(task.id, `Agent loop failed: ${e}`, agentType, git);\\\\n      }\\\\n      doEmit({ type: 'llm/messages/error', payload: { error: String(e), messages: messages.slice() } });\\\\n      doEmit({ type: 'run/progress/snapshot', payload: { progress: undefined, message: 'Error encountered' } });\\\\n      logger.error('Agent loop error:', e as any);\\\\n      complete('block', e);\\\\n      return;\\\\n    }\\\\n  }\\\\n\\\\n  // Max turns reached -> block\\\\n  if (feature) {\\\\n    await taskTools.blockFeature?.(task.id, feature.id, 'Agent loop exceeded max turns', agentType, git);\\\\n  } else {\\\\n    await taskTools.blockTask?.(task.id, 'Agent loop exceeded max turns', agentType, git);\\\\n  }\\\\n  doEmit({ type: 'llm/messages/final', payload: { messages: [{ role: 'system', content: systemPrompt }] as CompletionMessage[], reason: 'max_turns' } });\\\\n  doEmit({ type: 'run/progress/snapshot', payload: { progress: 1, message: 'Max turns reached' } });\\\\n  logger.warn('Max turns reached without completion.');\\\\n  complete('max_turns');\\\\n}\\\\n\\\\nasync function runAgentOnTask(model: string, agentType: string, task: Task, taskTools: TaskUtils, fileTools: FileTools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\\\n  logger.debug(`\\\\\\\\n--- Activating Agent ${agentType} for task: [${task.id}] ${task.title} ---`);\\\\n  const agentDocs = loadAgentDocs(agentType);\\\\n  const contextFiles = ['docs/FILE_ORGANISATION.md'];\\\\n  const [funcs, sigs] = toolSigsForAgent(agentType, taskTools, fileTools, git);\\\\n  const context = await Promise.resolve(fileTools.readFiles(contextFiles));\\\\n  const systemPrompt = constructSystemPrompt(agentType, task, null, agentDocs, context, sigs);\\\\n\\\\n  await runConversation({\\\\n    model,\\\\n    availableTools: funcs,\\\\n    systemPrompt,\\\\n    task,\\\\n    feature: null,\\\\n    agentType,\\\\n    taskTools,\\\\n    git,\\\\n    completion,\\\\n    complete: () => {},\\\\n    emit,\\\\n  });\\\\n}\\\\n\\\\nasync function runAgentOnFeature(model: string, agentType: string, task: Task, feature: Feature, taskTools: TaskUtils, fileTools: FileTools, git: GitManager, completion: CompletionClient, emit?: (e: { type: string; payload?: any }) => void) {\\\\n  logger.debug(`\\\\\\\\n--- Activating Agent ${agentType} for Feature: [${feature.id}] ${feature.title} ---`);\\\\n\\\\n  if (agentType === 'developer') await taskTools.updateFeatureStatus?.(task.id, feature.id, '~');\\\\n\\\\n  const agentDocs = loadAgentDocs(agentType);\\\\n  const featureContextFiles = ['docs/FILE_ORGANISATION.md', ...(feature.context ?? [])];\\\\n  const [funcs, sigs] = toolSigsForAgent(agentType, taskTools, fileTools, git);\\\\n  const context = await Promise.resolve(fileTools.readFiles(featureContextFiles));\\\\n  const systemPrompt = constructSystemPrompt(agentType, task, feature, agentDocs, context, sigs);\\\\n\\\\n  if (agentType === 'developer') await taskTools.updateFeatureStatus?.(task.id, feature.id, '~');\\\\n\\\\n  await runConversation({\\\\n    model,\\\\n    availableTools: funcs,\\\\n    systemPrompt,\\\\n    task,\\\\n    feature,\\\\n    agentType,\\\\n    taskTools,\\\\n    git,\\\\n    completion,\\\\n    complete: () => {},\\\\n    emit,\\\\n  });\\\\n}\\\\n\\\\nasync function runOrchestrator(opts: {\\\\n  model: string;\\\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\\\n  taskId: string; \\\\n  featureId?: string; \\\\n  projectDir?: string;\\\\n  taskTools: TaskUtils;\\\\n  fileTools: FileTools;\\\\n  git: GitManager;\\\\n  completion: CompletionClient;\\\\n  emit?: (e: { type: string; payload?: any }) => void;\\\\n}) {\\\\n  const { model, agentType, taskId, projectDir, taskTools, fileTools, git, completion, emit } = opts;\\\\n\\\\n  if (projectDir) taskTools.setProjectRoot(projectDir);\\\\n  if (projectDir) fileTools.setProjectRoot(projectDir);\\\\n\\\\n  const currentTask: Task = await taskTools.getTask(taskId);\\\\n  if (!currentTask) {\\\\n    logger.warn('No available tasks to work on in the repository.');\\\\n    return;\\\\n  }\\\\n\\\\n  logger.debug(`Selected Task: [${currentTask.id}] ${currentTask.title}`);\\\\n\\\\n  const branch = `features/${currentTask.id}`;\\\\n  try {\\\\n    await git.checkoutBranch(branch, true);\\\\n  } catch (e) {\\\\n    logger.warn(`Could not create or checkout branch '${branch}': ${e}`);\\\\n    await git.checkoutBranch(branch, false);\\\\n  }\\\\n  try {\\\\n    await git.pull(branch);\\\\n  } catch (e) {\\\\n    logger.warn(`Could not pull branch '${branch}': ${e}`);\\\\n  }\\\\n\\\\n  const processed = new Set<string>();\\\\n\\\\n  // Aggregate all messages across features for this run\\\\n  let aggregatedMessages: CompletionMessage[] = [];\\\\n\\\\n  if (agentType === 'speccer') {\\\\n    const freshTask = await taskTools.getTask(currentTask.id);\\\\n    await runAgentOnTask(model, agentType, freshTask, taskTools, fileTools, git, completion, (e) => {\\\\n      // For task-level runs, forward events as-is and track messages when present\\\\n      if (e?.payload?.messages) {\\\\n        const msgs = e.payload.messages as CompletionMessage[];\\\\n        // Ensure metadata on messages for task-level runs\\\\n        const annotated = msgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? '__task__', agentType, turn: (m as any).turn ?? idx }));\\\\n        aggregatedMessages = annotated.slice();\\\\n        emit?.({ ...e, payload: { ...e.payload, messages: aggregatedMessages.slice() } });\\\\n      } else {\\\\n        emit?.(e);\\\\n      }\\\\n    });\\\\n    return;\\\\n  }\\\\n\\\\n  while (true) {\\\\n    const freshTask = await taskTools.getTask(currentTask.id);\\\\n    const next = taskTools.findNextAvailableFeature(freshTask, processed, agentType !== 'developer');\\\\n    if (!next) {\\\\n      logger.debug(`\\\\\\\\nNo more available features for task ${freshTask.id}.`);\\\\n      break;\\\\n    }\\\\n\\\\n    // Insert a system marker before each feature to clearly separate in UI and history\\\\n    const featureMarker: CompletionMessage = annotateMessage(\\\\n      { role: 'system', content: `--- BEGIN FEATURE ${next.id}: ${next.title} ---` } as any,\\\\n      { featureId: next.id, agentType, marker: 'feature_begin' }\\\\n    );\\\\n    aggregatedMessages.push(featureMarker);\\\\n    emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), note: 'feature_begin', featureId: next.id } });\\\\n\\\\n    // Wrap emit to merge current feature's messages with the aggregate so far\\\\n    let lastFeatureMessages: CompletionMessage[] = [];\\\\n    const baseEmit = emit;\\\\n    const wrappedEmit = (e: { type: string; payload?: any }) => {\\\\n      const t = e?.type;\\\\n      if ((t === 'llm/messages/init' || t === 'llm/messages/snapshot' || t === 'llm/messages/final') && e?.payload?.messages) {\\\\n        try {\\\\n          const featureMsgs: CompletionMessage[] = e.payload.messages || [];\\\\n          // Ensure every message is tagged with this feature id and agentType for persistence\\\\n          const ensured = featureMsgs.map((m, idx) => annotateMessage(m, { featureId: (m as any).featureId ?? next.id, agentType, turn: (m as any).turn ?? idx }));\\\\n          lastFeatureMessages = ensured.slice();\\\\n          const combined = aggregatedMessages.concat(ensured);\\\\n          const payload = { ...e.payload, messages: combined };\\\\n          baseEmit?.({ ...e, payload });\\\\n          return;\\\\n        } catch {}\\\\n      }\\\\n      baseEmit?.(e);\\\\n    };\\\\n\\\\n    await runAgentOnFeature(model, agentType, freshTask, next, taskTools, fileTools, git, completion, wrappedEmit);\\\\n\\\\n    // After the feature completes, fold its messages into the aggregate\\\\n    if (lastFeatureMessages && lastFeatureMessages.length) {\\\\n      aggregatedMessages = aggregatedMessages.concat(lastFeatureMessages);\\\\n      // Emit a snapshot to persist the full sequence after folding\\\\n      emit?.({ type: 'llm/messages/snapshot', payload: { messages: aggregatedMessages.slice(), note: 'feature_folded', featureId: next.id } });\\\\n    }\\\\n\\\\n    processed.add(next.id);\\\\n  }\\\\n\\\\n  // Emit final snapshot at end of task run with complete sequence of feature conversations\\\\n  emit?.({ type: 'llm/messages/final', payload: { messages: aggregatedMessages.slice(), note: 'task_run_complete' } });\\\\n}\\\\n\\\\n// --- Isolated Runner (mimic Python run.py) ---\\\\n\\\\nfunction shouldIgnoreCopy(relPath: string): boolean {\\\\n  // Ignore common build, cache, and IDE artifacts for TypeScript/Node/Electron projects\\\\n  // Preserve .git (do NOT ignore)\\\\n  const parts = relPath.split(path.sep);\\\\n  const name = parts[parts.length - 1] || relPath;\\\\n\\\\n  // If path is within .git, do not ignore (preserve repo history/branches)\\\\n  if (parts.includes('.git')) return false;\\\\n\\\\n  const dirIgnore = new Set([\\\\n    // Package managers and caches\\\\n    'node_modules', '.pnpm', '.pnp', '.pnp.cjs', '.pnp.js', '.npm', '.yarn', '.yarn-cache', '.yarnrc',\\\\n    // Build/output directories\\\\n    'dist', 'build', 'out', 'release', 'storybook-static',\\\\n    // Framework-specific\\\\n    '.next', 'next', '.nuxt', '.svelte-kit',\\\\n    // Bundlers and dev servers caches\\\\n    '.vite', '.rollup.cache', '.parcel-cache', '.webpack',\\\\n    // Test/coverage\\\\n    'coverage', '.nyc_output',\\\\n    // Monorepo/turbo caches\\\\n    '.turbo',\\\\n    // Generic caches\\\\n    '.cache', '.eslintcache', '.rpt2_cache', '.tscache',\\\\n    // Editors/IDE\\\\n    '.idea', '.vscode',\\\\n    // Python (from original mirror)\\\\n    'venv', '__pycache__',\\\\n    // Logs and temp\\\\n    'logs', 'tmp', 'temp'\\\\n  ]);\\\\n\\\\n  // If any path segment matches an ignored dir name\\\\n  if (parts.some(p => dirIgnore.has(p))) return true;\\\\n\\\\n  // Ignore specific file patterns\\\\n  const lower = name.toLowerCase();\\\\n  if (lower === '.ds_Store'.toLowerCase() || lower === 'thumbs.db') return true;\\\\n  if (lower.endsWith('.log')) return true; // npm/yarn/pnpm debug logs\\\\n  if (lower.endsWith('.pyc')) return true; // Python bytecode files\\\\n  if (lower.endsWith('.tsbuildinfo')) return true; // TypeScript incremental build info\\\\n\\\\n  // Ignore Electron asar content markers when encountered as path segments\\\\n  if (parts.some(p => p.endsWith('.asar') || p.endsWith('.asar.unpacked'))) return true;\\\\n\\\\n  return false;\\\\n}\\\\n\\\\nasync function copyTree(src: string, dest: string) {\\\\n  // Recursively copy, respecting ignore patterns and skipping asar/virtual entries\\\\n  let stat: fs.Stats;\\\\n  try {\\\\n    stat = await fsp.stat(src);\\\\n  } catch (e: any) {\\\\n    throw new Error(`Source path does not exist or is not accessible: ${src} (${e?.code || e})`);\\\\n    }\\\\n  if (!stat.isDirectory()) throw new Error(`Source ${src} is not a directory`);\\\\n  await fsp.mkdir(dest, { recursive: true });\\\\n\\\\n  const walk = async (from: string, to: string) => {\\\\n    let entries: fs.Dirent[] = [] as unknown as fs.Dirent[];\\\\n    try {\\\\n      entries = await fsp.readdir(from, { withFileTypes: true });\\\\n    } catch (e: any) {\\\\n      // Skip unreadable directories (e.g., asar virtuals)\\\\n      logger.warn(`copyTree: Skipping unreadable directory ${from}: ${e?.code || e}`);\\\\n      return;\\\\n    }\\\\n    for (const entry of entries) {\\\\n      const rel = path.relative(src, path.join(from, entry.name));\\\\n      if (shouldIgnoreCopy(rel)) continue;\\\\n      const srcPath = path.join(from, entry.name);\\\\n      const dstPath = path.join(to, entry.name);\\\\n\\\\n      // Skip any path that traverses into an asar archive\\\\n      if (srcPath.includes('.asar')) continue;\\\\n\\\\n      try {\\\\n        if (entry.isDirectory()) {\\\\n          await fsp.mkdir(dstPath, { recursive: true });\\\\n          await walk(srcPath, dstPath);\\\\n        } else if (entry.isSymbolicLink()) {\\\\n          // Resolve symlink target and copy contents (best-effort)\\\\n          try {\\\\n            const linkTarget = await fsp.readlink(srcPath);\\\\n            const resolved = path.resolve(path.dirname(srcPath), linkTarget);\\\\n            const st = await fsp.stat(resolved);\\\\n            if (st.isDirectory()) {\\\\n              await fsp.mkdir(dstPath, { recursive: true });\\\\n              await walk(resolved, dstPath);\\\\n            } else {\\\\n              await fsp.copyFile(resolved, dstPath);\\\\n            }\\\\n          } catch {\\\\n            // Fallback: copy file bytes of the link itself (as file)\\\\n            try { await fsp.copyFile(srcPath, dstPath); } catch {}\\\\n          }\\\\n        } else if (entry.isFile()) {\\\\n          await fsp.copyFile(srcPath, dstPath);\\\\n        }\\\\n      } catch (e: any) {\\\\n        // Skip problematic entries (e.g., ENOENT due to virtualized packaging paths)\\\\n        if (e && (e.code === 'ENOENT' || e.code === 'EBUSY' || e.code === 'EPERM')) {\\\\n          logger.warn(`copyTree: Skipping ${srcPath}: ${e.code}`);\\\\n          continue;\\\\n        }\\\\n        throw e;\\\\n      }\\\\n    }\\\\n  };\\\\n\\\\n  await walk(src, dest);\\\\n}\\\\n\\\\nexport async function runIsolatedOrchestrator(opts: {\\\\n  model: string;\\\\n  agentType: 'developer' | 'tester' | 'planner' | 'contexter' | 'speccer';\\\\n  projectId: string; \\\\n  taskId: string;\\\\n  featureId?: string; \\\\n  taskTools: TaskUtils,\\\\n  fileTools: FileTools,\\\\n  gitFactory: (projectRoot: string) => GitManager;  // git bound to projectRoot\\\\n  completion: CompletionClient;\\\\n  emit?: (e: { type: string; payload?: any }) => void;\\\\n}) {\\\\n  const { model, agentType, projectId, taskId, featureId, taskTools, fileTools, gitFactory, completion, emit } = opts;\\\\n\\\\n  const projectDir = await taskTools.getProjectDir(projectId);\\\\n\\\\n  // Create temp workspace\\\\n  const tmpBase = fs.mkdtempSync(path.join(os.tmpdir(), 'factory-ts-'));\\\\n  // Keep a subfolder to host the copied source\\\\n  const workspace = path.join(tmpBase, 'workspace');\\\\n\\\\n  logger.info(`Copying repository from '${projectDir}' to temporary workspace: '${workspace}'`);\\\\n  try {\\\\n    await copyTree(projectDir, workspace);\\\\n  } catch (e) {\\\\n    logger.error(`FATAL: Failed to copy repository to temporary directory from '${projectDir}' -> '${workspace}': ${e}`);\\\\n    // best-effort cleanup\\\\n    try { fs.rmSync(tmpBase, { recursive: true, force: true }); } catch {}\\\\n    return;\\\\n  }\\\\n\\\\n  const git = gitFactory(workspace);\\\\n\\\\n  try {\\\\n    await runOrchestrator({\\\\n      model,\\\\n      agentType,\\\\n      taskId,\\\\n      featureId,\\\\n      projectDir: workspace,\\\\n      taskTools,\\\\n      fileTools,\\\\n      git,\\\\n      completion,\\\\n      emit,\\\\n    });\\\\n  } catch (e) {\\\\n    logger.error(`An error occurred while running the agent orchestrator: ${e}`);\\\\n  } finally {\\\\n    // Cleanup temporary directory\\\\n    try {\\\\n      fs.rmSync(tmpBase, { recursive: true, force: true });\\\\n      logger.info('Agent run finished. Temporary directory cleaned up.');\\\\n    } catch (e) {\\\\n      logger.warn(`Failed to cleanup temporary directory '${tmpBase}': ${e}`);\\\\n    }\\\\n  }\\\\n}\\\\n\\\"}\"}]",
    "featureId": "86314974-b368-49d5-8137-4b5b0d053adb",
    "agentType": "developer",
    "turn": 2,
    "source": "tools",
    "createdAt": "2025-09-06T23:29:08.708Z"
  },
  {
    "role": "system",
    "content": "--- BEGIN FEATURE 065bac4d-1035-48de-9f17-2bbe2e35a300: All agent turn messages should show their thinking time next to the message bubble ---",
    "featureId": "065bac4d-1035-48de-9f17-2bbe2e35a300",
    "agentType": "developer",
    "marker": "feature_begin",
    "createdAt": "2025-09-06T23:46:14.169Z"
  },
  {
    "role": "user",
    "content": "# Developer Agent Steps Execution\n\nYou are the Developer Agent. You will be assigned a single feature to implement. Your goal is to complete it by following these steps precisely.\n\n## Workflow\n\n1.  **Analyze the Feature**: Read the feature's title, description and rejection (if provided) to understand its goal.\n2.  **Consult the File Structure**: Use the provided `docs/FILE_ORGANISATION.md` to understand the project context.\n3.  **Implement**: Write or modify files to meet the feature's acceptance criteria. Use the `write_file`, `rename_file`, `delete_file`, `list_files` and `search_files` tools for all file operations.\n4.  **Complete the Feature**: When the feature is complete, you **MUST** call the `finish_feature` tool. This is your final step for a successful implementation.\n5.  **Handle Blockers**: If you cannot proceed, you **MUST** use `block_feature` to explain the reason for being stuck - this signals that you are blocked and ready for a new assignment.\n\n## Notes\n\nFor context on the overall project structure, including how tasks and features are organized, refer to `docs/FILE_ORGANISATION.md`. You should always update this file with new major directory changes.\n#CURRENT TASK (ID: f67e8921-b197-40c9-9154-e95db8f27deb)\n##TITLE:\nUI Improvements\n##DESCRIPTION:\nVarious UI improvements to the app\n\n\n#ASSIGNED FEATURE: All agent turn messages should show their thinking time next to the message bubble (ID: 065bac4d-1035-48de-9f17-2bbe2e35a300)\n##DESCRIPTION: Inside @src/renderer/components/agents/ChatConversation.tsx for each turn where an agent sends a message (and the agent's thoughts are shown), next to it (there's space in the right padding area), show a the thinking time as a chip\n\n##REJECTION REASON:\nAll of the bubbles now show 0.0s - clearly the thinkingTime is computed wrongly.\n\n\n\n\n\n#TOOL SIGNATURES:\n- read_files(paths: list[str]) -> list[str] - Read the content of one or more files at the given relative paths. Returns an array of strings (one per file).\n- search_files(query: str, path: str = '.') -> list[str] - Search for files by name or textual content under the given path. Returns matching relative paths. The query input must be a space separated list of keywords\n- block_feature(reason: str) - Stop work on the current feature and report why you are blocked (e.g., missing context, unclear requirements).\n- finish_feature() - Mark the current feature as complete and end the run. Use only when the work fully meets the acceptance criteria.\n- list_files(path: str) - List files and directories at a relative path from the project root.\n- write_file(filename: str, content: str) - Create or overwrite a file with the given content. Always use this to write code or docs.\n- rename_file(filename: str, new_filename: str) - Rename or move a file from one path to another.\n- delete_file(filename: str) - Delete a file. Use with caution and only when necessary.\n- run_test() -> str - Run the test for the current feature and return the output. Use to verify implementation.\n\n#RESPONSE FORMAT INSTRUCTIONS:\nYou **MUST** respond in a single, valid JSON object. This object must adhere to the following structure:\n```json\n{\n  \"thoughts\": \"A string explaining your reasoning, analysis, and plan for this step. For example: 'I need to create the main application file and then add the basic boilerplate.'\",\n  \"tool_calls\": [\n    {\n      \"tool_name\": \"name_of_the_tool_to_call\",\n      \"arguments\": {\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\"\n      }\n    }\n  ]\n}\n```\nThe thoughts field is for your reasoning, and tool_calls is a list of actions to execute.\nYour response will be parsed as JSON. Do not include any text outside of this JSON object.\nAs responses to the tool calls you will send, you will also receive JSON objects in the form:\n```json\n{\n\"name\":\"tool_name\",\n\"result\":\"...\"\n}\n```\n\n#CONTEXT FILES PROVIDED:\n{\"docs/FILE_ORGANISATION.md\":\"# File Organisation\\n\\nPurpose\\n- Provide a high-level map of the repository so contributors and agents can quickly find the right area.\\n- This is not a change log and not a per-file inventory.\\n\\nEditing Rules (read before updating)\\n- Only document major directories and subsystems. Do not list individual files.\\n- Keep bullets short (one sentence) and avoid \\\"New:\\\" or historical notes.\\n- When adding/removing a major directory or moving a subsystem, update a single bullet here.\\n- Prefer linking or pointing to deeper docs (README/OVERVIEW) rather than describing internals here.\\n- Never document build related artifacts.\\n\\nTop-Level Layout\\n- docs/: Project-wide documentation and specs; single source of truth for protocols and workflows.\\n- src/: Application source (Electron app: main, preload, renderer, and tooling).\\n  - renderer/: React UI (components, screens, hooks, services, navigation, preview runtime).\\n    - components/agents/: Agent-specific UI (status chips, run bullets, model selectors, project/cost/token chips).\\n    - services/: Renderer-side services (e.g., pricingService for LLM price lookup via IPC).\\n    - hooks/useShortcuts: Keyboard shortcuts provider; respects user-selected modifier and avoids interfering with text input.\\n  - tools/: Developer and agent tooling (preview analyzer, factory integration, helpers).\\n  - main.js: Electron main process entry.\\n  - preload.js: Safe IPC surface exposed to the renderer.\\n- packages/: Local monorepo packages.\\n  - factory-ts/: Agent orchestration library (orchestrator, pricing, history, completion, git integration).\\n- scripts/: Project automation scripts and CLIs.\\n- Root config files: package.json, tsconfig.json, tailwind/postcss configs, vite configs, forge config, .env.\\n\\nWhere to Learn More\\n- Agents and roles: packages/factory-ts/docs (AGENT_*.md).\\n- Factory TS overview and APIs: packages/factory-ts (see README/OVERVIEW files in that package).\\n- Preview system: see src/renderer/preview and related docs in docs/ (preview usage and analyzer).\\n- IPC and factory integration: src/tools/factory (renderer bridge and main process handlers).\\n\\nConventions (brief)\\n- Keep cross-cutting documentation in docs/; place domain-specific or area-specific READMEs next to the code they describe.\\n- Use descriptive directory names and keep responsibilities separated by area (renderer vs main vs tools vs packages).\\n\\nEnvironment & Credentials\\n- .env at the repo root is used for local development (e.g., credentials consumed by tooling and factory-ts).\\n\\nNotes\\n- If you are unsure whether something belongs here, it probably belongs in a local README under its directory, with this file providing only a one-line pointer to that area.\\n\",\"src/renderer/components/agents/ChatConversation.tsx\":\"import React, { useMemo, useRef, useState, useEffect, useLayoutEffect } from 'react';\\nimport type { AgentFeatureRunLog, AgentRun, AgentRunMessage } from '../../services/agentsService';\\nimport RichText from '../ui/RichText';\\nimport SafeText from '../ui/SafeText';\\nimport { ToolResult, AgentResponse, ToolCall } from 'packages/factory-ts/src/types';\\n\\n// Parse assistant JSON response to extract thoughts and tool calls safely\\nfunction parseAssistant(content: string): AgentResponse | null {\\n  try {\\n    const obj = JSON.parse(content);\\n    if (obj && typeof obj === 'object') return obj as AgentResponse;\\n    return null;\\n  } catch {\\n    return null;\\n  }\\n}\\n\\nfunction JsonPreview({ value, maxChars = 200 }: { value: any; maxChars?: number }) {\\n  const str = typeof value === 'string' ? value : JSON.stringify(value, null, 2);\\n  if (str.length <= maxChars) return (<pre className=\\\"text-xs whitespace-pre-wrap break-words\\\">{str}</pre>);\\n  const [open, setOpen] = useState(false);\\n  return (\\n    <div>\\n      <pre className=\\\"text-xs whitespace-pre-wrap break-words\\\">{open ? str : str.slice(0, maxChars) + '\\\\u2026'}</pre>\\n      <button className=\\\"btn-link text-xs mt-1\\\" onClick={() => setOpen(v => !v)}>{open ? 'Show less' : 'Show more'}</button>\\n    </div>\\n  );\\n}\\n\\nfunction Collapsible({ title, children, defaultOpen = false, className, innerClassName }: { title: React.ReactNode; children: React.ReactNode; defaultOpen?: boolean, className?: string, innerClassName?: string }) {\\n  const [open, setOpen] = useState(defaultOpen);\\n  return (\\n    <div className={`${className ??''} border rounded-md border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900`}>\\n      <button className=\\\"w-full flex items-center justify-between px-3 py-2 text-left hover:bg-neutral-50 dark:hover:bg-neutral-800/50\\\" onClick={() => setOpen(v => !v)}>\\n        <span className=\\\"text-xs font-medium truncate pr-2\\\">{title}</span>\\n        <span className=\\\"text-xs text-neutral-500\\\">{open ? '\\\\u2212' : '+'}</span>\\n      </button>\\n      {open ? (\\n        <div className={`${innerClassName ??''} border-t border-neutral-200 dark:border-neutral-800`}>{children}</div>\\n      ) : null}\\n    </div>\\n  );\\n}\\n\\nfunction ToolCallRow({ call, resultText, index }: { call: ToolCall; resultText?: string; index: number }) {\\n  const name = (call as any).tool_name || (call as any).tool || (call as any).name || 'tool';\\n  const args = (call as any).arguments ?? (call as any).parameters ?? {};\\n  const isHeavy = name === 'read_files' || name === 'write_file';\\n\\n  return (\\n    <div className=\\\"rounded-md border border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/40\\\">\\n      <div className=\\\"px-3 py-2 flex items-start justify-between gap-3\\\">\\n        <div className=\\\"min-w-0\\\">\\n          <div className=\\\"text-xs font-semibold\\\">{index + 1}. {name}</div>\\n          <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400\\\">Arguments</div>\\n        </div>\\n      </div>\\n      <div className=\\\"px-3 pb-2\\\">\\n        {isHeavy ? (\\n          <Collapsible title={<span>View arguments</span>}>\\n            <JsonPreview value={args} maxChars={500} />\\n          </Collapsible>\\n        ) : (\\n          <div className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 max-h-60 overflow-auto\\\">\\n            <JsonPreview value={args} maxChars={400} />\\n          </div>\\n        )}\\n      </div>\\n      {resultText != null && (\\n        <div className=\\\"px-3 pb-3\\\">\\n          <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400 mb-1\\\">Result</div>\\n          {isHeavy ? (\\n            <Collapsible title={<span>View result</span>}>\\n              <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><SafeText text={resultText} /></div>\\n            </Collapsible>\\n          ) : (\\n            <div className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 text-xs whitespace-pre-wrap break-words max-h-60 overflow-auto\\\">\\n              <SafeText text={resultText} />\\n            </div>\\n          )}\\n        </div>\\n      )}\\n    </div>\\n  );\\n}\\n\\n// Back-compat: parse tool results from mixed formats (preferred ToolResult JSON, else legacy lines)\\nexport type ParsedToolResult = { name: string; result: string };\\n\\nfunction parseToolResultsObjects(msg?: AgentRunMessage): ParsedToolResult[] {\\n  if (!msg?.content) return [];\\n  const text = msg.content.trim();\\n  // Try full JSON parse (array or object)\\n  try {\\n    const o = JSON.parse(text);\\n    if (Array.isArray(o)) {\\n      return o\\n        .filter(x => x && typeof x === 'object' && ('name' in x) && ('result' in x))\\n        .map(x => ({ name: String((x as any).name), result: String((x as any).result) }));\\n    }\\n    if (o && typeof o === 'object') {\\n      if ('name' in o && 'result' in o) {\\n        return [{ name: String((o as any).name), result: String((o as any).result) }];\\n      }\\n      if ('results' in o && Array.isArray((o as any).results)) {\\n        return (o as any).results\\n          .filter((x: any) => x && typeof x === 'object' && ('name' in x) && ('result' in x))\\n          .map((x: any) => ({ name: String(x.name), result: String(x.result) }));\\n      }\\n    }\\n  } catch {}\\n  // Fallback: try per-line JSON or legacy textual format\\n  const out: ParsedToolResult[] = [];\\n  for (const ln of text.split(/\\\\r?\\\\n/)) {\\n    const line = ln.trim();\\n    if (!line) continue;\\n    if (line.startsWith('---')) continue;\\n    try {\\n      const jo = JSON.parse(line);\\n      if (jo && typeof jo === 'object' && 'name' in jo && 'result' in jo) {\\n        out.push({ name: String((jo as any).name), result: String((jo as any).result) });\\n        continue;\\n      }\\n      if (Array.isArray(jo)) {\\n        for (const x of jo) {\\n          if (x && typeof x === 'object' && 'name' in x && 'result' in x) {\\n            out.push({ name: String((x as any).name), result: String((x as any).result) });\\n          }\\n        }\\n        continue;\\n      }\\n    } catch {}\\n    if (line.startsWith('Tool ')) {\\n      const nameMatch = /^Tool\\\\s+([^\\\\s:]+)(?::|\\\\s)/.exec(line);\\n      const name = nameMatch ? nameMatch[1] : 'tool';\\n      const i = line.indexOf(' returned: ');\\n      const result = i >= 0 ? line.substring(i + ' returned: '.length) : line;\\n      out.push({ name, result });\\n    } else {\\n      out.push({ name: 'tool', result: line });\\n    }\\n  }\\n  return out;\\n}\\n\\nfunction isLargeText(text?: string) {\\n  if (!text) return false;\\n  const len = text.length;\\n  const lines = text.split(/\\\\r?\\\\n/).length;\\n  return len > 800 || lines > 16;\\n}\\n\\nfunction ScrollableTextBox({ text, className }: { text: string; className?: string }) {\\n  return (\\n    <div className={className}>\\n      <div className=\\\"rounded border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-950 p-2 max-h-64 overflow-auto text-xs whitespace-pre-wrap break-words\\\">\\n        <RichText text={text} />\\n      </div>\\n    </div>\\n  );\\n}\\n\\nfunction isToolMsg(m: AgentRunMessage | undefined) {\\n  if (!m) return false;\\n  const content = m.content || '';\\n  const hinted = (m as any).source === 'tools';\\n  if (m.role === 'tool' || hinted || content.startsWith('--- TOOL RESULTS ---')) return true;\\n  // Robust detection: if content is JSON representing tool results, treat as tool message\\n  try {\\n    const o = JSON.parse(content);\\n    if (Array.isArray(o)) {\\n      return o.every(x => x && typeof x === 'object' && 'name' in x && 'result' in x);\\n    }\\n    if (o && typeof o === 'object') {\\n      if ('name' in o && 'result' in o) return true;\\n      if ('results' in o && Array.isArray((o as any).results)) {\\n        return (o as any).results.every((x: any) => x && typeof x === 'object' && 'name' in x && 'result' in x);\\n      }\\n    }\\n  } catch {}\\n  return false;\\n}\\n\\nfunction buildFeatureTurns(messages: AgentRunMessage[]) {\\n  const turns: { assistant: AgentRunMessage; tools?: AgentRunMessage; index: number; isFinal?: boolean; thinkingTime?: number }[] = [];\\n  if (!messages || messages.length === 0) return { initial: undefined as AgentRunMessage | undefined, turns };\\n\\n  // Initial message is the first non-tool message (usually user)\\n  let idx = 0;\\n  while (idx < messages.length && isToolMsg(messages[idx])) idx++;\\n  const initial = messages[idx];\\n  idx++;\\n\\n  let lastMessageForTime: AgentRunMessage | undefined = initial;\\n\\n  let tIndex = 0;\\n  while (idx < messages.length) {\\n    const a = messages[idx];\\n    if (!a) break;\\n    if (a.role !== 'assistant') {\\n      // Skip anything unexpected\\n      idx++;\\n      continue;\\n    }\\n\\n    let thinkingTime: number | undefined;\\n    if (lastMessageForTime && (lastMessageForTime as any).createdAt && (a as any).createdAt) {\\n      try {\\n        const startTime = new Date((lastMessageForTime as any).createdAt).getTime();\\n        const endTime = new Date((a as any).createdAt).getTime();\\n        if (!isNaN(startTime) && !isNaN(endTime)) {\\n          thinkingTime = endTime - startTime;\\n        }\\n      } catch (e) {\\n        // ignore date parsing errors\\n      }\\n    }\\n\\n    const parsed = parseAssistant(a.content);\\n    if (parsed && Array.isArray(parsed.tool_calls) && parsed.tool_calls.length > 0) {\\n      const maybeTools = messages[idx + 1];\\n      if (isToolMsg(maybeTools)) {\\n        turns.push({ assistant: a, tools: maybeTools, index: tIndex++, thinkingTime });\\n        lastMessageForTime = maybeTools;\\n        idx += 2;\\n        continue;\\n      }\\n      // No tools message, still push assistant-only\\n      turns.push({ assistant: a, index: tIndex++, thinkingTime });\\n      lastMessageForTime = a;\\n      idx += 1;\\n      continue;\\n    }\\n    // Final assistant message (no tool_calls)\\n    turns.push({ assistant: a, index: tIndex++, isFinal: true, thinkingTime });\\n    lastMessageForTime = a;\\n    idx += 1;\\n  }\\n  return { initial, turns };\\n}\\n\\nfunction AssistantBubble({ title, text }: { title?: string; text: string }) {\\n  return (\\n    <div className=\\\"max-w-[80%] rounded-2xl px-3 py-2 bg-blue-50 text-blue-900 dark:bg-blue-900/20 dark:text-blue-100 shadow-sm\\\">\\n      {title ? <div className=\\\"text-[11px] font-medium mb-1\\\">{title}</div> : null}\\n      {isLargeText(text) ? (\\n        <ScrollableTextBox text={text} />\\n      ) : (\\n        <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={text} /></div>\\n      )}\\n    </div>\\n  );\\n}\\n\\nfunction UserBubble({ title, text }: { title?: string; text: string }) {\\n  return (\\n    <div className=\\\"max-w-[80%] rounded-2xl px-3 py-2 bg-neutral-100 text-neutral-900 dark:bg-neutral-800 dark:text-neutral-50 shadow-sm\\\">\\n      {title ? <div className=\\\"text-[11px] font-medium mb-1\\\">{title}</div> : null}\\n      {isLargeText(text) ? (\\n        <ScrollableTextBox text={text} />\\n      ) : (\\n        <div className=\\\"text-xs whitespace-pre-wrap break-words\\\"><RichText text={text} /></div>\\n      )}\\n    </div>\\n  );\\n}\\n\\nfunction FeatureContent({ log }: { log: AgentFeatureRunLog }) {\\n  // Recompute on every render to reflect in-place mutations of log.messages\\n  const { initial, turns } = buildFeatureTurns(log.messages || []);\\n  const lastTurnRef = useRef<HTMLDivElement | null>(null);\\n\\n  return (\\n    <div className=\\\"space-y-2 p-1\\\">\\n      {initial ? (\\n        <Collapsible title={<span className=\\\"flex items-center1\\\">Initial prompt</span>} defaultOpen>\\n          {isLargeText(initial.content || '') ? (\\n            <ScrollableTextBox text={initial.content || ''} />\\n          ) : (\\n            <div className=\\\"p-2 text-xs whitespace-pre-wrap break-words\\\"><RichText text={initial.content || ''} /></div>\\n          )}\\n        </Collapsible>\\n      ) : (\\n        <div className=\\\"text-sm text-neutral-500\\\">No conversation yet.</div>\\n      )}\\n\\n      {turns.map((t, idx) => {\\n        const parsed = parseAssistant(t.assistant?.content || '');\\n        const toolCalls: ToolCall[] = parsed?.tool_calls || [];\\n        const resultsObjs = parseToolResultsObjects(t.tools);\\n        const pickResultForCall = (call: ToolCall, i: number) => resultsObjs[i]?.result ?? undefined;\\n        const hasThoughts = parsed?.thoughts && parsed.thoughts.trim().length > 0;\\n        const isFinal = t.isFinal || (toolCalls.length === 0);\\n\\n        return (\\n          <div key={idx} ref={idx === turns.length - 1 ? lastTurnRef : undefined}>\\n            <Collapsible innerClassName='p-2' title={<span className=\\\"flex items-center gap-2\\\">{isFinal ? 'Final' : `Turn ${idx + 1}`}</span>} defaultOpen={idx === turns.length - 1}>\\n              <div className=\\\"space-y-2\\\">\\n                <div className=\\\"flex items-start justify-between gap-2\\\">\\n                  <div className=\\\"min-w-0\\\">\\n                    {hasThoughts ? (\\n                      <AssistantBubble text={parsed!.thoughts!} />\\n                    ) : (\\n                      <AssistantBubble title=\\\"Assistant\\\" text={t.assistant?.content || ''} />\\n                    )}\\n                  </div>\\n                  {t.thinkingTime != null && (\\n                    <div className=\\\"flex-shrink-0 bg-neutral-100 dark:bg-neutral-800 rounded-full px-2 py-0.5 text-xs text-neutral-500 dark:text-neutral-400 whitespace-nowrap mt-1\\\">\\n                      {(t.thinkingTime / 1000).toFixed(1)}s\\n                    </div>\\n                  )}\\n                </div>\\n\\n                {toolCalls.length > 0 ? (\\n                  <div className=\\\"space-y-2\\\">\\n                    {toolCalls.map((call, i) => (\\n                      <ToolCallRow key={i} call={call} index={i} resultText={pickResultForCall(call, i)} />\\n                    ))}\\n                  </div>\\n                ) : null}\\n\\n                {toolCalls.length === 0 && !isFinal && resultsObjs.length > 0 ? (\\n                  <div className=\\\"rounded-md border border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/40 p-2\\\">\\n                    <div className=\\\"text-[11px] text-neutral-600 dark:text-neutral-400 mb-1\\\">Tool results</div>\\n                    {resultsObjs.map((r, i) => (\\n                      <div key={i} className=\\\"rounded bg-white dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 p-2 mb-2 last:mb-0 text-xs whitespace-pre-wrap break-words max-h-60 overflow-auto\\\">\\n                        <SafeText text={r.result} />\\n                      </div>\\n                    ))}\\n                  </div>\\n                ) : null}\\n              </div>\\n            </Collapsible>\\n          </div>\\n        );\\n      })}\\n    </div>\\n  );\\n}\\n\\nexport default function ChatConversation({ run }: { run: AgentRun }) {\\n  // Derive logs (sorted by startDate)\\n  const logs = useMemo(() => {\\n    const SKIP_FEATURE_KEYS = new Set(['__task__', '_task']);\\n    const list = Object.values(run.messagesLog ?? {}).filter((l) => !SKIP_FEATURE_KEYS.has((l as any).featureId));\\n    return list.sort((a, b) => {\\n      const at = new Date((a as any).startDate).getTime();\\n      const bt = new Date((b as any).startDate).getTime();\\n      return at - bt;\\n    });\\n  }, [run]);\\n\\n  // Track a scroll container and auto-scroll behavior\\n  const containerRef = useRef<HTMLUListElement | null>(null);\\n  const stickToBottomRef = useRef(true);\\n\\n  // Update stickToBottomRef on user scroll\\n  useEffect(() => {\\n    const el = containerRef.current;\\n    if (!el) return;\\n    const onScroll = () => {\\n      const threshold = 40; // px\\n      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - threshold;\\n      stickToBottomRef.current = atBottom;\\n    };\\n    el.addEventListener('scroll', onScroll, { passive: true } as any);\\n    // Initialize state\\n    onScroll();\\n    return () => el.removeEventListener('scroll', onScroll);\\n  }, []);\\n\\n  // Compute a simple metric to detect new content\\n  const contentSize = useMemo(() => {\\n    let count = 0;\\n    for (const l of logs) count += (l.messages?.length || 0);\\n    return count + ':' + logs.length;\\n  }, [logs]);\\n\\n  // Auto-scroll when new content arrives and user is at bottom\\n  useLayoutEffect(() => {\\n    const el = containerRef.current;\\n    if (!el) return;\\n    if (stickToBottomRef.current) {\\n      el.scrollTo({ top: el.scrollHeight });\\n    }\\n  }, [contentSize]);\\n\\n  return (\\n    <ul ref={containerRef} className=\\\"h-[60vh] max-h-[70vh] overflow-auto bg-neutral-50 dark:bg-neutral-900 rounded-md border border-neutral-200 dark:border-neutral-800 p-3 space-y-3\\\" role=\\\"log\\\" aria-live=\\\"polite\\\">\\n      {logs.length === 0 ? (\\n        <div className=\\\"text-sm text-neutral-500\\\">No features messages to display.</div>\\n      ) : (\\n        <>{logs.map((log) => {\\n          const start = log.startDate ? new Date(log.startDate as any) : undefined;\\n          const end = log.endDate ? new Date(log.endDate as any) : undefined;\\n          const subtitle = [start ? start.toLocaleString() : null, end ? `→ ${end.toLocaleString()}` : null].filter(Boolean).join(' ');\\n          return (\\n            <li key={log.featureId}>\\n              <Collapsible title={<span className=\\\"flex items-center\\\">Feature: {log.featureId}{subtitle ? <span className=\\\"text-neutral-500 text-[11px] px-3 py-2\\\"> {subtitle}</span> : null}</span>} defaultOpen>\\n                <FeatureContent log={log} />\\n              </Collapsible>\\n            </li>\\n          );\\n        })}</>\\n      )}\\n    </ul>\\n  );\\n}\\n\"}\n\nBegin now.",
    "featureId": "065bac4d-1035-48de-9f17-2bbe2e35a300",
    "agentType": "developer",
    "turn": 0,
    "source": "initial",
    "createdAt": "2025-09-06T23:46:14.209Z"
  }
]