{
  "id": 4,
  "status": "-",
  "title": "Task handling",
  "description": "Implement all features that allow proper handling of tasks",
  "features": [
    {
      "id": "4.1",
      "status": "-",
      "title": "Task schema definition and validator",
      "description": "Create a JSON Schema that mirrors the canonical task format described in docs/tasks/task_format.py and task_example.json. Generate TypeScript interfaces from the schema. Implement a validator used before reading/writing task.json. Acceptance: Validator catches malformed examples; TS types aligned with schema; unit tests cover valid/invalid cases using sample task.json files.",
      "plan": "Implementation plan for Feature 5.5: Task schema definition and validator\n\n1) Gather canonical sources\n- Open and study docs/tasks/task_format.py and docs/tasks/task_example.json to enumerate all fields, types, required/optional properties, allowed enums, nested objects/arrays, defaults, and any constraints (e.g., regex patterns, value ranges, cross-field rules).\n- Document the final field list and constraints in a short design notes file at docs/tasks/schema_notes.md for future maintainability.\n\n2) Create JSON Schema\n- File: schema/task.schema.json\n- Version: Draft 2020-12 (or 2019-09) to support modern features. Include $schema and $id.\n- Define the root object type with strict: \"additionalProperties\": false\n- Encode all required fields from Python canonical format.\n- Capture enums, min/max constraints, formats (date-time, uri), and patterns as present in the canonical spec.\n- Use definitions/$defs for reusable sub-objects (e.g., Task, Subtask, Assignee, StatusHistory, Link, etc.) if applicable.\n- Provide description fields for clarity and align property naming exactly with canonical names.\n- If Python spec defines defaults, include them using default where helpful (note defaults are for tooling, not enforcement).\n- Add examples array containing the known-good task_example.json.\n\n3) Validation library setup (Node/TS)\n- Dependency: ajv@^8 and ajv-formats for formats support.\n- Create a validation module in shared code:\n  - File: src/shared/validation/taskValidator.ts\n  - Export: validateTask(data: unknown): { valid: true; data: Task } | { valid: false; errors: Ajv.ErrorObject[] }\n  - Load and compile the schema once (singleton), configure Ajv with:\n    - allErrors: true\n    - strict: true\n    - removeAdditional: false\n    - allowUnionTypes: true (if needed)\n    - formats from ajv-formats\n  - Add helper function assertValidTask(data) that throws a descriptive Error when invalid, with a compacted error message builder for UI logging.\n\n4) Type generation from schema\n- Dependency: json-schema-to-typescript (jstt).\n- Script: npm run generate:task-types -> generates src/shared/types/task.ts from schema/task.schema.json\n- Configure jstt options:\n  - bannerComment warning that the file is auto-generated, do not edit.\n  - style: prefer interfaces\n  - declareExternallyReferenced: true\n- Ensure the generated root type is exported as Task to be consumed across the app.\n- Add a type-test compile step (tsc --noEmit) in CI that imports Task from generated types and uses it in at least one file to ensure alignment.\n\n5) Integrate validator in read/write flows\n- Identify modules that read and write task.json (e.g., src/main/fs/taskStore.ts or equivalent). If they don’t exist yet, create a dedicated task store module.\n- On read:\n  - Read JSON -> parse -> validate via validateTask\n  - If invalid: throw a descriptive error including path(s) and message(s) for UI display.\n  - If valid: return typed Task\n- On write:\n  - Validate the Task object before serialization. If invalid, fail-fast with error to avoid persisting malformed data.\n- Optional: provide a CLI/Dev script npm run validate:task path/to/task.json to quickly validate files during development.\n\n6) Testing\n- Test framework: Vitest (or Jest if the project standard already exists). Assume Vitest here.\n- Add fixtures:\n  - tests/fixtures/task/valid/task_valid.json — copy of docs/tasks/task_example.json\n  - tests/fixtures/task/invalid/*.json — multiple malformed cases, such as:\n    - missing required field(s)\n    - wrong type (string vs number)\n    - disallowed additional properties\n    - invalid enum values\n    - invalid nested object shape\n    - bad format (e.g., invalid date-time)\n- Unit tests:\n  - tests/taskValidator.valid.spec.ts — ensure valid example passes and types narrow to Task\n  - tests/taskValidator.invalid.spec.ts — iterate over invalid fixtures, assert validateTask returns {valid:false} and errors describe the failing paths\n  - tests/generation.types.spec.ts — import generated Task type and ensure a sample object typed as Task compiles; ensure a known-invalid object fails type-check via // @ts-expect-error tests\n- Ensure CI runs: type generation (or validate generated file is up-to-date), tsc --noEmit, and vitest\n\n7) Developer tooling and scripts\n- package.json scripts:\n  - generate:task-types: json2ts schema/task.schema.json -o src/shared/types/task.ts\n  - validate:task: ts-node scripts/validateTaskFile.ts <path> (or node + tsx if repo uses it)\n  - test: vitest run\n  - typecheck: tsc --noEmit\n- Add a prebuild or postinstall step to generate types or document that contributors must run generate:task-types after schema changes.\n\n8) Documentation\n- docs/tasks/schema_notes.md — mapping table: Python canonical fields -> JSON Schema properties; any assumptions; examples of valid/invalid fragments.\n- CONTRIBUTING.md — add a short section explaining how to modify task.schema.json, regenerate types, run validator, and add tests.\n\n9) Quality gates\n- Add a CI job that fails if:\n  - Generated types are outdated (diff check after running generate:task-types)\n  - tsc typecheck fails\n  - vitest fails\n- Add a pre-commit hook (optional) using simple-git-hooks or husky to run quick validate:task on changed task.json files.\n\n10) Future-proofing\n- If the Python canonical spec evolves, keep a bi-directional mapping note in schema_notes.md and bump schema $id version (e.g., v1 -> v4.1). Communicate breaking vs non-breaking changes and update tests accordingly.\n\nDeliverables checklist\n- schema/task.schema.json aligned with docs/tasks/task_format.py and task_example.json\n- src/shared/types/task.ts generated by json-schema-to-typescript\n- src/shared/validation/taskValidator.ts with Ajv-based validateTask/assertValidTask\n- Read/write integration with validation hooks\n- Tests and fixtures for valid/invalid cases\n- Scripts in package.json and CI updates\n- Documentation updates",
      "context": [],
      "acceptance": []
    },
    {
      "id": "4.2",
      "status": "-",
      "title": "Tasks indexer and file watcher",
      "description": "Scan tasks/{id}/ directories under the selected project root to build an in-memory index of tasks and features. Implement a file watcher to refresh the index on changes (create/modify/delete). Cache results for quick UI rendering. Acceptance: Indexing handles 100+ tasks; watcher reliably updates on file changes; performance measured and documented; exposed via IPC: tasks:list and task:get.",
      "plan": "Title: Tasks indexer and file watcher\n\nGoal\n- Scan tasks/{id}/ under the selected project root to build an in-memory index of tasks and their features.\n- Implement a file watcher to refresh the index on filesystem changes (create/modify/delete).\n- Cache results for fast UI rendering.\n- Expose IPC endpoints: tasks:list and task:get.\n- Handle 100+ tasks reliably; measure and document performance.\n\nHigh-level Design\n- Run the indexer in Electron main process.\n- Use chokidar to watch the tasks directory.\n- In-memory cache for fast list rendering; optionally persist to disk to prewarm on app start.\n- Minimal summaries for list; full details on demand for get.\n- Parser abstraction to support JSON/YAML task metadata (task.json/task.yaml). Extract features if present.\n- IPC handlers return typed DTOs to the renderer.\n\nDirectory and Files\n- tasks/{id}/ is a task directory. We detect the task ID from the directory name.\n- Preferred task metadata files within each task dir (first match wins):\n  1) task.json\n  2) task.yaml or task.yml\n  3) README.md (fallback for title/description only)\n- Optional files: features.json or features.yaml; otherwise features can live inline in task metadata under \"features\" key. If none found, features = []\n\nTech Stack\n- Node/Electron main process (TypeScript)\n- chokidar for watching\n- fast-glob for initial discovery (or fs.readdir recursive if preferred)\n- yaml for YAML parsing\n- fs-extra for FS convenience\n- zod for schema validation (optional but recommended)\n- lodash.debounce (or simple custom debounce)\n- perf_hooks for measurements\n- Jest or Vitest for tests\n\nType Definitions (shared/types/tasks.ts)\n- TaskId = string\n- TaskSummary {\n  id: string\n  path: string\n  title: string\n  status?: string\n  featureCount: number\n  updatedAt: number // ms epoch from latest relevant file mtime\n}\n- TaskFeature {\n  id: string\n  title?: string\n  status?: string\n}\n- TaskDetail extends TaskSummary {\n  description?: string\n  assignee?: string\n  tags?: string[]\n  features: TaskFeature[]\n  raw?: { source: 'json'|'yaml'|'md'|null, data?: any }\n}\n- TaskIndexStats {\n  projectRoot: string\n  taskCount: number\n  lastFullScanMs: number\n  lastScanAt: number\n  averageScanMs?: number\n}\n\nFilesystem Parsing Rules\n- For each tasks/<id>/:\n  - Read task.json or task.yaml/yml. Validate with zod schema (soft validation: log and continue if invalid).\n  - Extract fields: title, status, description, assignee, tags, features.\n  - If features missing, try features.json or features.yaml.\n  - If no structured metadata found, try README.md: use first heading as title and first paragraph as description; features = [].\n  - Determine updatedAt as max mtime of the selected primary metadata file and features file (if any).\n- Feature entries should at least have id; if no id provided, derive from directory/file name or hash of title.\n\nCaching Strategy\n- Maintain an in-memory Map<string, TaskDetail> index (key = taskId).\n- Maintain a separate array of TaskSummary built from details to respond quickly.\n- Persist a snapshot of summaries + a minimal detail cache to disk in app.getPath('userData')/cache/tasks/<hash(projectRoot)>.json to prewarm on app launch.\n- On startup for a given project root: try load disk cache first, serve immediately; then trigger background fresh full scan to validate/refresh.\n- Throttle disk cache writes (e.g., once every 2 seconds, trailing) to avoid excessive FS writes during rapid changes.\n\nWatcher Strategy (chokidar)\n- Watch: <projectRoot>/tasks/** with ignored patterns: ['**/node_modules/**', '**/.git/**', '**/.DS_Store'].\n- Events handled: add, addDir, change, unlink, unlinkDir.\n- Debounce re-scan operations per task directory (e.g., 150ms) to coalesce multiple rapid edits.\n- Incremental updates: on event within tasks/<id>/..., only re-parse that specific task; on directory removal, delete entry; on new dir, parse it.\n- Provide a full re-scan method as fallback and for initial indexing.\n\nPerformance\n- Use perf_hooks.performance.now() around scan operations; record lastFullScanMs and average over recent N scans.\n- Target: 100+ tasks initial scan in under ~500ms for simple metadata on a typical dev machine (document test conditions).\n- Ensure watchers do not trigger full re-scan unless necessary; prefer per-task incremental updates.\n\nIPC Endpoints (main/ipc/tasks.ts)\n- tasks:list -> returns { tasks: TaskSummary[], stats: TaskIndexStats }\n- task:get { id: string } -> returns TaskDetail | null\n- Optionally (dev-only): tasks:stats -> TaskIndexStats (or included in tasks:list)\n\nAPI Contracts (renderer expectation)\n- tasks:list should resolve quickly using in-memory summaries, even if a background refresh is ongoing.\n- task:get should return from cache if available; otherwise parse on-demand for that task directory and update cache.\n\nEdge Cases & Error Handling\n- Missing or malformed metadata: log warning; fall back to minimal info from directory name; do not crash.\n- Duplicate task IDs (duplicate directory names): last write wins; log error.\n- Non-UTF8 files: ignore with warning.\n- Root change: gracefully dispose current watcher and caches; initialize new indexer.\n\nImplementation Steps\n1) Scaffolding\n   - Create files:\n     - main/services/tasks/TaskIndexer.ts\n     - main/services/tasks/parsers/jsonParser.ts\n     - main/services/tasks/parsers/yamlParser.ts\n     - main/services/tasks/parsers/mdParser.ts\n     - main/ipc/tasks.ts\n     - shared/types/tasks.ts\n     - docs/performance/tasks_indexer.md\n     - tests/tasks/indexer.spec.ts\n\n2) Types and Schemas\n   - Define TaskSummary, TaskDetail, TaskFeature, TaskIndexStats in shared/types/tasks.ts.\n   - Define zod schemas in parsers for validation (optional but helpful).\n\n3) Parsers\n   - jsonParser: read task.json/features.json; parse, validate, normalize fields.\n   - yamlParser: read task.yaml|yml/features.yaml|yml; parse with yaml.\n   - mdParser: read README.md; extract first H1 (title) and first paragraph (description).\n   - Export a function parseTaskDir(taskDir: string): Promise<TaskDetail | null> that tries parsers in order and returns normalized TaskDetail.\n   - Ensure updatedAt is computed via fs.stat for the chosen files.\n\n4) TaskIndexer Class (main/services/tasks/TaskIndexer.ts)\n   - constructor(projectRoot: string)\n   - public async init(): initializes cache (load from disk), sets up chokidar watcher, triggers initial full scan in background.\n   - private async fullScan():\n     - Enumerate subdirectories under <root>/tasks using fs or fast-glob.\n     - In parallel (bounded concurrency, e.g., 10), parse each task dir.\n     - Build memory maps for details and summaries; compute stats; swap atomically.\n     - Persist summaries to disk cache (throttled).\n   - private async parseAndUpdateTask(taskDir: string): parse single task and update/remove in cache.\n   - private onFsEvent(event, path): debounced per task directory -> calls parseAndUpdateTask or remove.\n   - getSummaries(): TaskSummary[] (return shallow clone to avoid mutation)\n   - getTask(id: string): TaskDetail | null (if missing, try parse on-demand)\n   - getStats(): TaskIndexStats\n   - dispose(): close watcher, flush cache, cleanup timers.\n   - Use EventEmitter to emit 'index:updated' and 'task:updated' for future live UI updates (optional in this feature).\n\n5) Disk Cache\n   - Path: path.join(app.getPath('userData'), 'cache', 'tasks', hash(projectRoot) + '.json').\n   - Shape: { version: 1, projectRoot, summaries: TaskSummary[], timestamp }.\n   - Load on init if exists; populate in-memory summaries; mark as warm.\n   - Save after full scans and after bursts of incremental updates (throttled).\n\n6) Watcher Setup\n   - chokidar.watch(path.join(projectRoot, 'tasks'), { ignoreInitial: false, depth: 3, ignored: ['**/node_modules/**', '**/.git/**', '**/.DS_Store'] })\n   - Handle addDir/removeDir for tasks/<id> creation/deletion; add/change/unlink for metadata files inside.\n   - Debounce per-task using a Map<taskId, timeout> with 150ms delay.\n\n7) IPC Wiring (main/ipc/tasks.ts)\n   - Register handlers in app ready:\n     - ipcMain.handle('tasks:list', async () => ({ tasks: indexer.getSummaries(), stats: indexer.getStats() }))\n     - ipcMain.handle('task:get', async (_evt, id: string) => indexer.getTask(id))\n   - Export a function registerTasksIpc(indexer: TaskIndexer) to be called from main bootstrap.\n\n8) Bootstrap Integration\n   - In main process startup, when project root is selected/changed, instantiate TaskIndexer(root); call init(); registerTasksIpc(indexer).\n   - On root change, dispose previous indexer and create a new one.\n\n9) Performance Measurement & Documentation\n   - Record lastFullScanMs and taskCount on each scan; maintain an average over the last N scans.\n   - Add logs (debug) with counts and timings.\n   - Write docs/performance/tasks_indexer.md:\n     - How to run performance test\n     - Hardware/software environment\n     - Results for 100+ tasks (initial scan time, memory footprint estimate)\n\n10) Testing (Jest/Vitest)\n   - Create temp directory fixture with >120 tasks; generate task.json files with minimal fields.\n   - Test full scan finds all tasks and builds accurate summaries (featureCount, titles).\n   - Test watcher: create a new task dir -> expect new task in index after debounce; modify task.json title -> expect updated summary; delete task dir -> expect removal.\n   - Test performance: measure scan duration and assert within a reasonable bound (use generous threshold to avoid flakiness, but record measured value).\n   - Test malformed files: invalid JSON/YAML -> no crash, logs warning, task omitted or minimal fallback from README.md.\n   - Test disk cache: prewrite a cache file, init indexer, verify summaries served quickly prior to full scan.\n\n11) Observability & Logging\n   - Centralize logs in TaskIndexer with levels (info/debug/warn) using existing logging utility if present.\n   - Include counts and timings in info logs after scans.\n\n12) Configuration\n   - Expose optional configuration:\n     - TASKS_INDEXER_MAX_CONCURRENCY (default 10)\n     - TASKS_WATCH_DEBOUNCE_MS (default 150)\n     - TASKS_CACHE_WRITE_MS (default 2000)\n     - TASKS_DISABLE_DISK_CACHE (default false)\n   - Read from env or app config service.\n\n13) Security & Safety\n   - Sanitize and normalize projectRoot; ensure all watched paths are within projectRoot/tasks.\n   - Escape/sanitize IDs derived from directory names (use directory basename as ID, no path traversal).\n\n14) Acceptance Mapping\n- Indexing handles 100+ tasks: Verified by tests with 120+ generated tasks and documented timings.\n- Watcher reliably updates on file changes: Unit/integration tests simulate add/modify/delete and validate index updates.\n- Performance measured and documented: perf_hooks instrumentation and docs/performance report.\n- Exposed via IPC: tasks:list and task:get implemented and wired in main process.\n\n15) Future Enhancements (not required now)\n- Live push updates to renderer via IPC events on index changes.\n- Schema evolution handling with versioning.\n- Additional parsers (e.g., TOML) and richer feature directory structures.\n- Indexed search across task titles/descriptions via minisearch or lunr.\n",
      "context": [],
      "acceptance": [],
      "dependencies":["4.1"]
    },
    {
      "id": "4.3",
      "status": "-",
      "title": "Tasks list UI with filtering and search",
      "description": "Build a React view listing tasks with id, title, status, and counts of features (done/total). Provide text search and filters (e.g., status). Clicking a row opens details. Acceptance: Renders list from IPC data; filtering/search applied client-side; empty states handled; accessibility basics (labels, keyboard nav) covered.",
      "plan": "Implementation Plan: Tasks list UI with filtering and search (Feature 5.7)\n\nAssumptions\n- Project uses Electron (main + preload) and React + TypeScript in renderer.\n- There is/will be an IPC surface to fetch tasks from the main process. If not present, we will add it here.\n- React Router is used (or can be added) for navigation to a Task Details view.\n\n1) Define shared types\n- Create shared/types/tasks.ts with the minimal shape required by this feature:\n  export type TaskStatus = 'todo' | 'in_progress' | 'blocked' | 'done'\n  export interface TaskSummary {\n    id: string\n    title: string\n    status: TaskStatus\n    features: { done: number; total: number }\n  }\n- If a shared folder is not available, duplicate the type in both main and renderer temporarily with TODO to consolidate.\n\n2) IPC: main process handlers\n- In main/src/ipc/tasks.ts (or similar):\n  - Register ipcMain.handle('tasks:get', async () => Promise<TaskSummary[]>)\n  - Implementation can read from the existing task source. If not available yet, stub with an in-memory mock returning an array of TaskSummary.\n- Export a small tasksService.listSummaries() to keep main code clean; later it can be wired to real data (git/agents).\n\n3) Preload bridge\n- In preload/index.ts, expose tasks API via contextBridge:\n  type TasksAPI = { getTasks: () => Promise<TaskSummary[]> }\n  contextBridge.exposeInMainWorld('tasksAPI', {\n    getTasks: () => ipcRenderer.invoke('tasks:get')\n  })\n- Add global typing for window.tasksAPI in renderer/src/types/global.d.ts to ensure TS safety.\n\n4) Renderer: API wrapper\n- Create renderer/src/api/tasks.ts:\n  export async function getTasks(): Promise<TaskSummary[]> { return window.tasksAPI.getTasks() }\n\n5) Routing: ensure details route exists\n- Add a route /tasks and /tasks/:id in the router if not already present.\n- Create a placeholder TaskDetailsPage that reads :id and displays basic info (can be expanded by another feature).\n\n6) UI structure and components\n- Create renderer/src/pages/TasksPage/ with components:\n  - TasksPage.tsx: page container and state management\n  - TaskFilters.tsx: search input + status checkboxes\n  - TaskList.tsx: renders list + empty/loading/error states\n  - TaskRow.tsx: individual row\n- Style with existing styling system (CSS Modules/Tailwind) or minimal CSS module for layout and badges.\n\n7) State and data flow in TasksPage\n- Local state: tasks (TaskSummary[]), loading, error, searchQuery (string), selectedStatuses (Set<TaskStatus>)\n- useEffect(() => { loadTasks() }, []) where loadTasks calls getTasks(), sets loading/error accordingly.\n- Derived filteredTasks computed via useMemo from tasks, searchQuery, selectedStatuses.\n  - Search: case-insensitive substring match on id and title.\n  - Filters: include task if selectedStatuses is empty OR selectedStatuses has task.status.\n\n8) Filters UI (TaskFilters)\n- Accessible search input:\n  - <label htmlFor=\"task-search\">Search tasks</label>\n  - <input id=\"task-search\" type=\"search\" value={searchQuery} onChange=... placeholder=\"Search by id or title\" />\n  - Clear button (type=button) that resets searchQuery when visible.\n- Status filter group:\n  - Wrap in <fieldset><legend>Status filters</legend> ...</fieldset>\n  - Checkboxes for each status: Todo, In progress, Blocked, Done\n  - Maintain selectedStatuses via onChange toggling.\n\n9) List and Empty/Loading/Error states (TaskList)\n- Loading: show skeleton rows (e.g., 5 gray bars with aria-hidden) and aria-live polite message \"Loading tasks…\".\n- Error: show message \"Could not load tasks\" and a Retry button that calls loadTasks.\n- Empty states:\n  - If tasks length === 0 after load: \"No tasks available yet.\"\n  - If filteredTasks length === 0 but tasks > 0: \"No tasks match your search/filters\" with a Clear filters button to reset search and filters.\n- Render count summary with aria-live: \"Showing X of Y tasks\".\n\n10) TaskRow content and semantics\n- Each row rendered as a button-like element for keyboard activation while preserving list semantics:\n  - <li><button className=\"row\" onClick={openDetails} onKeyDown={handleKeyDown} aria-label={`Open task ${id}: ${title}`}> ... </button></li>\n- Display:\n  - Left: monospaced id\n  - Middle: title (truncate with ellipsis)\n  - Right: status badge with color + Features: done/total\n- Provide title attribute with full title for hover.\n\n11) Navigation behavior\n- openDetails navigates to /tasks/{id} using useNavigate from React Router.\n- handleKeyDown supports Enter/Space to open; Up/Down arrow optional (see step 12).\n\n12) Keyboard navigation\n- Default Tab navigation is sufficient; enhance with optional roving tabindex for arrow up/down among rows:\n  - Maintain focusedRowIndex state; on ArrowUp/ArrowDown, move focus to previous/next row button.\n  - Ensure no keyboard trap; Esc does nothing.\n\n13) Accessibility\n- Ensure labels for search and filters; fieldset/legend for checkbox group.\n- Buttons have accessible names; list has role=list and each row role=listitem (implicit via li).\n- Use aria-live=\"polite\" for result count updates.\n- Status badges must pass color contrast (use text + background choices accordingly).\n- Focus outline visible for interactive elements.\n\n14) Performance considerations\n- For now, simple list rendering; add react-window virtualization only if list size > ~500 in future tasks.\n- useMemo for filteredTasks to avoid unnecessary re-computation when typing.\n\n15) Testing\n- Unit tests (renderer) for filter function with cases: search only, status only, combined, empty, case-insensitive.\n- Component tests with React Testing Library:\n  - Renders from mocked API data and shows correct counts and rows.\n  - Search narrows results; clearing restores.\n  - Status filters work (single and multiple selections).\n  - Empty states render appropriately.\n  - Keyboard: Enter/Space triggers navigation; Tab focus order correct.\n  - Basic a11y using jest-axe (no violations for the page core flow).\n\n16) Type safety and linting\n- Strongly type IPC payloads and window.tasksAPI. Ensure no any leaks.\n- Add eslint rules for accessibility (jsx-a11y) if not already present.\n\n17) Visual polish\n- Status badge styles: todo (gray), in_progress (blue), blocked (red), done (green).\n- Monospace for IDs, truncate long titles, consistent spacing.\n\n18) Documentation\n- docs/ui/tasks-list.md: overview, data shape, IPC contract, component responsibilities, a11y notes, and testing strategy.\n\n19) Integration checklist (acceptance criteria mapping)\n- Renders list from IPC data: Verify getTasks IPC wired and list displays items.\n- Filtering/search applied client-side: Verify search and status filters adjust the derived list without re-fetch.\n- Empty states handled: No data, no matches, error, and loading states exist and are readable.\n- Accessibility basics covered: Labels, fieldset/legend, focus, keyboard activation, aria-live counts, contrast for badges.\n\n20) Optional: live updates hook (future)\n- Outline but do not implement now: an IPC event 'tasks:updated' + preload onUpdated(callback) to refresh list when tasks change.\n",
      "context": [],
      "acceptance": [],
      "dependencies":["4.2"]
    },
    {
      "id": "4.4",
      "status": "-",
      "title": "Task details view with feature list and editing notes/fields",
      "description": "Create a detail page showing the task metadata and its features with statuses. Implement controlled editing for permitted fields (e.g., description, notes, status) with schema validation and disk write-back via task:update IPC. Provide change preview and basic error handling. Acceptance: Edits persist to task.json on disk, schema-valid; changes reflected in UI and index; guard rails prevent schema-breaking updates; unit/e2e tests simulate common edits.",
      "plan": "Implementation Plan: Task details view with feature list and editing notes/fields\n\n1) Data model and validation\n4.1 Define a canonical task schema in a shared module\n    - Create src/shared/schemas/task.ts using Zod (or Ajv if preferred) to describe the full task JSON shape.\n      Example (adjust to existing project fields if present):\n        const TaskStatus = z.enum([\"todo\",\"in-progress\",\"blocked\",\"done\"]);\n        const Feature = z.object({ id: z.string(), title: z.string(), status: TaskStatus, description: z.string().optional(), acceptance: z.string().optional() });\n        export const TaskSchema = z.object({\n          id: z.string(),\n          title: z.string(),\n          status: TaskStatus,\n          description: z.string().default(\"\"),\n          notes: z.string().default(\"\"),\n          priority: z.string().optional(),\n          features: z.array(Feature).default([]),\n          // ...add other known metadata with safe defaults\n        });\n        export type Task = z.infer<typeof TaskSchema>;\n    - Define AllowedEditableFields = [\"description\", \"notes\", \"status\"].\n    - Export a helper validateTask(data): { ok: boolean; value?: Task; error?: string }.\n\n4.2 Stable JSON formatting utility\n    - Add src/shared/json.ts with export function stableStringify(obj) using JSON.stringify(obj, null, 2) for consistent diffs.\n\n2) Main process: tasks service and IPC\n4.1 Tasks service for read/write\n    - Create src/main/services/tasks.ts with functions:\n      - getTaskPath(id: string): string – resolve to tasks/<id>/task.json (or pull from config).\n      - readTask(id: string): Promise<{ task: Task; version: { mtimeMs: number; hash: string } }>\n        • Read JSON, parse, validate with TaskSchema.\n        • Compute version: mtimeMs from fs.stat and hash via sha256(stringified file).\n      - updateTask(id: string, changes: Partial<Pick<Task, typeof AllowedEditableFields[number]>>, baseVersion: { mtimeMs: number; hash: string }): Promise<{ task: Task }>\n        • Read current file and version.\n        • Concurrency guard: if current.hash !== baseVersion.hash or mtime differs beyond tolerance, throw { code: 'VERSION_CONFLICT' }.\n        • Whitelist: Filter changes to AllowedEditableFields only; type-check each value.\n        • Merge: const next = { ...current, ...filteredChanges }.\n        • Validate next with TaskSchema; if invalid, throw { code: 'VALIDATION_ERROR', details }.\n        • Atomic write: write to tmp file (path + \".tmp\") with stableStringify, fs.rename to target; optionally create a .bak first if desired.\n        • Return updated task.\n\n4.2 IPC channels\n    - In src/main/ipc/tasks.ts register handlers in app ready:\n      - ipcMain.handle('task:get', async (_, { id }) => readTask(id))\n      - ipcMain.handle('task:update', async (_, { id, changes, baseVersion }) => {\n          try { const { task } = await updateTask(id, changes, baseVersion); \n                win.webContents.send('tasks:updated', { id, task });\n                return { ok: true, task }; \n          } catch (e) { return { ok: false, error: serializeIpcError(e) }; }\n        })\n    - Implement serializeIpcError to map codes: VERSION_CONFLICT, VALIDATION_ERROR, FS_ERROR.\n\n3) Renderer: routing and data access\n3.1 Route\n    - Add route /tasks/:id to the React Router. Create pages/TaskDetailsPage.tsx.\n\n3.2 IPC client helpers\n    - Add src/renderer/ipc/tasks.ts:\n      - getTask(id): invoke('task:get', { id }).\n      - updateTask(id, changes, baseVersion): invoke('task:update', { id, changes, baseVersion }).\n      - subscribeUpdated(cb): ipcRenderer.on('tasks:updated', cb) (cleanup on unmount).\n\n4) UI: Task details page\n4.1 Layout\n    - Header: task title, ID, and editable Status select (restricted to enum values).\n    - Metadata section: show non-editable fields (priority, etc.).\n    - Description: Markdown editor textarea with live preview toggle; sanitize with DOMPurify on preview.\n    - Notes: Simple textarea (or Markdown too if desired) with preview toggle.\n    - Features list: read-only table/list of features with their statuses; show badge colors by status.\n    - Actions: Save, Cancel, and a \"Preview changes\" button to open a modal showing diffs.\n\n4.2 State management\n    - Fetch on mount: const { task, version } = await getTask(id); keep originalTaskRef and baseVersionRef.\n    - Local form state: use React state or react-hook-form; initialize with task fields.\n    - Dirty tracking: compute isDirty by shallow comparing editable fields to original. Prompt on route change/close if dirty (beforeunload and router blocker).\n\n4.3 Change preview modal\n    - Build a list of field diffs only for AllowedEditableFields that changed.\n    - For text fields (description, notes): show side-by-side or inline unified diff (use diff-match-patch or fast-diff) plus a Markdown-rendered preview of new content.\n    - For status: show from -> to.\n\n4.4 Save flow\n    - Build changes object with only fields that differ and pass baseVersion from initial load.\n    - Call updateTask via IPC; on success:\n      • Update originalTaskRef and baseVersionRef using result of a fresh getTask(id) (or use returned task and recompute version with a subsequent get if needed).\n      • Update local state to match saved task.\n      • Emit toast \"Task saved\" and close preview modal if open.\n      • Let tasks list or other views update via 'tasks:updated' event in their stores.\n    - On error:\n      • VERSION_CONFLICT: show modal explaining file changed externally; options: Reload (discard edits), Overwrite anyway (disable for this feature, or allow via forcing update by skipping version check — keep it out-of-scope to stay safe), Copy my edits to clipboard.\n      • VALIDATION_ERROR: highlight offending fields and show message.\n      • FS_ERROR: show retry/cancel.\n\n4.5 Guard rails in UI\n    - Only render controls for AllowedEditableFields.\n    - Enforce enum for status.\n    - Limit description/notes length with soft max (e.g., 100k chars) to avoid huge writes.\n    - Sanitize markdown preview.\n\n5) Index/list synchronization\n    - Wherever the task index is shown, subscribe to 'tasks:updated' and update the in-memory store for that id.\n    - Verify that after saving, the index reflects new status/description snippet.\n\n6) Testing\n6.1 Unit tests (Jest)\n    - task schema: accepts valid tasks; rejects invalid statuses; defaults missing description/notes/features.\n    - tasks service updateTask:\n      • Applies only whitelisted fields; rejects extra keys.\n      • Fails on version conflict; succeeds after reread.\n      • Validates and writes atomically (use memfs or tmp dirs; verify final file contents).\n    - IPC handlers: return shapes { ok: true/false } and map errors correctly.\n\n6.2 Component tests (React Testing Library)\n    - TaskDetailsPage renders metadata, features list, and editable fields.\n    - Editing description toggles dirty state and enables Save.\n    - Preview modal shows correct diffs for text and status.\n    - On save success, dirty state clears and toast appears.\n    - Validation error displays correctly (mock IPC).\n\n6.3 E2E tests (Playwright or Spectron)\n    - Launch app with a fixture project containing a sample task.json.\n    - Navigate to Task details; modify description and status; open preview; save; verify disk file content changed and index view shows updated status.\n    - Simulate external change (modify file between load and save) and verify conflict handling dialog.\n\n7) Implementation details and utilities\n7.1 Hashing and versioning\n    - Use node:crypto createHash('sha256').update(fileContents).digest('hex').\n    - Store and pass both mtimeMs and hash, but rely on hash for conflict decision.\n\n7.2 Atomic write helper\n    - writeAtomic(path, contents): write to path + '.tmp', fs.fsync, rename to path. Optionally keep a .bak on first write in dev.\n\n7.3 Markdown rendering\n    - Use markdown-it or marked in renderer; sanitize with DOMPurify; allow code highlighting if available.\n\n7.4 Error mapping\n    - Standardize IPC error payload: { code, message, details? } and avoid exposing stack traces in renderer.\n\n8) Documentation\n    - Add docs/dev/task-details.md covering:\n      • Task schema and editable fields\n      • IPC contract for task:get and task:update\n      • Concurrency behavior\n      • How to add a new editable field safely\n      • Testing instructions\n\n9) Acceptance checklist mapping\n    - Edits persist to task.json on disk: Verified via unit (memfs) and e2e (real file) tests.\n    - Schema-valid: Main process validates with TaskSchema; tests cover invalid updates.\n    - Changes reflected in UI and index: 'tasks:updated' event updates stores; e2e asserts list shows new status.\n    - Guard rails prevent schema-breaking updates: Whitelist in main, enum constraints in UI and validator; unit tests cover.\n    - Unit/e2e tests simulate common edits: Description/notes/status success; invalid status fail; version conflict path.",
      "context": [],
      "acceptance": [],
      "dependencies":["4.3"]
    }
  ]
}
