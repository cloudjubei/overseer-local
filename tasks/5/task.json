{
  "id": 5,
  "status": "-",
  "title": "Extra chat features",
  "description": "",
  "features": [
    {
      "id": "5.1",
      "status": "-",
      "title": "LLM connector abstraction and providers (LiteLLM, OpenAI-compatible)",
      "description": "Design an abstraction for chat providers. Implement connectors for: (1) LiteLLM-compatible HTTP endpoint, (2) OpenAI-compatible custom base URL to support LM Studio / Ollama. Configurable API key, base URL, model name, timeouts. Acceptance: Provider interface documented; connectors unit-tested with mocked servers; UI to add/edit providers; failing requests produce actionable errors.",
      "plan": "Feature: LLM connector abstraction and providers (LiteLLM, OpenAI-compatible)\n\nGoal\n- Provide a clean provider interface for chat.\n- Implement two connectors:\n  1) LiteLLM-compatible HTTP endpoint\n  2) OpenAI-compatible with custom base URL (supports LM Studio, Ollama in OpenAI-compat mode)\n- Configurable API key, base URL, model name, timeouts.\n- UI to add/edit/test providers and select default.\n- Unit tests with mocked servers; actionable errors on failure.\n\nAssumptions\n- Electron + React app with main (Node) and renderer (React). We keep secrets (API keys) in main process and communicate via IPC.\n- HTTP requests from main process to avoid CORS and protect keys.\n- For Ollama, we rely on OpenAI-compatible endpoint (e.g., LM Studio / Ollama openai-compat servers exposing /v1/chat/completions).\n\nHigh-level Architecture\n- src/common: shared types and zod schemas.\n- src/main/llm: provider abstractions, connectors, registry, HTTP client, error mapper, service.\n- src/main/config: provider config store (encrypted storage for secrets when possible).\n- src/main/ipc: IPC channels for provider CRUD, test, and chat execute.\n- src/renderer/modules/providers: React UI for list/add/edit/test, validation, error display.\n- tests/main/llm: unit tests for connectors using mocked servers (nock or msw/node).\n\nDeliverables\n- Provider interface documented in code and docs.\n- LiteLLM and OpenAI-compatible connectors.\n- Config persistence with validation and masking of secrets in UI.\n- IPC endpoints for CRUD/test/execute.\n- UI for add/edit/test providers and set default provider.\n- Unit tests with mocked servers; actionable errors.\n\nStep-by-step Plan\n\n1) Define Types and Schemas (src/common)\n- Chat types:\n  - ChatMessage: { role: 'system' | 'user' | 'assistant' | 'tool', content: string }\n  - ChatOptions: { model: string; temperature?: number; maxTokens?: number; stop?: string[]; timeoutMs?: number; stream?: boolean }\n  - ChatResponse: { id: string; content: string; usage?: { promptTokens?: number; completionTokens?: number; totalTokens?: number }; raw?: unknown }\n- Provider identity/types:\n  - ProviderId: string\n  - ProviderKind: 'litellm' | 'openai_compat'\n- Config schemas (zod):\n  - Base provider config: { id: string; name: string; kind: ProviderKind; baseUrl: string; apiKey?: string; model: string; timeoutMs?: number; extraHeaders?: Record<string,string> }\n  - Validation ensures baseUrl is URL, model non-empty, timeout reasonable (1s-120s), headers safe keys.\n- AppError shape and error codes:\n  - AppError: { code: 'NETWORK'|'TIMEOUT'|'AUTH'|'RATE_LIMIT'|'NOT_FOUND'|'BAD_REQUEST'|'SERVER'|'UNSUPPORTED'|'UNKNOWN', httpStatus?: number, hint?: string, details?: unknown }\n\n2) Provider Interface (src/main/llm/IChatProvider.ts)\n- export interface IChatProvider {\n  - readonly id: string\n  - readonly kind: ProviderKind\n  - configure(cfg: ProviderConfig): void // validates\n  - testConnection(): Promise<{ ok: true } | { ok: false; error: AppError }>\n  - chat(messages: ChatMessage[], options?: ChatOptions): Promise<ChatResponse>\n  - supportsStreaming(): boolean // may return false initially\n}\n- Provide a helper type for ProviderConfig.\n- Document expectations: chat should map errors to AppError; all connectors must honor timeoutMs and abort requests.\n\n3) HTTP Client Helper (src/main/llm/http.ts)\n- buildFetch(baseUrl, path, method, headers, body, timeoutMs): Promise<Response>\n  - Uses node-fetch or undici; supports AbortController for timeout.\n  - Merges default headers + extraHeaders; inject Authorization: Bearer <apiKey> when apiKey present.\n  - Converts network/timeout errors into AppError.\n- parseJSON(response): safe JSON parse with AppError on invalid JSON.\n\n4) Error Mapping Utility (src/main/llm/errorMapper.ts)\n- fromHttpResponse(resp: Response, payload: any): AppError\n  - 401/403 -> AUTH with hint: 'Check API key and base URL.'\n  - 404 -> NOT_FOUND with hint: 'Verify model name and endpoint path.'\n  - 429 -> RATE_LIMIT with hint: 'Reduce request rate or increase model quota.'\n  - 400 -> BAD_REQUEST with hint: 'Verify request fields, model supports options.'\n  - 5xx -> SERVER with hint: 'Server error; retry later or check provider.'\n  - else -> UNKNOWN.\n- fromException(err: unknown): AppError\n  - ECONNREFUSED/ENOTFOUND -> NETWORK with hint to check server reachable.\n  - Timeout -> TIMEOUT with hint to increase timeout or ensure server responsiveness.\n\n5) Provider Registry (src/main/llm/registry.ts)\n- In-memory registry mapping providerId -> instance implementing IChatProvider.\n- loadProvidersFromStore() builds instances and configures them.\n- getDefaultProviderId()/setDefaultProviderId().\n- CRUD operations update store and registry.\n\n6) Config Persistence (src/main/config/providersStore.ts)\n- Use electron-store or lowdb. Prefer electron-store for simplicity.\n- Store schema: { providers: ProviderConfig[]; defaultProviderId?: string }\n- Secrets handling:\n  - Use keytar to store apiKey per providerId when available; Store only a placeholder or empty in electron-store; On load, hydrate config with apiKey from keytar.\n  - Fallback: Electron safeStorage encrypt; else plaintext with a warning flag.\n- Provide functions: list(), get(id), upsert(cfg), remove(id), setDefault(id), getSecret(id)/setSecret(id, apiKey).\n\n7) Implement LiteLLMConnector (src/main/llm/connectors/LiteLLMProvider.ts)\n- Endpoint: baseUrl + '/v1/chat/completions'\n- Request body follows OpenAI chat format: { model, messages: [{role, content}], temperature, max_tokens, stop, stream: false }\n- chat():\n  - Validate config and messages.\n  - Call HTTP helper with timeout.\n  - On non-2xx, map error via errorMapper.\n  - On 2xx, parse JSON and map to ChatResponse (content from choices[0].message.content, usage if available).\n- testConnection():\n  - Strategy A: Make a lightweight POST with a short prompt 'ping' and max_tokens: 2.\n  - Or Strategy B: GET baseUrl + '/v1/models' if LiteLLM supports; If 200, ok. Prefer Strategy B if available; fallback to A.\n- supportsStreaming(): false for now (can be extended later).\n\n8) Implement OpenAICompatibleProvider (src/main/llm/connectors/OpenAICompatProvider.ts)\n- Same request/response shape as LiteLLM (OpenAI-spec).\n- Endpoint: baseUrl + '/v1/chat/completions'\n- testConnection():\n  - Try GET baseUrl + '/v1/models' (LM Studio supports; Ollama openai-compat generally supports too). Fallback to tiny chat as above.\n\n9) Unit Tests with Mocked Servers (tests/main/llm)\n- Testing framework: vitest.\n- Mock HTTP: nock or msw/node. Use nock for simplicity.\n- Test cases common to both providers:\n  - chat success: returns expected content and usage.\n  - 401/403 -> AUTH error with hint.\n  - 404 -> NOT_FOUND with hint.\n  - 429 -> RATE_LIMIT with hint.\n  - 400 -> BAD_REQUEST.\n  - 500 -> SERVER.\n  - malformed JSON -> UNKNOWN with details.\n  - network error (ECONNREFUSED) -> NETWORK.\n  - timeout -> TIMEOUT when exceeding timeoutMs.\n- testConnection paths:\n  - models endpoint success.\n  - models endpoint missing -> fallback tiny chat.\n  - tiny chat failure -> returns error.\n- Config validation tests:\n  - Reject invalid baseUrl, missing model, unreasonable timeout.\n\n10) IPC Layer (src/main/ipc/llm.ts)\n- Channels and payload schemas (zod on both ends):\n  - llm.providers.list -> returns array of provider configs with apiKey status masked.\n  - llm.providers.get(id)\n  - llm.providers.upsert(cfg, secret?) -> validates; stores cfg and secret via keytar; loads into registry.\n  - llm.providers.remove(id)\n  - llm.providers.setDefault(id)\n  - llm.providers.test(id) -> calls provider.testConnection()\n  - llm.chat.execute({ providerId?, messages, options }) -> resolves with ChatResponse or AppError.\n- Ensure errors are serialized using AppError shape for renderer.\n\n11) Renderer UI (src/renderer/modules/providers)\n- ProvidersPage: list providers with name, kind, baseUrl, model, default badge.\n- Add/Edit Provider Modal/Form:\n  - Fields: name, kind (select), baseUrl, model, apiKey (password field, masked; show \"stored\" indicator), timeoutMs, extra headers JSON (optional advanced section).\n  - Client-side validation mirrors zod schema; server-side validation via IPC on save.\n  - Buttons: Save, Test Connection, Cancel.\n  - Test Connection triggers IPC test; display status (success with checkmark; error shows code, message, hint).\n- Set Default: action on list row to set default provider.\n- Error presentation:\n  - Use a reusable Alert component to display AppError code, human-readable message, and hint.\n\n12) Actionable Error Strategy\n- Standardize human-readable messages for each AppError.code plus context, e.g.:\n  - AUTH: \"Authentication failed. Check API key and permissions.\"\n  - NETWORK: \"Cannot reach server. Verify base URL and that the server is running.\"\n  - TIMEOUT: \"The request timed out. Try increasing timeout or ensuring the server responds promptly.\"\n  - RATE_LIMIT: \"Rate limit exceeded. Slow down requests or increase quota.\"\n  - NOT_FOUND: \"Resource not found. Check model name or endpoint path.\"\n  - BAD_REQUEST: \"Request was invalid. Review options like temperature, max tokens, and message formatting.\"\n  - SERVER: \"Provider server error. Try again later.\"\n- Include any response error.message in details dropdown for debugging.\n\n13) Documentation\n- docs/llm_providers.md\n  - Overview of Provider interface, method contracts, error mapping, and configuration.\n  - How to add a new provider connector (template/boilerplate).\n  - Examples for LiteLLM, LM Studio, Ollama (OpenAI-compat): sample baseUrl and typical models.\n  - Security notes about API key storage (keytar) and fallbacks.\n\n14) Developer Experience\n- Add scripts:\n  - test:unit: llm connectors tests.\n  - typecheck.\n- TypeDoc or JSDoc for IChatProvider and connectors.\n\n15) Manual QA Matrix\n- LiteLLM on localhost:\n  - Valid key and baseUrl -> chat works.\n  - Wrong key -> AUTH error.\n  - Wrong path/baseUrl -> NETWORK/NOT_FOUND.\n- LM Studio:\n  - baseUrl http://localhost:1234; model name available; chat works.\n  - Missing model -> NOT_FOUND or BAD_REQUEST with hint.\n- Ollama (openai-compat mode):\n  - baseUrl http://localhost:11434/v1; known model; chat works.\n  - Stop server -> NETWORK error in UI.\n- UI: add, edit, test, set default; masked apiKey display.\n\n16) Future-proofing (optional, behind flags)\n- Streaming support (Server-Sent Events) in providers and IPC if needed later.\n- List models endpoint to assist UI selection when available.\n\n17) Definition of Done\n- Provider interface defined and documented.\n- LiteLLM and OpenAI-compatible connectors implemented.\n- Unit tests passing with mocked servers covering success and common failure modes.\n- UI flows to add/edit/test providers and set default provider.\n- Actionable error messages surfaced in UI.\n- Minimal documentation committed.\n\nImplementation Notes\n- Use undici for HTTP in main process for performance.\n- Use zod for config validation and IPC payload validation.\n- Use keytar for secure secret storage; provide graceful fallback with warning if unavailable.\n- Ensure no API keys are ever sent to renderer or persisted in plaintext configs.\n- Keep connectors small and leverage shared HTTP + error mapping utilities to avoid duplication.\n",
      "context": [],
      "acceptance": [],
      "dependencies":["2.13"]
    },
    {
      "id": "5.2",
      "status": "-",
      "title": "Read-only tool adapters for chat",
      "description": "Implement tools accessible from chat with strict read-only capabilities: read_file, list_dir (scoped to project root), docs_index, read_doc, tasks_index, get_task, git_status, list_agents, agent_log_tail. Enforce allowlists and path sandboxing. Acceptance: Tools cannot write to disk; attempts to escape sandbox blocked; usage audited/logged; tool registry exposes metadata; covered by security unit tests.",
      "plan": "Implementation Plan: Read-only tool adapters for chat (Feature 5.16)\n\n1) Define scope, constraints, and foundations\n   2.2. Tech stack: Node.js/TypeScript backend in Electron main process (or a local service), React for UI. Use zod for runtime schema validation and type inference. Use child_process.execFile for git (no shell) and fs/promises for file I/O.\n   2.2. Project root: Determine a single projectRoot directory at app startup (configurable via settings, defaults to the app workspace directory). All file-based tools must operate strictly within this root or an allowlisted subset of it.\n   2.3. Read-only enforcement: Registry will only expose tools flagged readOnly=true to the chat layer. Do not register any mutating tools here. Ensure all implementations avoid write operations.\n\n2) Core security utilities\n   2.2. Path sandboxing helper: create util pathSafe.ts with functions:\n       - resolveInsideRoot(root: string, input: string): string\n         • Uses path.resolve(root, input) and fs.realpath on the final path.\n         • Reject if resolved path does not start with root + path.sep.\n         • Reject NUL bytes, drive letter tricks, and normalize to POSIX-like expectations while supporting Windows.\n       - assertInsideRoot(root: string, target: string): void throws on violation.\n       - sanitizeRelPath(input: string): remove trailing slashes, collapse .., prohibit absolute and UNC.\n   2.2. Symlink handling: Always fs.realpath the target; reject if it resolves outside projectRoot.\n   2.3. Rate limiting middleware for tools (basic): per-session and per-tool token bucket, e.g., 10 calls/min default; overridable per tool metadata.\n   2.4. Size limits: impose maximum read sizes (e.g., read_file: 512 KB cap; agent_log_tail: 10 KB cap; list_dir: 500 entries cap) to prevent resource abuse.\n\n3) Tool Registry and metadata\n   3.2. Define Tool interface:\n       - name: string\n       - description: string\n       - readOnly: true\n       - paramsSchema: zod schema\n       - execute(ctx: { projectRoot: string; sessionId: string; userId?: string }, params: unknown): Promise<JSON-serializable>\n       - allowedRoots?: string[] (relative to projectRoot) for extra scoping (e.g., docs/*).\n       - rateLimit?: { callsPerMinute?: number }\n   3.2. Implement ToolRegistry:\n       - register(tool: Tool)\n       - list(): metadata only (no execute)\n       - get(name): returns tool instance\n       - Only expose readOnly tools to chat integration.\n   3.3. Tool metadata endpoint for UI: return list of tools with name, description, paramsSchema (JSON representation), readOnly flag, limits, and allowedRoots.\n\n4) Audit logging\n   4.2. Implement AuditLogger writing JSONL to logs/chat-tools.log and in-memory buffer for quick UI display.\n       - Fields: ts, sessionId, userId, tool, allowed (bool), paramsRedacted (apply simple redaction for paths), resultMeta { bytes?, items? }, error?\n   4.2. Hook audit logs in a middleware:\n       - Before execution: validate and check allowlists/sandbox; if fail, log denied and throw.\n       - After execution: log summary (sizes, counts), but never raw file contents.\n\n5) Implement tools (all readOnly=true)\n   Common: validate params via zod; enforce allowedRoots by pre-resolving base root = projectRoot or projectRoot/allowedRoot; use resolveInsideRoot; apply size limits; audit.\n   5.2. read_file\n       - Params: { path: string; encoding?: 'utf8'|'base64'='utf8'; maxBytes?: number }\n       - Resolve path within projectRoot; fs.stat; cap size to min(requested, 512KB default); read and return { content, bytes, truncated }.\n   5.2. list_dir\n       - Params: { path?: string; depth?: 1|2=1; includeFiles?: boolean=true; includeDirs?: boolean=true; maxEntries?: number=500 }\n       - Base is projectRoot if path missing. Use fs.readdir({ withFileTypes: true }); depth-limited recursion; return entries with { name, type, size?, mtime } for first level; enforce caps.\n   5.3. docs_index\n       - AllowedRoots: [\"docs\", \"README.md\", \"CONTRIBUTING.md\"]\n       - Walk projectRoot/docs and selected top-level README*.md; extract top-level headings (# ...); return tree of docs with relative paths, titles, size, mtime.\n   5.4. read_doc\n       - Params: { path: string }\n       - Only within docs and top-level *.md allowlist; reuse read_file with stricter allowedRoots; return content and front-matter (if present) parsed read-only.\n   5.5. tasks_index\n       - Assumption: tasks stored via TaskStore (existing or to be created) reading from a JSON/db in project data dir. Implement a read-only adapter: TaskStore.listPublic() returning id, title, status, assignee, updatedAt, tags (no sensitive notes by default).\n       - Params: { status?: string[]; limit?: number=200; q?: string }\n       - Server-side filter and return lightweight list.\n   5.6. get_task\n       - Params: { id: string; includeNotes?: boolean=false }\n       - Read from TaskStore; if includeNotes is true, still read-only; optionally redact private fields via configuration.\n   5.7. git_status\n       - Params: { porcelain?: boolean=true; branch?: boolean=true }\n       - Use execFile('git', ['status','--porcelain=v2','--branch']) with cwd=projectRoot; no shell; timeout 5s; return stdout parsed into structured fields (branch, ahead/behind, changes[]), plus raw for display.\n   5.8. list_agents\n       - Params: none\n       - Read from AgentManager registry: return [{ id, name, status: 'idle'|'running'|'error', currentTask?, pid?, startedAt?, lastHeartbeatAt? }]. Ensure only metadata, no control actions.\n   5.9. agent_log_tail\n       - Params: { agentId: string; lines?: number=200; maxBytes?: number=10240 }\n       - Source from in-memory ring buffer maintained by AgentManager; fallback to a per-agent log file under projectRoot/.logs/agents/<id>.log (ensure allowedRoots to .logs/agents only); return last lines up to limits.\n\n6) Chat integration (read-only)\n   6.2. In the chat tool-calling layer, fetch ToolRegistry.list() and expose only readOnly tools. Bind invocation to the execute method with session context.\n   6.2. Validate all incoming tool calls against the registry (no dynamic tool names). Deny any tool not in allowlist or with params failing schema; audit as denied.\n   6.3. Add UI affordance: In the chat panel, show an \"Available tools\" dropdown with metadata and parameter hints; show audit log sidebar for recent tool calls in-session.\n\n7) Configuration\n   7.2. Add settings keys: projectRoot (string), toolRateLimits (per tool), docsRoots (override), taskStoreConfig (path/driver), logDir (default projectRoot/.logs), maxReadBytes defaults.\n   7.2. Ensure settings changes require restart for projectRoot and logDir to avoid TOCTOU issues.\n\n8) Testing: security and functionality\n   8.2. Unit tests (Jest):\n       - Path sandbox: attempts to use '../', absolute paths, UNC, null bytes → rejected.\n       - Symlink outside root: create tmp structure with symlink to /etc or outside temp dir → rejected by resolveInsideRoot.\n       - read_file truncation: large file truncated at cap with truncated=true.\n       - list_dir caps: excessive entries trimmed; depth respected.\n       - docs_index restricts to docs + top-level allowlist only.\n       - git_status uses execFile without shell; malicious args not possible; timeout enforced.\n       - ToolRegistry exposes readOnly only; non-existent tool invocation rejected.\n       - Audit logging: allowed and denied calls recorded; no content leaked in logs.\n       - Rate limiting: exceed limit → 429-like error; audit recorded.\n   8.2. Integration tests:\n       - Chat tool invocation flow: call each tool with valid params; verify outputs and audit entries.\n       - Attempt escape via path traversal in chat → denied and audited.\n\n9) Documentation\n   9.2. docs/dev/chat-tools.md: architecture, registry API, metadata schema (JSON), security model, limits, examples.\n   9.2. docs/user/chat-tools-usage.md: how the chat uses tools, visible metadata, privacy notes.\n\n10) Delivery\n   10.2. Wire up CI to run security/unit tests on PR.\n   10.2. Add a feature flag or version tag: tools.readOnly.v2.\n   10.3. Open a follow-up ticket for write-capable tools with separate explicit opt-in and stricter security review.\n",
      "context": [],
      "acceptance": [],
      "dependencies":["2.14"]
    },
    {
      "id": "2.16",
      "status": "-",
      "title": "Chat tool permissions and admin gating",
      "description": "Add UI and backend enforcement for enabling/disabling tools per session. Provide a clear indicator in the chat UI of which tools are enabled. Acceptance: Disabled tools are not invocable; permissions persist; attempting to call a disabled tool returns a controlled error; tests verify enforcement at IPC and provider levels.",
      "plan": "Feature 5.17: Chat tool permissions and admin gating\n\nGoal\n- Add UI and backend enforcement for enabling/disabling tools per chat session.\n- Provide a clear indicator in the chat UI of which tools are enabled.\n- Disabled tools are not invocable; permissions persist across app restarts.\n- Attempting to call a disabled tool returns a controlled error.\n- Tests verify enforcement at both IPC and provider levels.\n\nAssumptions and Repo Layout\n- Electron + React app with:\n  - main/ (Electron main process, IPC, persistence)\n  - renderer/ (React/TS UI)\n  - common/ (shared types, constants)\n  - providers/ (LLM providers and tool execution layer)\n  - tools/ (tool registry and implementations)\n- Chat sessions already exist with IDs; LLM tool calling is centralized via a tool registry and provider wrappers.\n\n1) Data Model and Types\n2.1 Create shared types in common/types/tools.ts:\n- export type ToolId = string\n- export type ToolCapability = 'read' | 'write'\n- export interface ToolDescriptor {\n    id: ToolId\n    name: string\n    description: string\n    capability: ToolCapability\n    scope: 'chat' | 'agent' | 'both'\n    defaultEnabledInChat?: boolean // default true only for read-only tools\n  }\n- export interface SessionToolPermissions {\n    sessionId: string\n    allowedToolIds: ToolId[]\n    updatedAt: string\n  }\n- export interface ToolPermissionErrorPayload {\n    code: 'TOOL_DISABLED'\n    message: string\n    toolId: ToolId\n  }\n\n2.2 Define admin gating types in common/types/admin.ts:\n- export interface AdminSettings { enabled: boolean; pinHash?: string }\n- export interface AdminState { active: boolean; activatedAt?: string }\n\n2) Tool Registry Updates\n2.1 In tools/registry.ts, ensure each tool has a ToolDescriptor including capability and scope.\n- Mark read-only tools with capability: 'read' (e.g., git.status, fs.readFile, search.index).\n- Write tools flagged as 'write' (e.g., fs.writeFile, git.commit).\n- Set defaultEnabledInChat true only for read-only tools.\n\n2.2 Export helper functions:\n- listAllTools(): ToolDescriptor[]\n- listChatTools(): ToolDescriptor[] // scope chat/both\n- listReadOnlyChatTools(): ToolDescriptor[] // capability read\n\n3) Persistence Layer\n3.1 Add a new file main/persistence/permissionsStore.ts using electron-store or simple JSON in appData:\n- Methods:\n  - getSessionPermissions(sessionId): SessionToolPermissions | null\n  - setSessionPermissions(perm: SessionToolPermissions): void\n  - migrateIfNeeded(): void\n- On migrateIfNeeded, for sessions lacking permissions, set allowedToolIds to listReadOnlyChatTools().map(t => t.id).\n\n3.2 Admin settings persistence main/persistence/adminStore.ts:\n- getAdminSettings(): AdminSettings\n- setAdminSettings(settings: AdminSettings): void\n- getAdminState(): AdminState (in-memory)\n- setAdminState(state: AdminState): void\n\n4) Permission Manager (Backend Enforcement)\n4.1 Create main/security/permissionManager.ts:\n- class PermissionManager {\n    constructor(permissionsStore, adminStore, toolRegistry)\n    getAllowedTools(sessionId): ToolDescriptor[]\n    isToolAllowed(sessionId, toolId): boolean\n    requireAdmin(): void // throws if AdminState.active=false and AdminSettings.enabled=true\n    updateSessionPermissions(sessionId, allowedToolIds: ToolId[]): void // validates toolIds belong to listChatTools; if AdminSettings.enabled, requireAdmin\n    ensureDefaults(sessionId): void // set defaults if missing\n  }\n- Validate that only tools with scope chat/both can be enabled for chat sessions.\n- Extra guard: if a tool capability is 'write', allow it only if explicitly enabled via UI (no default).\n\n4.2 Define a specific error class in common/errors.ts:\n- export class ToolPermissionError extends Error { code='TOOL_DISABLED'; toolId: ToolId; }\n\n5) IPC API\n5.1 Define IPC channels in common/ipc.ts:\n- 'chat.getPermissions' -> (sessionId) => SessionToolPermissions\n- 'chat.updatePermissions' -> (sessionId, allowedToolIds) => SessionToolPermissions (admin gated)\n- 'tools.list' -> ({scope?: 'chat'|'agent'|'both'}) => ToolDescriptor[]\n- 'chat.invokeTool' -> ({sessionId, toolId, args}) => ToolResult | ToolPermissionErrorPayload\n- 'admin.enableMode' -> ({pin}) => {active: boolean}\n- 'admin.disableMode' -> () => {active: boolean}\n- 'admin.status' -> () => AdminState\n- 'admin.updateSettings' -> ({enabled, pin}) => AdminSettings (admin gated or if no PIN set yet)\n\n5.2 Implement handlers in main/ipc/chatTools.ts:\n- chat.getPermissions: permissionManager.ensureDefaults(sessionId); return permissionsStore.getSessionPermissions(sessionId)\n- chat.updatePermissions: permissionManager.requireAdmin(); validate IDs; save; return updated\n- tools.list: filter by scope\n- chat.invokeTool:\n  - if !permissionManager.isToolAllowed(sessionId, toolId) -> return { code: 'TOOL_DISABLED', message: 'Tool is disabled for this session', toolId }\n  - else forward to tool execution pipeline\n\n5.3 Implement admin handlers in main/ipc/admin.ts:\n- admin.enableMode: verify pin by comparing hash (use bcrypt/scrypt); set AdminState.active=true; return state\n- admin.disableMode: set active=false\n- admin.status: return AdminState\n- admin.updateSettings: if settings.pinHash not set, allow setting; else requireAdmin; store enabled flag and new pinHash if provided\n\n6) Provider-Level Enforcement\n6.1 When constructing tool/function list for the LLM provider (providers/*):\n- Add a function buildAllowedToolDefs(sessionId): returns only tools allowed by PermissionManager.\n- Ensure provider.request() for a chat session passes only these tool definitions to the model.\n\n6.2 In the tool execution layer (tools/executor.ts):\n- Before executing any tool invocation, call permissionManager.isToolAllowed(sessionId, toolId). If false, throw ToolPermissionError so backend catches and returns controlled error payload via IPC.\n\n7) UI: Permissions Indicator and Admin Gating\n7.1 Add a ChatHeaderTools component in renderer/components/chat/ChatHeaderTools.tsx:\n- Button \"Tools\" showing a badge with count of enabled tools (e.g., 5).\n- Clicking opens a side drawer or modal listing chat-scope tools grouped by capability:\n  - Enabled tools: toggle on\n  - Disabled tools: toggle off\n  - Non-interactive when not in Admin Mode and AdminSettings.enabled (show lock icon tooltip \"Admin mode required\")\n- Controls:\n  - Search/filter tools\n  - Reset to defaults\n  - Apply/save (disabled unless changes + admin if required)\n\n7.2 Admin Mode UI in renderer/components/admin/AdminMode.tsx:\n- Status indicator in app header (shield icon): Active/Inactive\n- Button to Enable Admin Mode -> opens PIN prompt modal\n- Button to Disable Admin Mode\n- Preferences page to enable/disable admin gating and set/change PIN (if gating enabled). If PIN not yet set, allow set without admin mode; otherwise require admin mode.\n\n7.3 Chat Input area indicator:\n- Under the text input, display a pill row: \"Tools enabled:\" followed by chips for enabled tool names (truncated + tooltip). When zero enabled, show warning chip \"No tools enabled\".\n\n7.4 Error surfacing:\n- If chat.invokeTool returns TOOL_DISABLED, append a system message bubble: \"Tool <name> is disabled for this session. Ask an admin to enable it.\" with a shortcut button opening the Tools drawer.\n\n7.5 State management:\n- Redux/Zustand slice: permissionsSlice with state per session { allowedToolIds, loading, error }\n- Effects to load on chat mount: fetch tools.list(scope='chat') and chat.getPermissions(sessionId)\n- Actions to update: chat.updatePermissions -> refresh state and toast success\n- Admin slice: adminState and adminSettings with IPC bindings\n\n8) Security and Validation\n- Renderer never trusted: IPC handlers enforce permissions and admin gating\n- Validate allowedToolIds against registry; drop unknown IDs\n- If AdminSettings.enabled=false, allow toggles without Admin Mode (backward compatible dev mode)\n- Admin mode times out after 15 minutes of inactivity: implement in AdminState using timestamp + periodic check; auto-disable and notify UI\n\n9) Migrations\n- On app startup, permissionsStore.migrateIfNeeded() creates allowedToolIds for each existing chat session with defaults (read-only chat tools)\n- Maintain backup of previous sessions file: sessions.json.bak\n\n10) Error Codes and Mapping\n- Standardize error payload for disabled tools: { code:'TOOL_DISABLED', message, toolId }\n- Map ToolPermissionError to this payload in IPC and provider error paths\n- Ensure renderer gracefully handles this in chat stream or single-shot calls\n\n11) Tests\n12.1 Unit tests (jest) for PermissionManager:\n- Defaults applied for new sessions\n- isToolAllowed true/false logic across read/write tools\n- updateSessionPermissions rejects non-chat tools or unknown IDs\n- requireAdmin throws when admin gating enabled and not active\n\n12.2 IPC integration tests (using spectron/electron-mocha or electron-playwright):\n- chat.invokeTool on disabled tool returns TOOL_DISABLED\n- chat.updatePermissions blocked without admin when gating enabled; succeeds when admin active\n- tools.list returns proper scope filtering\n\n12.3 Provider tests:\n- buildAllowedToolDefs excludes disabled tools\n- Tool executor throws ToolPermissionError when a tool invocation arrives for a disabled tool (simulate function_call from model)\n\n12.4 UI tests (Playwright):\n- Tools drawer shows enabled/disabled states and count badge updates when toggled\n- With Admin gating on and admin inactive, toggles are disabled and lock icon shown\n- Enabling Admin Mode allows toggling and persists after reload\n- Attempt to use disabled tool shows system message and disabled state persists after app restart\n\n12) Documentation\n- Update README/User Guide: Managing chat tool permissions, Admin Mode, defaults, and error messages\n- Admin Guide: How to set/change PIN, enable gating, session defaults, and timeout behavior\n- Security note: renderer not trusted; all checks in main process\n\n13) Rollout and Acceptance Checklist\n- Feature flag: Admin gating enabled by default = true; PIN required; initial PIN must be set on first attempt to enable Admin Mode\n- Acceptance criteria mapping:\n  - Disabled tools not invocable -> Verified by IPC and provider tests and manual QA\n  - Permissions persist -> Restart app and verify allowedToolIds saved and reloaded\n  - Attempt to call disabled tool returns controlled error -> TOOL_DISABLED payload shown in UI\n  - Tests at IPC and provider levels -> Implemented as above\n\n14) Implementation Order\n2. Types and registry updates\n2. Persistence stores\n3. PermissionManager and error class\n4. IPC handlers (chat + admin)\n5. Provider enforcement (tool list filtering and executor checks)\n6. UI components and state slices\n7. Migrations and defaults\n8. Tests (unit -> integration -> UI)\n9. Documentation\n\n15) Notes\n- Keep the tool IDs stable and human-readable (e.g., 'git.status', 'fs.readFile')\n- For hashing PINs, use bcrypt with salt; store only hash\n- Ensure no tool invocation path bypasses PermissionManager (audit calls)\n- Consider telemetry/logging for permission denials (local-only)\n",
      "context": [],
      "acceptance": [],
      "dependencies":["2.15"]
    },
    {
      "id": "2.17",
      "status": "-",
      "title": "Context retrieval for chat (RAG-lite)",
      "description": "Implement simple keyword-based search over project docs and tasks. Allow user to attach retrieved snippets into context before sending. Optionally auto-attach top-k snippets with a toggle. Acceptance: Search returns ranked results quickly; selected snippets previewed; tokens limited by model configuration; unit tests confirm deterministic retrieval on fixed corpora.",
      "plan": "Feature: Context retrieval for chat (RAG-lite)\n\nGoal\n- Implement fast, deterministic keyword-based search over project docs and tasks.\n- Let users preview and select snippets to attach to chat context.\n- Optional auto-attach top-k snippets with token-budget enforcement.\n- Provide unit tests ensuring deterministic retrieval ordering on a fixed corpus.\n\nHigh-level architecture\n- Main process (Electron): File scanning, indexing, search service (read-only), exposed via IPC.\n- Common package: Tokenizer, BM25 scoring, types, token counting.\n- Renderer (React): UI for search, selection, preview, token budget display, auto-attach toggle; integration with chat send pipeline.\n\n1) Data sources and scope\n2.1 Define corpus roots from current project settings: projectRoot/docs/**/*.md, projectRoot/tasks/**/*.(md|json|yaml), and future adapters (extensible).\n2.2 Exclude large/binary/unwanted paths: node_modules, .git, .env*, build artifacts, images, >2MB files by default.\n2.3 Add a simple adapter interface: CorpusAdapter { id, name, globPatterns, parse(file) -> {doc: Document | chunkedDocs[]} } to support docs and tasks uniformly.\n\n2) Common library (packages/common)\n2.1 Types (src/common/rag/types.ts)\n- RawDocument: { id, source: 'docs'|'tasks'|'other', path, title, content, meta? }\n- Chunk: { id, docId, chunkIndex, text, tokensApprox, title, path, source, meta }\n- SearchResult: { chunkId, docId, score, highlights: { start, end }[], preview: string, title, path, source }\n- RagConfig: { chunkSizeChars: number, chunkOverlapChars: number, stopwords: string[], bm25: { k1: number, b: number }, maxFileSizeBytes: number }\n2.2 Deterministic tokenizer (src/common/rag/tokenizer.ts)\n- Lowercase, Unicode NFKD normalize, strip diacritics, remove punctuation, split on non-letter/digit, stopword removal.\n- Expose tokenize(text): string[] and matchOffsets(text, terms) -> [{start,end,term}].\n- Keep deterministic ordering for ties by stable sort rules.\n2.3 BM25 scorer (src/common/rag/bm25.ts)\n- Build index from chunks: DF per term, avg doc length, per-chunk term frequencies.\n- Implement BM25 with k1=2.2, b=0.75 defaults; deterministic score + tie-break rule: higher score, then higher sum of IDF, then path lexicographically, then chunkIndex asc.\n2.4 Token counting (src/common/rag/tokens.ts)\n- Provide two methods: approxCharsToTokens(chars/4) and optional tiktoken via dynamic import if available (documented opt-in). Default to approx for zero-dependency.\n\n3) Main process: index and search (packages/main)\n3.1 File discovery and watching (src/main/rag/fileWatcher.ts)\n- Use chokidar to watch configured glob patterns for adapters.\n- On add/change/unlink: schedule incremental reindex for affected file (debounced).\n3.2 Adapters (src/main/rag/adapters)\n- docsAdapter.ts: read markdown, extract title (first H1 or filename), split into chunks by heading or fixed window (config.chunkSizeChars with overlap).\n- tasksAdapter.ts: parse md/json/yaml; extract task fields (id, title, description, notes) and emit chunks from description/notes.\n3.3 Index builder (src/main/rag/indexer.ts)\n- Build/maintain in-memory index: { chunks[], lexicon, df, avgLen }.\n- Persist snapshot to disk (appData/rag/index.json) with corpus hash to accelerate startup.\n- Deterministic ordering guaranteed by sorting and stable data structures.\n3.4 Search service (src/main/rag/search.ts)\n- search(query: string, k: number): tokenize query, compute BM25 scores, select top-k, generate previews (first N chars around highlight), and highlight offsets.\n- Enforce max results and timeouts; results returned in under ~100ms for medium corpora via precomputed structures.\n3.5 IPC API (src/main/rag/ipc.ts)\n- rag:buildIndex(): force rebuild; rag:getStatus(): { docs, chunks, lastBuildAt, ready }.\n- rag:search({ query, k }): return SearchResult[].\n- rag:getConfig()/rag:setConfig(partial): allow tuning chunk size, stopwords, k1, b.\n- Rate-limit search requests and ensure read-only operations.\n\n4) Renderer: state and hooks (packages/renderer)\n4.1 Global state (Zustand or Redux) (src/renderer/store/ragSlice.ts)\n- query, results, selectedChunkIds, autoAttachEnabled, topK, tokenBudget, modelMaxTokens, attachmentTokensUsed.\n- Actions: setQuery, search, toggleSelect(chunkId), clearSelection, setAutoAttach, setTopK, setTokenBudget, setModelMaxTokens.\n4.2 Hook (src/renderer/hooks/useRag.ts)\n- Debounced search tied to query changes (250ms debounce).\n- Calculates per-snippet tokens via tokens.approx; computes total selection tokens; prevents exceeding budget.\n\n5) Renderer: UI components\n5.1 Chat context panel (src/renderer/components/chat/ChatContextPanel.tsx)\n- Search input, auto-attach toggle, top-k selector, results list.\n- Each result shows title, source badge (Docs/Tasks), path, score bar (subtle), highlighted terms, and a 3-5 line preview.\n- Checkbox to select snippets; footer shows Selected N, Tokens total/limit; Attach Selected button.\n5.2 Selected attachments bar (src/renderer/components/chat/ContextAttachmentsBar.tsx)\n- Lists selected snippets as chips with token count and remove button; open-in-viewer action.\n5.3 Settings modal (src/renderer/components/settings/RagSettings.tsx)\n- Configure: chunk size/overlap, k1/b, default topK, token budget strategy, model max tokens, stopwords list.\n\n6) Chat send integration\n6.1 Message pipeline middleware (src/renderer/chat/sendMiddleware/ragContext.ts)\n- On send: if auto-attach enabled and no manual selection, perform a search using current composer text as query; pick topK within remaining token budget (modelMaxTokens - safety margin - current prompt tokens - system tokens - existing attachments).\n- Merge manual selections with auto-attach (deduplicate).\n- Construct a context block message preceding user message (e.g., role: \"system\" or a structured \"context\" metadata) with a header and the selected snippets with sources.\n- Enforce token budget: drop tail snippets if budget exceeded; show a toast when truncation occurs.\n\n7) Determinism and performance guarantees\n7.1 Deterministic sort: implement explicit tiebreak strategy and stable sorting; pin config defaults; pin stopwords list.\n7.2 Cache index snapshot and warm it on startup; show small status in UI (Indexing..., Ready).\n7.3 Debounced search in UI and IPC result streaming to keep interactions snappy.\n\n8) Unit tests (Vitest)\n8.1 Tokenizer tests (tests/rag/tokenizer.spec.ts)\n- Normalization, stopwords removal, punctuation handling, non-ASCII diacritics.\n8.2 BM25 tests (tests/rag/bm25.spec.ts)\n- Known corpus with 5-10 chunks; verify exact ordered results for fixed queries; tie-break rules verified.\n8.3 Indexer/search integration (tests/rag/search.spec.ts)\n- Build small in-memory index; run queries; verify preview generation and highlight offsets; ensure same order across runs.\n8.4 Token budget tests (tests/rag/tokens.spec.ts)\n- Approximate token counts and enforcement logic.\n\n9) Developer experience\n9.1 Dev commands\n- yarn rag:rebuild to trigger IPC buildIndex; yarn test:rag to run unit tests.\n9.2 Logging\n- Scoped logs: RAG:Indexer, RAG:Search, RAG:UI; disable in production.\n\n10) Documentation\n10.1 README-RAG.md\n- Overview, design choices, determinism guarantees, configuration, performance tips, privacy (local-only), and how to extend adapters.\n10.2 Third-party considerations\n- Default implementation is dependency-light. Optionally allow swapping to lunr/minisearch via an adapter in future; document trade-offs.\n\n11) Acceptance criteria mapping\n- Fast ranked results: Debounced UI + BM25 index with precomputed stats; verified via manual test and logs.\n- Selected snippets previewed: UI components show preview and highlights; attachments bar confirms selection.\n- Tokens limited by model configuration: Settings define modelMaxTokens; middleware enforces budget, shows live totals.\n- Deterministic retrieval: Unit tests validate order on fixed corpus; deterministic tokenizer + explicit tie-breakers.\n\n12) Implementation order\n1) Common lib (tokenizer, bm25, tokens, types).\n2) Main indexer + adapters + search + IPC.\n3) Renderer store + hook + basic UI with manual selection and attachment.\n4) Send middleware with token budget and auto-attach toggle.\n5) Unit tests.\n6) Docs and polish (highlights, file watcher, settings UI).\n\n13) Validation checklist\n- [ ] Index builds on startup; status \"Ready\" visible.\n- [ ] Query returns ranked results within ~100ms on typical corpora.\n- [ ] Selecting results updates token totals; cannot exceed budget.\n- [ ] Auto-attach top-k adds context when sending with toggle on.\n- [ ] Unit tests pass and confirm deterministic ordering.\n- [ ] No write operations exposed; read-only search only.",
      "context": [],
      "acceptance": [],
      "dependencies":["2.16"]
    }
  ]
}
